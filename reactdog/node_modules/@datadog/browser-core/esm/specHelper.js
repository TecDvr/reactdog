import { __assign, __awaiter, __generator } from "tslib";
import { noop } from './utils';
export var SPEC_ENDPOINTS = {
    internalMonitoringEndpoint: 'https://monitoring-intake.com/abcde?foo=bar',
    logsEndpoint: 'https://logs-intake.com/abcde?foo=bar',
    rumEndpoint: 'https://rum-intake.com/abcde?foo=bar',
    traceEndpoint: 'https://trace-intake.com/abcde?foo=bar',
};
export function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
export function isFirefox() {
    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
}
export function isIE() {
    return navigator.userAgent.indexOf('MSIE ') > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./);
}
export function clearAllCookies() {
    document.cookie.split(';').forEach(function (c) {
        document.cookie = c.replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
    });
}
var FetchStubBuilder = /** @class */ (function () {
    function FetchStubBuilder(_a) {
        var _this = this;
        var requestStartObservable = _a[0], requestCompleteObservable = _a[1];
        this.requests = [];
        this.whenAllCompleteFn = noop;
        var pendingFetch = 0;
        requestStartObservable.subscribe(function () {
            pendingFetch += 1;
        });
        requestCompleteObservable.subscribe(function (request) {
            _this.requests.push(request);
            pendingFetch -= 1;
            if (pendingFetch === 0) {
                // ensure that AssertionError are not swallowed by promise context
                setTimeout(function () {
                    _this.whenAllCompleteFn(_this.requests);
                });
            }
        });
    }
    FetchStubBuilder.prototype.whenAllComplete = function (onCompleteFn) {
        this.whenAllCompleteFn = onCompleteFn;
    };
    FetchStubBuilder.prototype.getStub = function () {
        var _this = this;
        return (function () {
            var resolve;
            var reject;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            promise.resolveWith = function (response) { return __awaiter(_this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, resolve(__assign(__assign({}, response), { clone: function () {
                                var cloned = {
                                    text: function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            if (response.responseTextError) {
                                                throw response.responseTextError;
                                            }
                                            return [2 /*return*/, response.responseText];
                                        });
                                    }); },
                                };
                                return cloned;
                            } }))];
                });
            }); };
            promise.rejectWith = function (error) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, reject(error)];
            }); }); };
            return promise;
        });
    };
    return FetchStubBuilder;
}());
export { FetchStubBuilder };
var PerformanceObserverStubBuilder = /** @class */ (function () {
    function PerformanceObserverStubBuilder() {
    }
    PerformanceObserverStubBuilder.prototype.getEntryTypes = function () {
        // tslint:disable-next-line: no-unsafe-any
        return this.instance.entryTypes;
    };
    PerformanceObserverStubBuilder.prototype.fakeEntry = function (entry, entryType) {
        var asEntryList = function () { return [entry]; };
        // tslint:disable-next-line: no-unsafe-any
        this.instance.callback({
            getEntries: asEntryList,
            getEntriesByName: asEntryList,
            getEntriesByType: function (type) {
                if (type === entryType) {
                    return asEntryList();
                }
                return [];
            },
        });
    };
    PerformanceObserverStubBuilder.prototype.getStub = function () {
        var _a;
        // tslint:disable-next-line:no-this-assignment
        var builder = this;
        return _a = /** @class */ (function () {
                function class_1(callback) {
                    this.callback = callback;
                    builder.instance = this;
                }
                class_1.prototype.observe = function (options) {
                    if (options) {
                        // tslint:disable-next-line: no-unsafe-any
                        builder.instance.entryTypes = options.entryTypes;
                    }
                };
                return class_1;
            }()),
            _a.supportedEntryTypes = ['navigation'],
            _a;
    };
    return PerformanceObserverStubBuilder;
}());
export { PerformanceObserverStubBuilder };
export function setPageVisibility(visibility) {
    Object.defineProperty(document, 'visibilityState', {
        get: function () {
            return visibility;
        },
        configurable: true,
    });
}
export function restorePageVisibility() {
    delete document.visibilityState;
}
//# sourceMappingURL=specHelper.js.map