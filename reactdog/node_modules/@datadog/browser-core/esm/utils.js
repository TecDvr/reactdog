import { __assign, __spreadArrays } from "tslib";
export var ONE_SECOND = 1000;
export var ONE_MINUTE = 60 * ONE_SECOND;
export var ONE_HOUR = 60 * ONE_MINUTE;
export var ONE_KILO_BYTE = 1024;
export var DOM_EVENT;
(function (DOM_EVENT) {
    DOM_EVENT["BEFORE_UNLOAD"] = "beforeunload";
    DOM_EVENT["CLICK"] = "click";
    DOM_EVENT["KEY_DOWN"] = "keydown";
    DOM_EVENT["LOAD"] = "load";
    DOM_EVENT["POP_STATE"] = "popstate";
    DOM_EVENT["SCROLL"] = "scroll";
    DOM_EVENT["TOUCH_START"] = "touchstart";
    DOM_EVENT["VISIBILITY_CHANGE"] = "visibilitychange";
})(DOM_EVENT || (DOM_EVENT = {}));
export var ResourceKind;
(function (ResourceKind) {
    ResourceKind["DOCUMENT"] = "document";
    ResourceKind["XHR"] = "xhr";
    ResourceKind["BEACON"] = "beacon";
    ResourceKind["FETCH"] = "fetch";
    ResourceKind["CSS"] = "css";
    ResourceKind["JS"] = "js";
    ResourceKind["IMAGE"] = "image";
    ResourceKind["FONT"] = "font";
    ResourceKind["MEDIA"] = "media";
    ResourceKind["OTHER"] = "other";
})(ResourceKind || (ResourceKind = {}));
// use lodash API
export function throttle(fn, wait, options) {
    var needLeadingExecution = options && options.leading !== undefined ? options.leading : true;
    var needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;
    var inWaitPeriod = false;
    var hasPendingExecution = false;
    var pendingTimeoutId;
    var isStopped = false;
    return {
        throttled: function () {
            var _this = this;
            if (isStopped) {
                return;
            }
            if (inWaitPeriod) {
                hasPendingExecution = true;
                return;
            }
            if (needLeadingExecution) {
                fn.apply(this);
            }
            else {
                hasPendingExecution = true;
            }
            inWaitPeriod = true;
            pendingTimeoutId = window.setTimeout(function () {
                if (needTrailingExecution && hasPendingExecution) {
                    fn.apply(_this);
                }
                inWaitPeriod = false;
                hasPendingExecution = false;
            }, wait);
        },
        stop: function () {
            window.clearTimeout(pendingTimeoutId);
            isStopped = true;
        },
    };
}
var isContextArray = function (value) { return Array.isArray(value); };
var isContext = function (value) { return !Array.isArray(value) && typeof value === 'object'; };
/**
 * Performs a deep merge of objects and arrays
 * - arrays values are merged index by index
 * - objects are merged by keys
 * - values get replaced, unless undefined
 *
 * ⚠️ this method does not prevent infinite loops while merging circular references ⚠️
 *
 */
export function deepMerge(destination) {
    var toMerge = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        toMerge[_i - 1] = arguments[_i];
    }
    return toMerge.reduce(function (value1, value2) {
        if (isContextArray(value1) && isContextArray(value2)) {
            return __spreadArrays(Array(Math.max(value1.length, value2.length))).map(function (_, index) {
                return deepMerge(value1[index], value2[index]);
            });
        }
        if (isContext(value1) && isContext(value2)) {
            return Object.keys(value2).reduce(function (merged, key) {
                var _a;
                return (__assign(__assign({}, merged), (_a = {}, _a[key] = deepMerge(value1[key], value2[key]), _a)));
            }, value1);
        }
        return value2 === undefined ? value1 : value2;
    }, destination);
}
export function assign(target) {
    var toAssign = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        toAssign[_i - 1] = arguments[_i];
    }
    toAssign.forEach(function (source) {
        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    });
}
/**
 * UUID v4
 * from https://gist.github.com/jed/982883
 */
export function generateUUID(placeholder) {
    return placeholder
        ? // tslint:disable-next-line no-bitwise
            (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)
        : (1e7 + "-" + 1e3 + "-" + 4e3 + "-" + 8e3 + "-" + 1e11).replace(/[018]/g, generateUUID);
}
/**
 * Return true if the draw is successful
 * @param threshold between 0 and 100
 */
export function performDraw(threshold) {
    return threshold !== 0 && Math.random() * 100 <= threshold;
}
export function round(num, decimals) {
    return +num.toFixed(decimals);
}
export function msToNs(duration) {
    return round(duration * 1e6, 0);
}
export function withSnakeCaseKeys(candidate) {
    var result = {};
    Object.keys(candidate).forEach(function (key) {
        result[toSnakeCase(key)] = deepSnakeCase(candidate[key]);
    });
    return result;
}
export function deepSnakeCase(candidate) {
    if (Array.isArray(candidate)) {
        return candidate.map(function (value) { return deepSnakeCase(value); });
    }
    if (typeof candidate === 'object') {
        return withSnakeCaseKeys(candidate);
    }
    return candidate;
}
export function toSnakeCase(word) {
    return word
        .replace(/[A-Z]/g, function (uppercaseLetter, index) { return "" + (index !== 0 ? '_' : '') + uppercaseLetter.toLowerCase(); })
        .replace(/-/g, '_');
}
// tslint:disable-next-line:no-empty
export function noop() { }
/**
 * Custom implementation of JSON.stringify that ignores value.toJSON.
 * We need to do that because some sites badly override toJSON on certain objects.
 * Note this still supposes that JSON.stringify is correct...
 */
export function jsonStringify(value, replacer, space) {
    if (value === null || value === undefined) {
        return JSON.stringify(value);
    }
    var originalToJSON = [false, undefined];
    if (hasToJSON(value)) {
        // We need to add a flag and not rely on the truthiness of value.toJSON
        // because it can be set but undefined and that's actually significant.
        originalToJSON = [true, value.toJSON];
        delete value.toJSON;
    }
    var originalProtoToJSON = [false, undefined];
    var prototype;
    if (typeof value === 'object') {
        prototype = Object.getPrototypeOf(value);
        if (hasToJSON(prototype)) {
            originalProtoToJSON = [true, prototype.toJSON];
            delete prototype.toJSON;
        }
    }
    var result;
    try {
        result = JSON.stringify(value, undefined, space);
    }
    catch (_a) {
        result = '<error: unable to serialize object>';
    }
    finally {
        if (originalToJSON[0]) {
            ;
            value.toJSON = originalToJSON[1];
        }
        if (originalProtoToJSON[0]) {
            ;
            prototype.toJSON = originalProtoToJSON[1];
        }
    }
    return result;
}
function hasToJSON(value) {
    return typeof value === 'object' && value !== null && value.hasOwnProperty('toJSON');
}
export function includes(candidate, search) {
    // tslint:disable-next-line: no-unsafe-any
    return candidate.indexOf(search) !== -1;
}
export function find(array, predicate) {
    for (var i = 0; i < array.length; i += 1) {
        var item = array[i];
        if (predicate(item, i, array)) {
            return item;
        }
    }
    return undefined;
}
export function isPercentage(value) {
    return isNumber(value) && value >= 0 && value <= 100;
}
export function isNumber(value) {
    return typeof value === 'number';
}
/**
 * Get the time since the navigation was started.
 *
 * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual
 * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.
 * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926
 */
export function getRelativeTime(timestamp) {
    return timestamp - getNavigationStart();
}
export function getTimestamp(relativeTime) {
    return Math.floor(getNavigationStart() + relativeTime);
}
/**
 * Navigation start slightly change on some rare cases
 */
var navigationStart;
export function getNavigationStart() {
    if (navigationStart === undefined) {
        navigationStart = performance.timing.navigationStart;
    }
    return navigationStart;
}
export function objectValues(object) {
    var values = [];
    Object.keys(object).forEach(function (key) {
        values.push(object[key]);
    });
    return values;
}
export function objectEntries(object) {
    return Object.keys(object).map(function (key) { return [key, object[key]]; });
}
export function isEmptyObject(object) {
    return Object.keys(object).length === 0;
}
/**
 * inspired by https://mathiasbynens.be/notes/globalthis
 */
export function getGlobalObject() {
    if (typeof globalThis === 'object') {
        return globalThis;
    }
    Object.defineProperty(Object.prototype, '_dd_temp_', {
        get: function () {
            return this;
        },
        configurable: true,
    });
    // @ts-ignore
    var globalObject = _dd_temp_;
    // @ts-ignore
    delete Object.prototype._dd_temp_;
    if (typeof globalObject !== 'object') {
        // on safari _dd_temp_ is available on window but not globally
        // fallback on other browser globals check
        if (typeof self === 'object') {
            globalObject = self;
        }
        else if (typeof window === 'object') {
            globalObject = window;
        }
        else {
            globalObject = {};
        }
    }
    return globalObject;
}
export function getLocationOrigin() {
    return getLinkElementOrigin(window.location);
}
/**
 * IE fallback
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin
 */
export function getLinkElementOrigin(element) {
    if (element.origin) {
        return element.origin;
    }
    var sanitizedHost = element.host.replace(/(:80|:443)$/, '');
    return element.protocol + "//" + sanitizedHost;
}
//# sourceMappingURL=utils.js.map