import { __awaiter, __generator } from "tslib";
import { toStackTraceString } from './errorCollection';
import { monitor } from './internalMonitoring';
import { Observable } from './observable';
import { computeStackTrace } from './tracekit';
import { normalizeUrl } from './urlPolyfill';
export var RequestType;
(function (RequestType) {
    RequestType["FETCH"] = "fetch";
    RequestType["XHR"] = "xhr";
})(RequestType || (RequestType = {}));
var nextRequestId = 1;
function getNextRequestId() {
    var result = nextRequestId;
    nextRequestId += 1;
    return result;
}
var requestObservablesSingleton;
export function startRequestCollection() {
    if (!requestObservablesSingleton) {
        requestObservablesSingleton = [new Observable(), new Observable()];
        trackXhr(requestObservablesSingleton);
        trackFetch(requestObservablesSingleton);
    }
    return requestObservablesSingleton;
}
export function trackXhr(_a) {
    var requestStartObservable = _a[0], requestCompleteObservable = _a[1];
    var originalOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = monitor(function (method, url) {
        this._datadog_xhr = {
            method: method,
            url: url,
        };
        return originalOpen.apply(this, arguments);
    });
    var originalSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function (body) {
        var _this = this;
        var startTime = performance.now();
        var requestId = getNextRequestId();
        requestStartObservable.notify({
            requestId: requestId,
        });
        var hasBeenReported = false;
        var reportXhr = function () {
            if (hasBeenReported) {
                return;
            }
            hasBeenReported = true;
            requestCompleteObservable.notify({
                requestId: requestId,
                startTime: startTime,
                duration: performance.now() - startTime,
                method: _this._datadog_xhr.method,
                response: _this.response,
                status: _this.status,
                traceId: getTraceId(),
                type: RequestType.XHR,
                url: normalizeUrl(_this._datadog_xhr.url),
            });
        };
        var originalOnreadystatechange = this.onreadystatechange;
        this.onreadystatechange = function () {
            if (this.readyState === XMLHttpRequest.DONE) {
                monitor(reportXhr)();
            }
            if (originalOnreadystatechange) {
                originalOnreadystatechange.apply(this, arguments);
            }
        };
        this.addEventListener('loadend', monitor(reportXhr));
        return originalSend.apply(this, arguments);
    };
}
export function trackFetch(_a) {
    var requestStartObservable = _a[0], requestCompleteObservable = _a[1];
    if (!window.fetch) {
        return;
    }
    var originalFetch = window.fetch;
    // tslint:disable promise-function-async
    window.fetch = monitor(function (input, init) {
        var _this = this;
        var method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET';
        var startTime = performance.now();
        var requestId = getNextRequestId();
        requestStartObservable.notify({
            requestId: requestId,
        });
        var reportFetch = function (response) { return __awaiter(_this, void 0, void 0, function () {
            var duration, url, stackTrace, text, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        duration = performance.now() - startTime;
                        url = normalizeUrl((typeof input === 'object' && input.url) || input);
                        if (!('stack' in response || response instanceof Error)) return [3 /*break*/, 1];
                        stackTrace = computeStackTrace(response);
                        requestCompleteObservable.notify({
                            duration: duration,
                            method: method,
                            requestId: requestId,
                            startTime: startTime,
                            url: url,
                            response: toStackTraceString(stackTrace),
                            status: 0,
                            traceId: getTraceId(),
                            type: RequestType.FETCH,
                        });
                        return [3 /*break*/, 6];
                    case 1:
                        if (!('status' in response)) return [3 /*break*/, 6];
                        text = void 0;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, response.clone().text()];
                    case 3:
                        text = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        text = "Unable to retrieve response: " + e_1;
                        return [3 /*break*/, 5];
                    case 5:
                        requestCompleteObservable.notify({
                            duration: duration,
                            method: method,
                            requestId: requestId,
                            startTime: startTime,
                            url: url,
                            response: text,
                            responseType: response.type,
                            status: response.status,
                            traceId: getTraceId(),
                            type: RequestType.FETCH,
                        });
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        var responsePromise = originalFetch.call(this, input, init);
        responsePromise.then(monitor(reportFetch), monitor(reportFetch));
        return responsePromise;
    });
}
export function isRejected(request) {
    return request.status === 0 && request.responseType !== 'opaque';
}
export function isServerError(request) {
    return request.status >= 500;
}
/**
 * Get the current traceId generated from dd-trace-js (if any).
 *
 * Note: in order to work, the browser-sdk should be initialized *before* dd-trace-js because both
 * libraries are wrapping fetch() and XHR.  Wrappers are called in reverse order, and the
 * dd-trace-js wrapper needs to be called first so it can generate the new trace.  The browser-sdk
 * wrapper will then pick up the new trace id via this function.
 */
function getTraceId() {
    // tslint:disable-next-line: no-unsafe-any
    return 'ddtrace' in window && window.ddtrace.tracer.scope().active()
        ? // tslint:disable-next-line: no-unsafe-any
            window.ddtrace.tracer
                .scope()
                .active()
                .context()
                .toTraceId()
        : undefined;
}
//# sourceMappingURL=requestCollection.js.map