import { __spreadArrays } from "tslib";
import { monitor } from './internalMonitoring';
import { Observable } from './observable';
import { isRejected, isServerError, RequestType, startRequestCollection, } from './requestCollection';
import { computeStackTrace, report } from './tracekit';
import { jsonStringify, ONE_MINUTE } from './utils';
export var ErrorOrigin;
(function (ErrorOrigin) {
    ErrorOrigin["AGENT"] = "agent";
    ErrorOrigin["CONSOLE"] = "console";
    ErrorOrigin["NETWORK"] = "network";
    ErrorOrigin["SOURCE"] = "source";
    ErrorOrigin["LOGGER"] = "logger";
})(ErrorOrigin || (ErrorOrigin = {}));
var filteredErrorsObservable;
export function startErrorCollection(configuration) {
    if (!filteredErrorsObservable) {
        var errorObservable = new Observable();
        if (configuration.isCollectingError) {
            var _a = startRequestCollection(), requestCompleteObservable = _a[1];
            trackNetworkError(configuration, errorObservable, requestCompleteObservable);
            startConsoleTracking(errorObservable);
            startRuntimeErrorTracking(errorObservable);
        }
        filteredErrorsObservable = filterErrors(configuration, errorObservable);
    }
    return filteredErrorsObservable;
}
export function filterErrors(configuration, errorObservable) {
    var errorCount = 0;
    var filteredErrorObservable = new Observable();
    errorObservable.subscribe(function (error) {
        if (errorCount < configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify(error);
        }
        else if (errorCount === configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify({
                context: {
                    error: {
                        origin: ErrorOrigin.AGENT,
                    },
                },
                message: "Reached max number of errors by minute: " + configuration.maxErrorsByMinute,
                startTime: performance.now(),
            });
        }
    });
    setInterval(function () { return (errorCount = 0); }, ONE_MINUTE);
    return filteredErrorObservable;
}
var originalConsoleError;
export function startConsoleTracking(errorObservable) {
    originalConsoleError = console.error;
    console.error = monitor(function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        originalConsoleError.apply(console, __spreadArrays([message], optionalParams));
        errorObservable.notify({
            context: {
                error: {
                    origin: ErrorOrigin.CONSOLE,
                },
            },
            message: __spreadArrays(['console error:', message], optionalParams).map(formatConsoleParameters).join(' '),
            startTime: performance.now(),
        });
    });
}
export function stopConsoleTracking() {
    console.error = originalConsoleError;
}
function formatConsoleParameters(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (param instanceof Error) {
        return toStackTraceString(computeStackTrace(param));
    }
    return jsonStringify(param, undefined, 2);
}
var traceKitReportHandler;
export function startRuntimeErrorTracking(errorObservable) {
    traceKitReportHandler = function (stack, _, errorObject) {
        errorObservable.notify(formatRuntimeError(stack, errorObject));
    };
    report.subscribe(traceKitReportHandler);
}
export function stopRuntimeErrorTracking() {
    ;
    report.unsubscribe(traceKitReportHandler);
}
export function formatRuntimeError(stackTrace, errorObject) {
    var message;
    var stack;
    if (stackTrace.message === undefined && !(errorObject instanceof Error)) {
        message = "Uncaught " + jsonStringify(errorObject);
        stack = 'No stack, consider using an instance of Error';
    }
    else {
        message = stackTrace.message || 'Empty message';
        stack = toStackTraceString(stackTrace);
    }
    return {
        message: message,
        context: {
            error: {
                stack: stack,
                kind: stackTrace.name,
                origin: ErrorOrigin.SOURCE,
            },
        },
        startTime: performance.now(),
    };
}
export function toStackTraceString(stack) {
    var result = (stack.name || 'Error') + ": " + stack.message;
    stack.stack.forEach(function (frame) {
        var func = frame.func === '?' ? '<anonymous>' : frame.func;
        var args = frame.args && frame.args.length > 0 ? "(" + frame.args.join(', ') + ")" : '';
        var line = frame.line ? ":" + frame.line : '';
        var column = frame.line && frame.column ? ":" + frame.column : '';
        result += "\n  at " + func + args + " @ " + frame.url + line + column;
    });
    return result;
}
export function trackNetworkError(configuration, errorObservable, requestObservable) {
    requestObservable.subscribe(function (request) {
        if (isRejected(request) || isServerError(request)) {
            errorObservable.notify({
                context: {
                    error: {
                        origin: ErrorOrigin.NETWORK,
                        stack: truncateResponse(request.response, configuration) || 'Failed to load',
                    },
                    http: {
                        method: request.method,
                        status_code: request.status,
                        url: request.url,
                    },
                },
                message: format(request.type) + " error " + request.method + " " + request.url,
                startTime: request.startTime,
            });
        }
    });
}
function truncateResponse(response, configuration) {
    if (response && response.length > configuration.requestErrorResponseLengthLimit) {
        return response.substring(0, configuration.requestErrorResponseLengthLimit) + "...";
    }
    return response;
}
function format(type) {
    if (RequestType.XHR === type) {
        return 'XHR';
    }
    return 'Fetch';
}
//# sourceMappingURL=errorCollection.js.map