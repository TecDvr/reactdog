"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errorCollection_1 = require("./errorCollection");
var tracekit_1 = require("./tracekit");
var transport_1 = require("./transport");
var utils = tslib_1.__importStar(require("./utils"));
var StatusType;
(function (StatusType) {
    StatusType["info"] = "info";
    StatusType["error"] = "error";
})(StatusType || (StatusType = {}));
var monitoringConfiguration = { maxMessagesPerPage: 0, sentMessageCount: 0 };
var externalContextProvider;
function startInternalMonitoring(configuration) {
    if (configuration.internalMonitoringEndpoint) {
        var batch = new transport_1.Batch(new transport_1.HttpRequest(configuration.internalMonitoringEndpoint, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, function () {
            return utils.deepMerge({
                date: new Date().getTime(),
                view: {
                    referrer: document.referrer,
                    url: window.location.href,
                },
            }, externalContextProvider !== undefined ? externalContextProvider() : {});
        });
        utils.assign(monitoringConfiguration, {
            batch: batch,
            maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,
            sentMessageCount: 0,
        });
    }
    return {
        setExternalContextProvider: function (provider) {
            externalContextProvider = provider;
        },
    };
}
exports.startInternalMonitoring = startInternalMonitoring;
function resetInternalMonitoring() {
    monitoringConfiguration.batch = undefined;
}
exports.resetInternalMonitoring = resetInternalMonitoring;
function monitored(_, __, descriptor) {
    var originalMethod = descriptor.value;
    descriptor.value = function () {
        var decorated = (monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod);
        return decorated.apply(this, arguments);
    };
}
exports.monitored = monitored;
function monitor(fn) {
    return function () {
        try {
            return fn.apply(this, arguments);
        }
        catch (e) {
            logErrorIfDebug(e);
            try {
                addErrorToMonitoringBatch(e);
            }
            catch (e) {
                logErrorIfDebug(e);
            }
        }
    }; // consider output type has input type
}
exports.monitor = monitor;
function addMonitoringMessage(message) {
    logMessageIfDebug(message);
    addToMonitoringBatch({
        message: message,
        status: StatusType.info,
    });
}
exports.addMonitoringMessage = addMonitoringMessage;
function addErrorToMonitoringBatch(e) {
    addToMonitoringBatch(tslib_1.__assign(tslib_1.__assign({}, formatError(e)), { status: StatusType.error }));
}
function addToMonitoringBatch(message) {
    if (monitoringConfiguration.batch &&
        monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {
        monitoringConfiguration.sentMessageCount += 1;
        monitoringConfiguration.batch.add(message);
    }
}
function formatError(e) {
    if (e instanceof Error) {
        var stackTrace = tracekit_1.computeStackTrace(e);
        return {
            error: {
                kind: stackTrace.name,
                stack: errorCollection_1.toStackTraceString(stackTrace),
            },
            message: stackTrace.message,
        };
    }
    return {
        error: {
            stack: 'Not an instance of error',
        },
        message: "Uncaught " + utils.jsonStringify(e),
    };
}
function setDebugMode(debugMode) {
    monitoringConfiguration.debugMode = debugMode;
}
exports.setDebugMode = setDebugMode;
function logErrorIfDebug(e) {
    if (monitoringConfiguration.debugMode) {
        // Log as warn to not forward the logs.
        console.warn('[INTERNAL ERROR]', e);
    }
}
function logMessageIfDebug(message) {
    if (monitoringConfiguration.debugMode) {
        console.log('[MONITORING MESSAGE]', message);
    }
}
//# sourceMappingURL=internalMonitoring.js.map