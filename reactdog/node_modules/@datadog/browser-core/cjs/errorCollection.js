"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var internalMonitoring_1 = require("./internalMonitoring");
var observable_1 = require("./observable");
var requestCollection_1 = require("./requestCollection");
var tracekit_1 = require("./tracekit");
var utils_1 = require("./utils");
var ErrorOrigin;
(function (ErrorOrigin) {
    ErrorOrigin["AGENT"] = "agent";
    ErrorOrigin["CONSOLE"] = "console";
    ErrorOrigin["NETWORK"] = "network";
    ErrorOrigin["SOURCE"] = "source";
    ErrorOrigin["LOGGER"] = "logger";
})(ErrorOrigin = exports.ErrorOrigin || (exports.ErrorOrigin = {}));
var filteredErrorsObservable;
function startErrorCollection(configuration) {
    if (!filteredErrorsObservable) {
        var errorObservable = new observable_1.Observable();
        if (configuration.isCollectingError) {
            var _a = requestCollection_1.startRequestCollection(), requestCompleteObservable = _a[1];
            trackNetworkError(configuration, errorObservable, requestCompleteObservable);
            startConsoleTracking(errorObservable);
            startRuntimeErrorTracking(errorObservable);
        }
        filteredErrorsObservable = filterErrors(configuration, errorObservable);
    }
    return filteredErrorsObservable;
}
exports.startErrorCollection = startErrorCollection;
function filterErrors(configuration, errorObservable) {
    var errorCount = 0;
    var filteredErrorObservable = new observable_1.Observable();
    errorObservable.subscribe(function (error) {
        if (errorCount < configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify(error);
        }
        else if (errorCount === configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify({
                context: {
                    error: {
                        origin: ErrorOrigin.AGENT,
                    },
                },
                message: "Reached max number of errors by minute: " + configuration.maxErrorsByMinute,
                startTime: performance.now(),
            });
        }
    });
    setInterval(function () { return (errorCount = 0); }, utils_1.ONE_MINUTE);
    return filteredErrorObservable;
}
exports.filterErrors = filterErrors;
var originalConsoleError;
function startConsoleTracking(errorObservable) {
    originalConsoleError = console.error;
    console.error = internalMonitoring_1.monitor(function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        originalConsoleError.apply(console, tslib_1.__spreadArrays([message], optionalParams));
        errorObservable.notify({
            context: {
                error: {
                    origin: ErrorOrigin.CONSOLE,
                },
            },
            message: tslib_1.__spreadArrays(['console error:', message], optionalParams).map(formatConsoleParameters).join(' '),
            startTime: performance.now(),
        });
    });
}
exports.startConsoleTracking = startConsoleTracking;
function stopConsoleTracking() {
    console.error = originalConsoleError;
}
exports.stopConsoleTracking = stopConsoleTracking;
function formatConsoleParameters(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (param instanceof Error) {
        return toStackTraceString(tracekit_1.computeStackTrace(param));
    }
    return utils_1.jsonStringify(param, undefined, 2);
}
var traceKitReportHandler;
function startRuntimeErrorTracking(errorObservable) {
    traceKitReportHandler = function (stack, _, errorObject) {
        errorObservable.notify(formatRuntimeError(stack, errorObject));
    };
    tracekit_1.report.subscribe(traceKitReportHandler);
}
exports.startRuntimeErrorTracking = startRuntimeErrorTracking;
function stopRuntimeErrorTracking() {
    ;
    tracekit_1.report.unsubscribe(traceKitReportHandler);
}
exports.stopRuntimeErrorTracking = stopRuntimeErrorTracking;
function formatRuntimeError(stackTrace, errorObject) {
    var message;
    var stack;
    if (stackTrace.message === undefined && !(errorObject instanceof Error)) {
        message = "Uncaught " + utils_1.jsonStringify(errorObject);
        stack = 'No stack, consider using an instance of Error';
    }
    else {
        message = stackTrace.message || 'Empty message';
        stack = toStackTraceString(stackTrace);
    }
    return {
        message: message,
        context: {
            error: {
                stack: stack,
                kind: stackTrace.name,
                origin: ErrorOrigin.SOURCE,
            },
        },
        startTime: performance.now(),
    };
}
exports.formatRuntimeError = formatRuntimeError;
function toStackTraceString(stack) {
    var result = (stack.name || 'Error') + ": " + stack.message;
    stack.stack.forEach(function (frame) {
        var func = frame.func === '?' ? '<anonymous>' : frame.func;
        var args = frame.args && frame.args.length > 0 ? "(" + frame.args.join(', ') + ")" : '';
        var line = frame.line ? ":" + frame.line : '';
        var column = frame.line && frame.column ? ":" + frame.column : '';
        result += "\n  at " + func + args + " @ " + frame.url + line + column;
    });
    return result;
}
exports.toStackTraceString = toStackTraceString;
function trackNetworkError(configuration, errorObservable, requestObservable) {
    requestObservable.subscribe(function (request) {
        if (requestCollection_1.isRejected(request) || requestCollection_1.isServerError(request)) {
            errorObservable.notify({
                context: {
                    error: {
                        origin: ErrorOrigin.NETWORK,
                        stack: truncateResponse(request.response, configuration) || 'Failed to load',
                    },
                    http: {
                        method: request.method,
                        status_code: request.status,
                        url: request.url,
                    },
                },
                message: format(request.type) + " error " + request.method + " " + request.url,
                startTime: request.startTime,
            });
        }
    });
}
exports.trackNetworkError = trackNetworkError;
function truncateResponse(response, configuration) {
    if (response && response.length > configuration.requestErrorResponseLengthLimit) {
        return response.substring(0, configuration.requestErrorResponseLengthLimit) + "...";
    }
    return response;
}
function format(type) {
    if (requestCollection_1.RequestType.XHR === type) {
        return 'XHR';
    }
    return 'Fetch';
}
//# sourceMappingURL=errorCollection.js.map