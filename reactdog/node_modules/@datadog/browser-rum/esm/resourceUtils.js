import { addMonitoringMessage, getPathName, haveSameOrigin, includes, isValidUrl, msToNs, ResourceKind, } from '@datadog/browser-core';
export var FAKE_INITIAL_DOCUMENT = 'initial_document';
var RESOURCE_TYPES = [
    [ResourceKind.DOCUMENT, function (initiatorType) { return FAKE_INITIAL_DOCUMENT === initiatorType; }],
    [ResourceKind.XHR, function (initiatorType) { return 'xmlhttprequest' === initiatorType; }],
    [ResourceKind.FETCH, function (initiatorType) { return 'fetch' === initiatorType; }],
    [ResourceKind.BEACON, function (initiatorType) { return 'beacon' === initiatorType; }],
    [ResourceKind.CSS, function (_, path) { return path.match(/\.css$/i) !== null; }],
    [ResourceKind.JS, function (_, path) { return path.match(/\.js$/i) !== null; }],
    [
        ResourceKind.IMAGE,
        function (initiatorType, path) {
            return includes(['image', 'img', 'icon'], initiatorType) || path.match(/\.(gif|jpg|jpeg|tiff|png|svg)$/i) !== null;
        },
    ],
    [ResourceKind.FONT, function (_, path) { return path.match(/\.(woff|eot|woff2|ttf)$/i) !== null; }],
    [
        ResourceKind.MEDIA,
        function (initiatorType, path) {
            return includes(['audio', 'video'], initiatorType) || path.match(/\.(mp3|mp4)$/i) !== null;
        },
    ],
];
export function computeResourceKind(timing) {
    var url = timing.name;
    if (!isValidUrl(url)) {
        addMonitoringMessage("Failed to construct URL for \"" + timing.name + "\"");
        return ResourceKind.OTHER;
    }
    var path = getPathName(url);
    for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {
        var _a = RESOURCE_TYPES_1[_i], type = _a[0], isType = _a[1];
        if (isType(timing.initiatorType, path)) {
            return type;
        }
    }
    return ResourceKind.OTHER;
}
function areInOrder() {
    var numbers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        numbers[_i] = arguments[_i];
    }
    for (var i = 1; i < numbers.length; i += 1) {
        if (numbers[i - 1] > numbers[i]) {
            return false;
        }
    }
    return true;
}
export function computePerformanceResourceDuration(entry) {
    var duration = entry.duration, startTime = entry.startTime, responseEnd = entry.responseEnd;
    // Safari duration is always 0 on timings blocked by cross origin policies.
    if (duration === 0 && startTime < responseEnd) {
        return msToNs(responseEnd - startTime);
    }
    return msToNs(duration);
}
export function computePerformanceResourceDetails(entry) {
    var startTime = entry.startTime, fetchStart = entry.fetchStart, domainLookupStart = entry.domainLookupStart, domainLookupEnd = entry.domainLookupEnd, connectStart = entry.connectStart, secureConnectionStart = entry.secureConnectionStart, connectEnd = entry.connectEnd, requestStart = entry.requestStart, responseStart = entry.responseStart, responseEnd = entry.responseEnd;
    var redirectStart = entry.redirectStart, redirectEnd = entry.redirectEnd;
    // Ensure timings are in the right order.  On top of filtering out potential invalid
    // PerformanceResourceTiming, it will ignore entries from requests where timings cannot be
    // collected, for example cross origin requests without a "Timing-Allow-Origin" header allowing
    // it.
    if (!areInOrder(startTime, fetchStart, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, responseEnd)) {
        return undefined;
    }
    // The only time fetchStart is different than startTime is if a redirection occured.
    var hasRedirectionOccured = fetchStart !== startTime;
    if (hasRedirectionOccured) {
        // Firefox doesn't provide redirect timings on cross origin requests.  Provide a default for
        // those.
        if (redirectStart < startTime) {
            redirectStart = startTime;
        }
        if (redirectEnd < startTime) {
            redirectEnd = fetchStart;
        }
        // Make sure redirect timings are in order
        if (!areInOrder(startTime, redirectStart, redirectEnd, fetchStart)) {
            return undefined;
        }
    }
    var details = {
        download: formatTiming(startTime, responseStart, responseEnd),
        firstByte: formatTiming(startTime, requestStart, responseStart),
    };
    // Make sure a connection occured
    if (connectEnd !== fetchStart) {
        details.connect = formatTiming(startTime, connectStart, connectEnd);
        // Make sure a secure connection occured
        if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {
            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);
        }
    }
    // Make sure a domain lookup occured
    if (domainLookupEnd !== fetchStart) {
        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);
    }
    if (hasRedirectionOccured) {
        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);
    }
    return details;
}
function formatTiming(origin, start, end) {
    return {
        duration: msToNs(end - start),
        start: msToNs(start - origin),
    };
}
export function computeSize(entry) {
    // Make sure a request actually occured
    if (entry.startTime < entry.responseStart) {
        return entry.decodedBodySize;
    }
    return undefined;
}
export function isValidResource(url, configuration) {
    return url && !isBrowserAgentRequest(url, configuration);
}
function isBrowserAgentRequest(url, configuration) {
    return (haveSameOrigin(url, configuration.logsEndpoint) ||
        haveSameOrigin(url, configuration.rumEndpoint) ||
        haveSameOrigin(url, configuration.traceEndpoint) ||
        (configuration.internalMonitoringEndpoint && haveSameOrigin(url, configuration.internalMonitoringEndpoint)));
}
//# sourceMappingURL=resourceUtils.js.map