import { __assign } from "tslib";
import { Batch, deepMerge, getTimestamp, HttpRequest, includes, monitor, msToNs, RequestType, ResourceKind, withSnakeCaseKeys, } from '@datadog/browser-core';
import { LifeCycleEventType } from './lifeCycle';
import { matchRequestTiming } from './matchRequestTiming';
import { computePerformanceResourceDetails, computePerformanceResourceDuration, computeResourceKind, computeSize, isValidResource, } from './resourceUtils';
import { getUserActionReference, UserActionType } from './userActionCollection';
import { viewContext } from './viewCollection';
export var RumEventCategory;
(function (RumEventCategory) {
    RumEventCategory["USER_ACTION"] = "user_action";
    RumEventCategory["ERROR"] = "error";
    RumEventCategory["LONG_TASK"] = "long_task";
    RumEventCategory["VIEW"] = "view";
    RumEventCategory["RESOURCE"] = "resource";
})(RumEventCategory || (RumEventCategory = {}));
var SessionType;
(function (SessionType) {
    SessionType["SYNTHETICS"] = "synthetics";
    SessionType["USER"] = "user";
})(SessionType || (SessionType = {}));
export function startRum(applicationId, lifeCycle, configuration, session, internalMonitoring) {
    var globalContext = {};
    internalMonitoring.setExternalContextProvider(function () {
        return deepMerge({
            application_id: applicationId,
            session_id: viewContext.sessionId,
            view: {
                id: viewContext.id,
            },
        }, globalContext);
    });
    var batch = startRumBatch(configuration, session, function () { return ({
        applicationId: applicationId,
        date: new Date().getTime(),
        session: {
            // must be computed on each event because synthetics instrumentation can be done after sdk execution
            // cf https://github.com/puppeteer/puppeteer/issues/3667
            type: getSessionType(),
        },
        sessionId: viewContext.sessionId,
        view: {
            id: viewContext.id,
            referrer: document.referrer,
            url: viewContext.location.href,
        },
    }); }, function () { return globalContext; }, function () { return lifeCycle.notify(LifeCycleEventType.BEFORE_UNLOAD); });
    trackView(lifeCycle, batch.upsertRumEvent);
    trackErrors(lifeCycle, batch.addRumEvent);
    trackRequests(configuration, lifeCycle, session, batch.addRumEvent);
    trackPerformanceTiming(configuration, lifeCycle, batch.addRumEvent);
    trackCustomUserAction(lifeCycle, batch.addRumEvent);
    trackAutoUserAction(lifeCycle, batch.addRumEvent);
    return {
        addRumGlobalContext: monitor(function (key, value) {
            globalContext[key] = value;
        }),
        addUserAction: monitor(function (name, context) {
            lifeCycle.notify(LifeCycleEventType.USER_ACTION_COLLECTED, { context: context, name: name, type: UserActionType.CUSTOM });
        }),
        getInternalContext: monitor(function () {
            return {
                application_id: applicationId,
                session_id: viewContext.sessionId,
                user_action: getUserActionReference(),
                view: {
                    id: viewContext.id,
                },
            };
        }),
        setRumGlobalContext: monitor(function (context) {
            globalContext = context;
        }),
    };
}
function startRumBatch(configuration, session, rumContextProvider, globalContextProvider, beforeUnloadCallback) {
    var batch = new Batch(new HttpRequest(configuration.rumEndpoint, configuration.batchBytesLimit, true), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, function () { return deepMerge(withSnakeCaseKeys(rumContextProvider()), globalContextProvider()); }, beforeUnloadCallback);
    return {
        addRumEvent: function (event, context) {
            if (session.isTracked()) {
                batch.add(__assign(__assign({}, context), withSnakeCaseKeys(event)));
            }
        },
        upsertRumEvent: function (event, key) {
            if (session.isTracked()) {
                batch.upsert(withSnakeCaseKeys(event), key);
            }
        },
    };
}
function trackView(lifeCycle, upsertRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.VIEW_COLLECTED, function (view) {
        upsertRumEvent({
            date: getTimestamp(view.startTime),
            duration: msToNs(view.duration),
            evt: {
                category: RumEventCategory.VIEW,
            },
            rum: {
                documentVersion: view.documentVersion,
            },
            view: {
                loadingTime: view.loadingTime ? msToNs(view.loadingTime) : undefined,
                loadingType: view.loadingType,
                measures: view.measures,
            },
        }, view.id);
    });
}
function trackErrors(lifeCycle, addRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.ERROR_COLLECTED, function (_a) {
        var message = _a.message, startTime = _a.startTime, context = _a.context;
        addRumEvent(__assign({ message: message, date: getTimestamp(startTime), evt: {
                category: RumEventCategory.ERROR,
            }, userAction: getUserActionReference(startTime) }, context));
    });
}
function trackCustomUserAction(lifeCycle, addRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.USER_ACTION_COLLECTED, function (userAction) {
        if (userAction.type === UserActionType.CUSTOM) {
            addRumEvent({
                evt: {
                    category: RumEventCategory.USER_ACTION,
                    name: userAction.name,
                },
                userAction: {
                    type: userAction.type,
                },
            }, userAction.context);
        }
    });
}
function trackAutoUserAction(lifeCycle, addRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.USER_ACTION_COLLECTED, function (userAction) {
        if (userAction.type !== UserActionType.CUSTOM) {
            addRumEvent({
                date: getTimestamp(userAction.startTime),
                duration: msToNs(userAction.duration),
                evt: {
                    category: RumEventCategory.USER_ACTION,
                    name: userAction.name,
                },
                userAction: {
                    id: userAction.id,
                    measures: userAction.measures,
                    type: userAction.type,
                },
            });
        }
    });
}
export function trackRequests(configuration, lifeCycle, session, addRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, function (request) {
        if (!session.isTrackedWithResource()) {
            return;
        }
        if (!isValidResource(request.url, configuration)) {
            return;
        }
        var timing = matchRequestTiming(request);
        var kind = request.type === RequestType.XHR ? ResourceKind.XHR : ResourceKind.FETCH;
        var startTime = timing ? timing.startTime : request.startTime;
        addRumEvent({
            date: getTimestamp(startTime),
            duration: timing ? computePerformanceResourceDuration(timing) : msToNs(request.duration),
            evt: {
                category: RumEventCategory.RESOURCE,
            },
            http: {
                method: request.method,
                performance: timing ? computePerformanceResourceDetails(timing) : undefined,
                statusCode: request.status,
                url: request.url,
            },
            network: {
                bytesWritten: timing ? computeSize(timing) : undefined,
            },
            resource: {
                kind: kind,
            },
            traceId: request.traceId,
            userAction: getUserActionReference(startTime),
        });
        lifeCycle.notify(LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
    });
}
function trackPerformanceTiming(configuration, lifeCycle, addRumEvent) {
    lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        switch (entry.entryType) {
            case 'resource':
                handleResourceEntry(configuration, entry, addRumEvent, lifeCycle);
                break;
            case 'longtask':
                handleLongTaskEntry(entry, addRumEvent);
                break;
            default:
                break;
        }
    });
}
export function handleResourceEntry(configuration, entry, addRumEvent, lifeCycle) {
    if (!isValidResource(entry.name, configuration)) {
        return;
    }
    var resourceKind = computeResourceKind(entry);
    if (includes([ResourceKind.XHR, ResourceKind.FETCH], resourceKind)) {
        return;
    }
    addRumEvent({
        date: getTimestamp(entry.startTime),
        duration: computePerformanceResourceDuration(entry),
        evt: {
            category: RumEventCategory.RESOURCE,
        },
        http: {
            performance: computePerformanceResourceDetails(entry),
            url: entry.name,
        },
        network: {
            bytesWritten: computeSize(entry),
        },
        resource: {
            kind: resourceKind,
        },
        userAction: getUserActionReference(entry.startTime),
    });
    lifeCycle.notify(LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
}
export function handleLongTaskEntry(entry, addRumEvent) {
    addRumEvent({
        date: getTimestamp(entry.startTime),
        duration: msToNs(entry.duration),
        evt: {
            category: RumEventCategory.LONG_TASK,
        },
        userAction: getUserActionReference(entry.startTime),
    });
}
function getSessionType() {
    return window._DATADOG_SYNTHETICS_BROWSER === undefined ? SessionType.USER : SessionType.SYNTHETICS;
}
//# sourceMappingURL=rum.js.map