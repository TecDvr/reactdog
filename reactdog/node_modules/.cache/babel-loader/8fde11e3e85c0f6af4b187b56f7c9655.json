{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { toStackTraceString } from './errorCollection';\nimport { monitor } from './internalMonitoring';\nimport { Observable } from './observable';\nimport { computeStackTrace } from './tracekit';\nimport { normalizeUrl } from './urlPolyfill';\nexport var RequestType;\n\n(function (RequestType) {\n  RequestType[\"FETCH\"] = \"fetch\";\n  RequestType[\"XHR\"] = \"xhr\";\n})(RequestType || (RequestType = {}));\n\nvar nextRequestId = 1;\n\nfunction getNextRequestId() {\n  var result = nextRequestId;\n  nextRequestId += 1;\n  return result;\n}\n\nvar requestObservablesSingleton;\nexport function startRequestCollection() {\n  if (!requestObservablesSingleton) {\n    requestObservablesSingleton = [new Observable(), new Observable()];\n    trackXhr(requestObservablesSingleton);\n    trackFetch(requestObservablesSingleton);\n  }\n\n  return requestObservablesSingleton;\n}\nexport function trackXhr(_a) {\n  var requestStartObservable = _a[0],\n      requestCompleteObservable = _a[1];\n  var originalOpen = XMLHttpRequest.prototype.open;\n  XMLHttpRequest.prototype.open = monitor(function (method, url) {\n    this._datadog_xhr = {\n      method: method,\n      url: url\n    };\n    return originalOpen.apply(this, arguments);\n  });\n  var originalSend = XMLHttpRequest.prototype.send;\n\n  XMLHttpRequest.prototype.send = function (body) {\n    var _this = this;\n\n    var startTime = performance.now();\n    var requestId = getNextRequestId();\n    requestStartObservable.notify({\n      requestId: requestId\n    });\n    var hasBeenReported = false;\n\n    var reportXhr = function () {\n      if (hasBeenReported) {\n        return;\n      }\n\n      hasBeenReported = true;\n      requestCompleteObservable.notify({\n        requestId: requestId,\n        startTime: startTime,\n        duration: performance.now() - startTime,\n        method: _this._datadog_xhr.method,\n        response: _this.response,\n        status: _this.status,\n        traceId: getTraceId(),\n        type: RequestType.XHR,\n        url: normalizeUrl(_this._datadog_xhr.url)\n      });\n    };\n\n    var originalOnreadystatechange = this.onreadystatechange;\n\n    this.onreadystatechange = function () {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        monitor(reportXhr)();\n      }\n\n      if (originalOnreadystatechange) {\n        originalOnreadystatechange.apply(this, arguments);\n      }\n    };\n\n    this.addEventListener('loadend', monitor(reportXhr));\n    return originalSend.apply(this, arguments);\n  };\n}\nexport function trackFetch(_a) {\n  var requestStartObservable = _a[0],\n      requestCompleteObservable = _a[1];\n\n  if (!window.fetch) {\n    return;\n  }\n\n  var originalFetch = window.fetch; // tslint:disable promise-function-async\n\n  window.fetch = monitor(function (input, init) {\n    var _this = this;\n\n    var method = init && init.method || typeof input === 'object' && input.method || 'GET';\n    var startTime = performance.now();\n    var requestId = getNextRequestId();\n    requestStartObservable.notify({\n      requestId: requestId\n    });\n\n    var reportFetch = function (response) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var duration, url, stackTrace, text, e_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              duration = performance.now() - startTime;\n              url = normalizeUrl(typeof input === 'object' && input.url || input);\n              if (!('stack' in response || response instanceof Error)) return [3\n              /*break*/\n              , 1];\n              stackTrace = computeStackTrace(response);\n              requestCompleteObservable.notify({\n                duration: duration,\n                method: method,\n                requestId: requestId,\n                startTime: startTime,\n                url: url,\n                response: toStackTraceString(stackTrace),\n                status: 0,\n                traceId: getTraceId(),\n                type: RequestType.FETCH\n              });\n              return [3\n              /*break*/\n              , 6];\n\n            case 1:\n              if (!('status' in response)) return [3\n              /*break*/\n              , 6];\n              text = void 0;\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2, 4,, 5]);\n\n              return [4\n              /*yield*/\n              , response.clone().text()];\n\n            case 3:\n              text = _a.sent();\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              e_1 = _a.sent();\n              text = \"Unable to retrieve response: \" + e_1;\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              requestCompleteObservable.notify({\n                duration: duration,\n                method: method,\n                requestId: requestId,\n                startTime: startTime,\n                url: url,\n                response: text,\n                responseType: response.type,\n                status: response.status,\n                traceId: getTraceId(),\n                type: RequestType.FETCH\n              });\n              _a.label = 6;\n\n            case 6:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    var responsePromise = originalFetch.call(this, input, init);\n    responsePromise.then(monitor(reportFetch), monitor(reportFetch));\n    return responsePromise;\n  });\n}\nexport function isRejected(request) {\n  return request.status === 0 && request.responseType !== 'opaque';\n}\nexport function isServerError(request) {\n  return request.status >= 500;\n}\n/**\n * Get the current traceId generated from dd-trace-js (if any).\n *\n * Note: in order to work, the browser-sdk should be initialized *before* dd-trace-js because both\n * libraries are wrapping fetch() and XHR.  Wrappers are called in reverse order, and the\n * dd-trace-js wrapper needs to be called first so it can generate the new trace.  The browser-sdk\n * wrapper will then pick up the new trace id via this function.\n */\n\nfunction getTraceId() {\n  // tslint:disable-next-line: no-unsafe-any\n  return 'ddtrace' in window && window.ddtrace.tracer.scope().active() ? // tslint:disable-next-line: no-unsafe-any\n  window.ddtrace.tracer.scope().active().context().toTraceId() : undefined;\n}","map":{"version":3,"sources":["../src/requestCollection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { toStackTraceString } from './errorCollection';\nimport { monitor } from './internalMonitoring';\nimport { Observable } from './observable';\nimport { computeStackTrace } from './tracekit';\nimport { normalizeUrl } from './urlPolyfill';\nexport var RequestType;\n(function (RequestType) {\n    RequestType[\"FETCH\"] = \"fetch\";\n    RequestType[\"XHR\"] = \"xhr\";\n})(RequestType || (RequestType = {}));\nvar nextRequestId = 1;\nfunction getNextRequestId() {\n    var result = nextRequestId;\n    nextRequestId += 1;\n    return result;\n}\nvar requestObservablesSingleton;\nexport function startRequestCollection() {\n    if (!requestObservablesSingleton) {\n        requestObservablesSingleton = [new Observable(), new Observable()];\n        trackXhr(requestObservablesSingleton);\n        trackFetch(requestObservablesSingleton);\n    }\n    return requestObservablesSingleton;\n}\nexport function trackXhr(_a) {\n    var requestStartObservable = _a[0], requestCompleteObservable = _a[1];\n    var originalOpen = XMLHttpRequest.prototype.open;\n    XMLHttpRequest.prototype.open = monitor(function (method, url) {\n        this._datadog_xhr = {\n            method: method,\n            url: url,\n        };\n        return originalOpen.apply(this, arguments);\n    });\n    var originalSend = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function (body) {\n        var _this = this;\n        var startTime = performance.now();\n        var requestId = getNextRequestId();\n        requestStartObservable.notify({\n            requestId: requestId,\n        });\n        var hasBeenReported = false;\n        var reportXhr = function () {\n            if (hasBeenReported) {\n                return;\n            }\n            hasBeenReported = true;\n            requestCompleteObservable.notify({\n                requestId: requestId,\n                startTime: startTime,\n                duration: performance.now() - startTime,\n                method: _this._datadog_xhr.method,\n                response: _this.response,\n                status: _this.status,\n                traceId: getTraceId(),\n                type: RequestType.XHR,\n                url: normalizeUrl(_this._datadog_xhr.url),\n            });\n        };\n        var originalOnreadystatechange = this.onreadystatechange;\n        this.onreadystatechange = function () {\n            if (this.readyState === XMLHttpRequest.DONE) {\n                monitor(reportXhr)();\n            }\n            if (originalOnreadystatechange) {\n                originalOnreadystatechange.apply(this, arguments);\n            }\n        };\n        this.addEventListener('loadend', monitor(reportXhr));\n        return originalSend.apply(this, arguments);\n    };\n}\nexport function trackFetch(_a) {\n    var requestStartObservable = _a[0], requestCompleteObservable = _a[1];\n    if (!window.fetch) {\n        return;\n    }\n    var originalFetch = window.fetch;\n    // tslint:disable promise-function-async\n    window.fetch = monitor(function (input, init) {\n        var _this = this;\n        var method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET';\n        var startTime = performance.now();\n        var requestId = getNextRequestId();\n        requestStartObservable.notify({\n            requestId: requestId,\n        });\n        var reportFetch = function (response) { return __awaiter(_this, void 0, void 0, function () {\n            var duration, url, stackTrace, text, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        duration = performance.now() - startTime;\n                        url = normalizeUrl((typeof input === 'object' && input.url) || input);\n                        if (!('stack' in response || response instanceof Error)) return [3 /*break*/, 1];\n                        stackTrace = computeStackTrace(response);\n                        requestCompleteObservable.notify({\n                            duration: duration,\n                            method: method,\n                            requestId: requestId,\n                            startTime: startTime,\n                            url: url,\n                            response: toStackTraceString(stackTrace),\n                            status: 0,\n                            traceId: getTraceId(),\n                            type: RequestType.FETCH,\n                        });\n                        return [3 /*break*/, 6];\n                    case 1:\n                        if (!('status' in response)) return [3 /*break*/, 6];\n                        text = void 0;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, response.clone().text()];\n                    case 3:\n                        text = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        text = \"Unable to retrieve response: \" + e_1;\n                        return [3 /*break*/, 5];\n                    case 5:\n                        requestCompleteObservable.notify({\n                            duration: duration,\n                            method: method,\n                            requestId: requestId,\n                            startTime: startTime,\n                            url: url,\n                            response: text,\n                            responseType: response.type,\n                            status: response.status,\n                            traceId: getTraceId(),\n                            type: RequestType.FETCH,\n                        });\n                        _a.label = 6;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        }); };\n        var responsePromise = originalFetch.call(this, input, init);\n        responsePromise.then(monitor(reportFetch), monitor(reportFetch));\n        return responsePromise;\n    });\n}\nexport function isRejected(request) {\n    return request.status === 0 && request.responseType !== 'opaque';\n}\nexport function isServerError(request) {\n    return request.status >= 500;\n}\n/**\n * Get the current traceId generated from dd-trace-js (if any).\n *\n * Note: in order to work, the browser-sdk should be initialized *before* dd-trace-js because both\n * libraries are wrapping fetch() and XHR.  Wrappers are called in reverse order, and the\n * dd-trace-js wrapper needs to be called first so it can generate the new trace.  The browser-sdk\n * wrapper will then pick up the new trace id via this function.\n */\nfunction getTraceId() {\n    // tslint:disable-next-line: no-unsafe-any\n    return 'ddtrace' in window && window.ddtrace.tracer.scope().active()\n        ? // tslint:disable-next-line: no-unsafe-any\n            window.ddtrace.tracer\n                .scope()\n                .active()\n                .context()\n                .toTraceId()\n        : undefined;\n}\n//# sourceMappingURL=requestCollection.js.map"]},"metadata":{},"sourceType":"module"}