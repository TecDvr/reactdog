{"ast":null,"code":"/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return;\n  }\n\n  var candidates = performance.getEntriesByName(request.url, 'resource').filter(function (entry) {\n    return isBetween(entry, request.startTime, endTime(request));\n  });\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n    return candidates[1];\n  }\n\n  return;\n}\n\nfunction firstCanBeOptionRequest(correspondingEntries) {\n  return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime;\n}\n\nfunction endTime(timing) {\n  return timing.startTime + timing.duration;\n}\n\nfunction isBetween(timing, start, end) {\n  return timing.startTime >= start && endTime(timing) <= end;\n}","map":{"version":3,"sources":["../src/matchRequestTiming.ts"],"names":[],"mappings":"AAOA;;;;;;;;;;;;AAYA,OAAM,SAAU,kBAAV,CAA6B,OAA7B,EAA0D;AAC9D,MAAI,CAAC,WAAD,IAAgB,EAAE,sBAAsB,WAAxB,CAApB,EAA0D;AACxD;AACD;;AACD,MAAM,UAAU,GAAG,WAAW,CAC3B,gBADgB,CACC,OAAO,CAAC,GADT,EACc,UADd,EAEhB,MAFgB,CAET,UAAC,KAAD,EAAM;AAAK,WAAA,SAAS,CAAC,KAAD,EAAQ,OAAO,CAAC,SAAhB,EAA2B,OAAO,CAA3C,OAA2C,CAAlC,CAAT;AAAqD,GAFvD,CAAnB;;AAIA,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,WAAO,UAAU,CAAC,CAAD,CAAjB;AACD;;AAED,MAAI,UAAU,CAAC,MAAX,KAAsB,CAAtB,IAA2B,uBAAuB,CAAC,UAAD,CAAtD,EAAoE;AAClE,WAAO,UAAU,CAAC,CAAD,CAAjB;AACD;;AAED;AACD;;AAED,SAAS,uBAAT,CAAiC,oBAAjC,EAAkF;AAChF,SAAO,OAAO,CAAC,oBAAoB,CAAC,CAAD,CAArB,CAAP,IAAoC,oBAAoB,CAAC,CAAD,CAApB,CAAwB,SAAnE;AACD;;AAED,SAAS,OAAT,CAAiB,MAAjB,EAA+B;AAC7B,SAAO,MAAM,CAAC,SAAP,GAAmB,MAAM,CAAC,QAAjC;AACD;;AAED,SAAS,SAAT,CAAmB,MAAnB,EAAmC,KAAnC,EAAkD,GAAlD,EAA6D;AAC3D,SAAO,MAAM,CAAC,SAAP,IAAoB,KAApB,IAA6B,OAAO,CAAC,MAAD,CAAP,IAAmB,GAAvD;AACD","sourceRoot":"","sourcesContent":["/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request) {\n    if (!performance || !('getEntriesByName' in performance)) {\n        return;\n    }\n    var candidates = performance\n        .getEntriesByName(request.url, 'resource')\n        .filter(function (entry) { return isBetween(entry, request.startTime, endTime(request)); });\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n        return candidates[1];\n    }\n    return;\n}\nfunction firstCanBeOptionRequest(correspondingEntries) {\n    return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime;\n}\nfunction endTime(timing) {\n    return timing.startTime + timing.duration;\n}\nfunction isBetween(timing, start, end) {\n    return timing.startTime >= start && endTime(timing) <= end;\n}\n//# sourceMappingURL=matchRequestTiming.js.map"]},"metadata":{},"sourceType":"module"}