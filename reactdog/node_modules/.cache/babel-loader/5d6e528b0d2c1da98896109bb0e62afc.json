{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { monitor } from './internalMonitoring';\nimport { Observable } from './observable';\nimport { isRejected, isServerError, RequestType, startRequestCollection } from './requestCollection';\nimport { computeStackTrace, report } from './tracekit';\nimport { jsonStringify, ONE_MINUTE } from './utils';\nexport var ErrorOrigin;\n\n(function (ErrorOrigin) {\n  ErrorOrigin[\"AGENT\"] = \"agent\";\n  ErrorOrigin[\"CONSOLE\"] = \"console\";\n  ErrorOrigin[\"NETWORK\"] = \"network\";\n  ErrorOrigin[\"SOURCE\"] = \"source\";\n  ErrorOrigin[\"LOGGER\"] = \"logger\";\n})(ErrorOrigin || (ErrorOrigin = {}));\n\nvar filteredErrorsObservable;\nexport function startErrorCollection(configuration) {\n  if (!filteredErrorsObservable) {\n    var errorObservable = new Observable();\n\n    if (configuration.isCollectingError) {\n      var _a = startRequestCollection(),\n          requestCompleteObservable = _a[1];\n\n      trackNetworkError(configuration, errorObservable, requestCompleteObservable);\n      startConsoleTracking(errorObservable);\n      startRuntimeErrorTracking(errorObservable);\n    }\n\n    filteredErrorsObservable = filterErrors(configuration, errorObservable);\n  }\n\n  return filteredErrorsObservable;\n}\nexport function filterErrors(configuration, errorObservable) {\n  var errorCount = 0;\n  var filteredErrorObservable = new Observable();\n  errorObservable.subscribe(function (error) {\n    if (errorCount < configuration.maxErrorsByMinute) {\n      errorCount += 1;\n      filteredErrorObservable.notify(error);\n    } else if (errorCount === configuration.maxErrorsByMinute) {\n      errorCount += 1;\n      filteredErrorObservable.notify({\n        context: {\n          error: {\n            origin: ErrorOrigin.AGENT\n          }\n        },\n        message: \"Reached max number of errors by minute: \" + configuration.maxErrorsByMinute,\n        startTime: performance.now()\n      });\n    }\n  });\n  setInterval(function () {\n    return errorCount = 0;\n  }, ONE_MINUTE);\n  return filteredErrorObservable;\n}\nvar originalConsoleError;\nexport function startConsoleTracking(errorObservable) {\n  originalConsoleError = console.error;\n  console.error = monitor(function (message) {\n    var optionalParams = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      optionalParams[_i - 1] = arguments[_i];\n    }\n\n    originalConsoleError.apply(console, __spreadArrays([message], optionalParams));\n    errorObservable.notify({\n      context: {\n        error: {\n          origin: ErrorOrigin.CONSOLE\n        }\n      },\n      message: __spreadArrays(['console error:', message], optionalParams).map(formatConsoleParameters).join(' '),\n      startTime: performance.now()\n    });\n  });\n}\nexport function stopConsoleTracking() {\n  console.error = originalConsoleError;\n}\n\nfunction formatConsoleParameters(param) {\n  if (typeof param === 'string') {\n    return param;\n  }\n\n  if (param instanceof Error) {\n    return toStackTraceString(computeStackTrace(param));\n  }\n\n  return jsonStringify(param, undefined, 2);\n}\n\nvar traceKitReportHandler;\nexport function startRuntimeErrorTracking(errorObservable) {\n  traceKitReportHandler = function (stack, _, errorObject) {\n    errorObservable.notify(formatRuntimeError(stack, errorObject));\n  };\n\n  report.subscribe(traceKitReportHandler);\n}\nexport function stopRuntimeErrorTracking() {\n  ;\n  report.unsubscribe(traceKitReportHandler);\n}\nexport function formatRuntimeError(stackTrace, errorObject) {\n  var message;\n  var stack;\n\n  if (stackTrace.message === undefined && !(errorObject instanceof Error)) {\n    message = \"Uncaught \" + jsonStringify(errorObject);\n    stack = 'No stack, consider using an instance of Error';\n  } else {\n    message = stackTrace.message || 'Empty message';\n    stack = toStackTraceString(stackTrace);\n  }\n\n  return {\n    message: message,\n    context: {\n      error: {\n        stack: stack,\n        kind: stackTrace.name,\n        origin: ErrorOrigin.SOURCE\n      }\n    },\n    startTime: performance.now()\n  };\n}\nexport function toStackTraceString(stack) {\n  var result = (stack.name || 'Error') + \": \" + stack.message;\n  stack.stack.forEach(function (frame) {\n    var func = frame.func === '?' ? '<anonymous>' : frame.func;\n    var args = frame.args && frame.args.length > 0 ? \"(\" + frame.args.join(', ') + \")\" : '';\n    var line = frame.line ? \":\" + frame.line : '';\n    var column = frame.line && frame.column ? \":\" + frame.column : '';\n    result += \"\\n  at \" + func + args + \" @ \" + frame.url + line + column;\n  });\n  return result;\n}\nexport function trackNetworkError(configuration, errorObservable, requestObservable) {\n  requestObservable.subscribe(function (request) {\n    if (isRejected(request) || isServerError(request)) {\n      errorObservable.notify({\n        context: {\n          error: {\n            origin: ErrorOrigin.NETWORK,\n            stack: truncateResponse(request.response, configuration) || 'Failed to load'\n          },\n          http: {\n            method: request.method,\n            status_code: request.status,\n            url: request.url\n          }\n        },\n        message: format(request.type) + \" error \" + request.method + \" \" + request.url,\n        startTime: request.startTime\n      });\n    }\n  });\n}\n\nfunction truncateResponse(response, configuration) {\n  if (response && response.length > configuration.requestErrorResponseLengthLimit) {\n    return response.substring(0, configuration.requestErrorResponseLengthLimit) + \"...\";\n  }\n\n  return response;\n}\n\nfunction format(type) {\n  if (RequestType.XHR === type) {\n    return 'XHR';\n  }\n\n  return 'Fetch';\n}","map":{"version":3,"sources":["../src/errorCollection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport { monitor } from './internalMonitoring';\nimport { Observable } from './observable';\nimport { isRejected, isServerError, RequestType, startRequestCollection, } from './requestCollection';\nimport { computeStackTrace, report } from './tracekit';\nimport { jsonStringify, ONE_MINUTE } from './utils';\nexport var ErrorOrigin;\n(function (ErrorOrigin) {\n    ErrorOrigin[\"AGENT\"] = \"agent\";\n    ErrorOrigin[\"CONSOLE\"] = \"console\";\n    ErrorOrigin[\"NETWORK\"] = \"network\";\n    ErrorOrigin[\"SOURCE\"] = \"source\";\n    ErrorOrigin[\"LOGGER\"] = \"logger\";\n})(ErrorOrigin || (ErrorOrigin = {}));\nvar filteredErrorsObservable;\nexport function startErrorCollection(configuration) {\n    if (!filteredErrorsObservable) {\n        var errorObservable = new Observable();\n        if (configuration.isCollectingError) {\n            var _a = startRequestCollection(), requestCompleteObservable = _a[1];\n            trackNetworkError(configuration, errorObservable, requestCompleteObservable);\n            startConsoleTracking(errorObservable);\n            startRuntimeErrorTracking(errorObservable);\n        }\n        filteredErrorsObservable = filterErrors(configuration, errorObservable);\n    }\n    return filteredErrorsObservable;\n}\nexport function filterErrors(configuration, errorObservable) {\n    var errorCount = 0;\n    var filteredErrorObservable = new Observable();\n    errorObservable.subscribe(function (error) {\n        if (errorCount < configuration.maxErrorsByMinute) {\n            errorCount += 1;\n            filteredErrorObservable.notify(error);\n        }\n        else if (errorCount === configuration.maxErrorsByMinute) {\n            errorCount += 1;\n            filteredErrorObservable.notify({\n                context: {\n                    error: {\n                        origin: ErrorOrigin.AGENT,\n                    },\n                },\n                message: \"Reached max number of errors by minute: \" + configuration.maxErrorsByMinute,\n                startTime: performance.now(),\n            });\n        }\n    });\n    setInterval(function () { return (errorCount = 0); }, ONE_MINUTE);\n    return filteredErrorObservable;\n}\nvar originalConsoleError;\nexport function startConsoleTracking(errorObservable) {\n    originalConsoleError = console.error;\n    console.error = monitor(function (message) {\n        var optionalParams = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            optionalParams[_i - 1] = arguments[_i];\n        }\n        originalConsoleError.apply(console, __spreadArrays([message], optionalParams));\n        errorObservable.notify({\n            context: {\n                error: {\n                    origin: ErrorOrigin.CONSOLE,\n                },\n            },\n            message: __spreadArrays(['console error:', message], optionalParams).map(formatConsoleParameters).join(' '),\n            startTime: performance.now(),\n        });\n    });\n}\nexport function stopConsoleTracking() {\n    console.error = originalConsoleError;\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (param instanceof Error) {\n        return toStackTraceString(computeStackTrace(param));\n    }\n    return jsonStringify(param, undefined, 2);\n}\nvar traceKitReportHandler;\nexport function startRuntimeErrorTracking(errorObservable) {\n    traceKitReportHandler = function (stack, _, errorObject) {\n        errorObservable.notify(formatRuntimeError(stack, errorObject));\n    };\n    report.subscribe(traceKitReportHandler);\n}\nexport function stopRuntimeErrorTracking() {\n    ;\n    report.unsubscribe(traceKitReportHandler);\n}\nexport function formatRuntimeError(stackTrace, errorObject) {\n    var message;\n    var stack;\n    if (stackTrace.message === undefined && !(errorObject instanceof Error)) {\n        message = \"Uncaught \" + jsonStringify(errorObject);\n        stack = 'No stack, consider using an instance of Error';\n    }\n    else {\n        message = stackTrace.message || 'Empty message';\n        stack = toStackTraceString(stackTrace);\n    }\n    return {\n        message: message,\n        context: {\n            error: {\n                stack: stack,\n                kind: stackTrace.name,\n                origin: ErrorOrigin.SOURCE,\n            },\n        },\n        startTime: performance.now(),\n    };\n}\nexport function toStackTraceString(stack) {\n    var result = (stack.name || 'Error') + \": \" + stack.message;\n    stack.stack.forEach(function (frame) {\n        var func = frame.func === '?' ? '<anonymous>' : frame.func;\n        var args = frame.args && frame.args.length > 0 ? \"(\" + frame.args.join(', ') + \")\" : '';\n        var line = frame.line ? \":\" + frame.line : '';\n        var column = frame.line && frame.column ? \":\" + frame.column : '';\n        result += \"\\n  at \" + func + args + \" @ \" + frame.url + line + column;\n    });\n    return result;\n}\nexport function trackNetworkError(configuration, errorObservable, requestObservable) {\n    requestObservable.subscribe(function (request) {\n        if (isRejected(request) || isServerError(request)) {\n            errorObservable.notify({\n                context: {\n                    error: {\n                        origin: ErrorOrigin.NETWORK,\n                        stack: truncateResponse(request.response, configuration) || 'Failed to load',\n                    },\n                    http: {\n                        method: request.method,\n                        status_code: request.status,\n                        url: request.url,\n                    },\n                },\n                message: format(request.type) + \" error \" + request.method + \" \" + request.url,\n                startTime: request.startTime,\n            });\n        }\n    });\n}\nfunction truncateResponse(response, configuration) {\n    if (response && response.length > configuration.requestErrorResponseLengthLimit) {\n        return response.substring(0, configuration.requestErrorResponseLengthLimit) + \"...\";\n    }\n    return response;\n}\nfunction format(type) {\n    if (RequestType.XHR === type) {\n        return 'XHR';\n    }\n    return 'Fetch';\n}\n//# sourceMappingURL=errorCollection.js.map"]},"metadata":{},"sourceType":"module"}