{"ast":null,"code":"import { addMonitoringMessage, getPathName, haveSameOrigin, includes, isValidUrl, msToNs, ResourceKind } from '@datadog/browser-core';\nexport var FAKE_INITIAL_DOCUMENT = 'initial_document';\nvar RESOURCE_TYPES = [[ResourceKind.DOCUMENT, function (initiatorType) {\n  return FAKE_INITIAL_DOCUMENT === initiatorType;\n}], [ResourceKind.XHR, function (initiatorType) {\n  return 'xmlhttprequest' === initiatorType;\n}], [ResourceKind.FETCH, function (initiatorType) {\n  return 'fetch' === initiatorType;\n}], [ResourceKind.BEACON, function (initiatorType) {\n  return 'beacon' === initiatorType;\n}], [ResourceKind.CSS, function (_, path) {\n  return path.match(/\\.css$/i) !== null;\n}], [ResourceKind.JS, function (_, path) {\n  return path.match(/\\.js$/i) !== null;\n}], [ResourceKind.IMAGE, function (initiatorType, path) {\n  return includes(['image', 'img', 'icon'], initiatorType) || path.match(/\\.(gif|jpg|jpeg|tiff|png|svg)$/i) !== null;\n}], [ResourceKind.FONT, function (_, path) {\n  return path.match(/\\.(woff|eot|woff2|ttf)$/i) !== null;\n}], [ResourceKind.MEDIA, function (initiatorType, path) {\n  return includes(['audio', 'video'], initiatorType) || path.match(/\\.(mp3|mp4)$/i) !== null;\n}]];\nexport function computeResourceKind(timing) {\n  var url = timing.name;\n\n  if (!isValidUrl(url)) {\n    addMonitoringMessage(\"Failed to construct URL for \\\"\" + timing.name + \"\\\"\");\n    return ResourceKind.OTHER;\n  }\n\n  var path = getPathName(url);\n\n  for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {\n    var _a = RESOURCE_TYPES_1[_i],\n        type = _a[0],\n        isType = _a[1];\n\n    if (isType(timing.initiatorType, path)) {\n      return type;\n    }\n  }\n\n  return ResourceKind.OTHER;\n}\n\nfunction areInOrder() {\n  var numbers = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    numbers[_i] = arguments[_i];\n  }\n\n  for (var i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function computePerformanceResourceDuration(entry) {\n  var duration = entry.duration,\n      startTime = entry.startTime,\n      responseEnd = entry.responseEnd; // Safari duration is always 0 on timings blocked by cross origin policies.\n\n  if (duration === 0 && startTime < responseEnd) {\n    return msToNs(responseEnd - startTime);\n  }\n\n  return msToNs(duration);\n}\nexport function computePerformanceResourceDetails(entry) {\n  var startTime = entry.startTime,\n      fetchStart = entry.fetchStart,\n      domainLookupStart = entry.domainLookupStart,\n      domainLookupEnd = entry.domainLookupEnd,\n      connectStart = entry.connectStart,\n      secureConnectionStart = entry.secureConnectionStart,\n      connectEnd = entry.connectEnd,\n      requestStart = entry.requestStart,\n      responseStart = entry.responseStart,\n      responseEnd = entry.responseEnd;\n  var redirectStart = entry.redirectStart,\n      redirectEnd = entry.redirectEnd; // Ensure timings are in the right order.  On top of filtering out potential invalid\n  // PerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n\n  if (!areInOrder(startTime, fetchStart, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, responseEnd)) {\n    return undefined;\n  } // The only time fetchStart is different than startTime is if a redirection occured.\n\n\n  var hasRedirectionOccured = fetchStart !== startTime;\n\n  if (hasRedirectionOccured) {\n    // Firefox doesn't provide redirect timings on cross origin requests.  Provide a default for\n    // those.\n    if (redirectStart < startTime) {\n      redirectStart = startTime;\n    }\n\n    if (redirectEnd < startTime) {\n      redirectEnd = fetchStart;\n    } // Make sure redirect timings are in order\n\n\n    if (!areInOrder(startTime, redirectStart, redirectEnd, fetchStart)) {\n      return undefined;\n    }\n  }\n\n  var details = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    firstByte: formatTiming(startTime, requestStart, responseStart)\n  }; // Make sure a connection occured\n\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd); // Make sure a secure connection occured\n\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n    }\n  } // Make sure a domain lookup occured\n\n\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n  }\n\n  if (hasRedirectionOccured) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n  }\n\n  return details;\n}\n\nfunction formatTiming(origin, start, end) {\n  return {\n    duration: msToNs(end - start),\n    start: msToNs(start - origin)\n  };\n}\n\nexport function computeSize(entry) {\n  // Make sure a request actually occured\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize;\n  }\n\n  return undefined;\n}\nexport function isValidResource(url, configuration) {\n  return url && !isBrowserAgentRequest(url, configuration);\n}\n\nfunction isBrowserAgentRequest(url, configuration) {\n  return haveSameOrigin(url, configuration.logsEndpoint) || haveSameOrigin(url, configuration.rumEndpoint) || haveSameOrigin(url, configuration.traceEndpoint) || configuration.internalMonitoringEndpoint && haveSameOrigin(url, configuration.internalMonitoringEndpoint);\n}","map":{"version":3,"sources":["../src/resourceUtils.ts"],"names":[],"mappings":"AAAA,SACE,oBADF,EAGE,WAHF,EAIE,cAJF,EAKE,QALF,EAME,UANF,EAOE,MAPF,EAQE,YARF,QASO,uBATP;AAaA,OAAO,IAAM,qBAAqB,GAAG,kBAA9B;AAEP,IAAM,cAAc,GAA4E,CAC9F,CAAC,YAAY,CAAC,QAAd,EAAwB,UAAC,aAAD,EAAsB;AAAK,SAAA,qBAAqB,KAArB,aAAA;AAAuC,CAA1F,CAD8F,EAE9F,CAAC,YAAY,CAAC,GAAd,EAAmB,UAAC,aAAD,EAAsB;AAAK,SAAA,qBAAA,aAAA;AAAkC,CAAhF,CAF8F,EAG9F,CAAC,YAAY,CAAC,KAAd,EAAqB,UAAC,aAAD,EAAsB;AAAK,SAAA,YAAA,aAAA;AAAyB,CAAzE,CAH8F,EAI9F,CAAC,YAAY,CAAC,MAAd,EAAsB,UAAC,aAAD,EAAsB;AAAK,SAAA,aAAA,aAAA;AAA0B,CAA3E,CAJ8F,EAK9F,CAAC,YAAY,CAAC,GAAd,EAAmB,UAAC,CAAD,EAAY,IAAZ,EAAwB;AAAK,SAAA,IAAI,CAAC,KAAL,CAAW,SAAX,MAAA,IAAA;AAA8B,CAA9E,CAL8F,EAM9F,CAAC,YAAY,CAAC,EAAd,EAAkB,UAAC,CAAD,EAAY,IAAZ,EAAwB;AAAK,SAAA,IAAI,CAAC,KAAL,CAAW,QAAX,MAAA,IAAA;AAA6B,CAA5E,CAN8F,EAO9F,CACE,YAAY,CAAC,KADf,EAEE,UAAC,aAAD,EAAwB,IAAxB,EAAoC;AAClC,SAAA,QAAQ,CAAC,CAAC,OAAD,EAAU,KAAV,EAAiB,MAAjB,CAAD,EAA2B,aAA3B,CAAR,IAAqD,IAAI,CAAC,KAAL,CAAW,iCAAX,MAAkD,IAAvG;AAA2G,CAH/G,CAP8F,EAY9F,CAAC,YAAY,CAAC,IAAd,EAAoB,UAAC,CAAD,EAAY,IAAZ,EAAwB;AAAK,SAAA,IAAI,CAAC,KAAL,CAAW,0BAAX,MAAA,IAAA;AAA+C,CAAhG,CAZ8F,EAa9F,CACE,YAAY,CAAC,KADf,EAEE,UAAC,aAAD,EAAwB,IAAxB,EAAoC;AAClC,SAAA,QAAQ,CAAC,CAAC,OAAD,EAAU,OAAV,CAAD,EAAqB,aAArB,CAAR,IAA+C,IAAI,CAAC,KAAL,CAAW,eAAX,MAAgC,IAA/E;AAAmF,CAHvF,CAb8F,CAAhG;AAoBA,OAAM,SAAU,mBAAV,CAA8B,MAA9B,EAA+D;AACnE,MAAM,GAAG,GAAG,MAAM,CAAC,IAAnB;;AACA,MAAI,CAAC,UAAU,CAAC,GAAD,CAAf,EAAsB;AACpB,IAAA,oBAAoB,CAAC,mCAAgC,MAAM,CAAC,IAAvC,GAA2C,IAA5C,CAApB;AACA,WAAO,YAAY,CAAC,KAApB;AACD;;AACD,MAAM,IAAI,GAAG,WAAW,CAAC,GAAD,CAAxB;;AACA,OAA6B,IAAA,EAAA,GAAA,CAAA,EAAA,gBAAA,GAAA,cAA7B,EAA6B,EAAA,GAAA,gBAAA,CAAA,MAA7B,EAA6B,EAAA,EAA7B,EAA6C;AAAlC,QAAA,EAAA,GAAA,gBAAA,CAAA,EAAA,CAAA;AAAA,QAAC,IAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,QAAO,MAAA,GAAA,EAAA,CAAA,CAAA,CAAP;;AACT,QAAI,MAAM,CAAC,MAAM,CAAC,aAAR,EAAuB,IAAvB,CAAV,EAAwC;AACtC,aAAO,IAAP;AACD;AACF;;AACD,SAAO,YAAY,CAAC,KAApB;AACD;;AAED,SAAS,UAAT,GAAmB;AAAC,MAAA,OAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAoB;AAApB,IAAA,OAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAClB,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,IAAI,CAAzC,EAA4C;AAC1C,QAAI,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,OAAO,CAAC,CAAD,CAA5B,EAAiC;AAC/B,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,OAAM,SAAU,kCAAV,CAA6C,KAA7C,EAA6E;AACzE,MAAA,QAAA,GAAA,KAAA,CAAA,QAAA;AAAA,MAAU,SAAA,GAAA,KAAA,CAAA,SAAV;AAAA,MAAqB,WAAA,GAAA,KAAA,CAAA,WAArB,CADyE,CAGjF;;AACA,MAAI,QAAQ,KAAK,CAAb,IAAkB,SAAS,GAAG,WAAlC,EAA+C;AAC7C,WAAO,MAAM,CAAC,WAAW,GAAG,SAAf,CAAb;AACD;;AAED,SAAO,MAAM,CAAC,QAAD,CAAb;AACD;AAED,OAAM,SAAU,iCAAV,CACJ,KADI,EAC4B;AAG9B,MAAA,SAAA,GAAA,KAAA,CAAA,SAAA;AAAA,MACA,UAAA,GAAA,KAAA,CAAA,UADA;AAAA,MAEA,iBAAA,GAAA,KAAA,CAAA,iBAFA;AAAA,MAGA,eAAA,GAAA,KAAA,CAAA,eAHA;AAAA,MAIA,YAAA,GAAA,KAAA,CAAA,YAJA;AAAA,MAKA,qBAAA,GAAA,KAAA,CAAA,qBALA;AAAA,MAMA,UAAA,GAAA,KAAA,CAAA,UANA;AAAA,MAOA,YAAA,GAAA,KAAA,CAAA,YAPA;AAAA,MAQA,aAAA,GAAA,KAAA,CAAA,aARA;AAAA,MASA,WAAA,GAAA,KAAA,CAAA,WATA;AAWI,MAAA,aAAA,GAAA,KAAA,CAAA,aAAA;AAAA,MAAe,WAAA,GAAA,KAAA,CAAA,WAAf,CAd0B,CAgBhC;AACA;AACA;AACA;;AACA,MACE,CAAC,UAAU,CACT,SADS,EAET,UAFS,EAGT,iBAHS,EAIT,eAJS,EAKT,YALS,EAMT,UANS,EAOT,YAPS,EAQT,aARS,EAST,WATS,CADb,EAYE;AACA,WAAO,SAAP;AACD,GAlC+B,CAoChC;;;AACA,MAAM,qBAAqB,GAAG,UAAU,KAAK,SAA7C;;AAEA,MAAI,qBAAJ,EAA2B;AACzB;AACA;AACA,QAAI,aAAa,GAAG,SAApB,EAA+B;AAC7B,MAAA,aAAa,GAAG,SAAhB;AACD;;AACD,QAAI,WAAW,GAAG,SAAlB,EAA6B;AAC3B,MAAA,WAAW,GAAG,UAAd;AACD,KARwB,CAUzB;;;AACA,QAAI,CAAC,UAAU,CAAC,SAAD,EAAY,aAAZ,EAA2B,WAA3B,EAAwC,UAAxC,CAAf,EAAoE;AAClE,aAAO,SAAP;AACD;AACF;;AAED,MAAM,OAAO,GAA+B;AAC1C,IAAA,QAAQ,EAAE,YAAY,CAAC,SAAD,EAAY,aAAZ,EAA2B,WAA3B,CADoB;AAE1C,IAAA,SAAS,EAAE,YAAY,CAAC,SAAD,EAAY,YAAZ,EAA0B,aAA1B;AAFmB,GAA5C,CAvDgC,CA4DhC;;AACA,MAAI,UAAU,KAAK,UAAnB,EAA+B;AAC7B,IAAA,OAAO,CAAC,OAAR,GAAkB,YAAY,CAAC,SAAD,EAAY,YAAZ,EAA0B,UAA1B,CAA9B,CAD6B,CAG7B;;AACA,QAAI,UAAU,CAAC,YAAD,EAAe,qBAAf,EAAsC,UAAtC,CAAd,EAAiE;AAC/D,MAAA,OAAO,CAAC,GAAR,GAAc,YAAY,CAAC,SAAD,EAAY,qBAAZ,EAAmC,UAAnC,CAA1B;AACD;AACF,GApE+B,CAsEhC;;;AACA,MAAI,eAAe,KAAK,UAAxB,EAAoC;AAClC,IAAA,OAAO,CAAC,GAAR,GAAc,YAAY,CAAC,SAAD,EAAY,iBAAZ,EAA+B,eAA/B,CAA1B;AACD;;AAED,MAAI,qBAAJ,EAA2B;AACzB,IAAA,OAAO,CAAC,QAAR,GAAmB,YAAY,CAAC,SAAD,EAAY,aAAZ,EAA2B,WAA3B,CAA/B;AACD;;AAED,SAAO,OAAP;AACD;;AAED,SAAS,YAAT,CAAsB,MAAtB,EAAsC,KAAtC,EAAqD,GAArD,EAAgE;AAC9D,SAAO;AACL,IAAA,QAAQ,EAAE,MAAM,CAAC,GAAG,GAAG,KAAP,CADX;AAEL,IAAA,KAAK,EAAE,MAAM,CAAC,KAAK,GAAG,MAAT;AAFR,GAAP;AAID;;AAED,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAsD;AAC1D;AACA,MAAI,KAAK,CAAC,SAAN,GAAkB,KAAK,CAAC,aAA5B,EAA2C;AACzC,WAAO,KAAK,CAAC,eAAb;AACD;;AACD,SAAO,SAAP;AACD;AAED,OAAM,SAAU,eAAV,CAA0B,GAA1B,EAAuC,aAAvC,EAAmE;AACvE,SAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,GAAD,EAAM,aAAN,CAApC;AACD;;AAED,SAAS,qBAAT,CAA+B,GAA/B,EAA4C,aAA5C,EAAwE;AACtE,SACE,cAAc,CAAC,GAAD,EAAM,aAAa,CAAC,YAApB,CAAd,IACA,cAAc,CAAC,GAAD,EAAM,aAAa,CAAC,WAApB,CADd,IAEA,cAAc,CAAC,GAAD,EAAM,aAAa,CAAC,aAApB,CAFd,IAGC,aAAa,CAAC,0BAAd,IAA4C,cAAc,CAAC,GAAD,EAAM,aAAa,CAAC,0BAApB,CAJ7D;AAMD","sourceRoot":"","sourcesContent":["import { addMonitoringMessage, getPathName, haveSameOrigin, includes, isValidUrl, msToNs, ResourceKind, } from '@datadog/browser-core';\nexport var FAKE_INITIAL_DOCUMENT = 'initial_document';\nvar RESOURCE_TYPES = [\n    [ResourceKind.DOCUMENT, function (initiatorType) { return FAKE_INITIAL_DOCUMENT === initiatorType; }],\n    [ResourceKind.XHR, function (initiatorType) { return 'xmlhttprequest' === initiatorType; }],\n    [ResourceKind.FETCH, function (initiatorType) { return 'fetch' === initiatorType; }],\n    [ResourceKind.BEACON, function (initiatorType) { return 'beacon' === initiatorType; }],\n    [ResourceKind.CSS, function (_, path) { return path.match(/\\.css$/i) !== null; }],\n    [ResourceKind.JS, function (_, path) { return path.match(/\\.js$/i) !== null; }],\n    [\n        ResourceKind.IMAGE,\n        function (initiatorType, path) {\n            return includes(['image', 'img', 'icon'], initiatorType) || path.match(/\\.(gif|jpg|jpeg|tiff|png|svg)$/i) !== null;\n        },\n    ],\n    [ResourceKind.FONT, function (_, path) { return path.match(/\\.(woff|eot|woff2|ttf)$/i) !== null; }],\n    [\n        ResourceKind.MEDIA,\n        function (initiatorType, path) {\n            return includes(['audio', 'video'], initiatorType) || path.match(/\\.(mp3|mp4)$/i) !== null;\n        },\n    ],\n];\nexport function computeResourceKind(timing) {\n    var url = timing.name;\n    if (!isValidUrl(url)) {\n        addMonitoringMessage(\"Failed to construct URL for \\\"\" + timing.name + \"\\\"\");\n        return ResourceKind.OTHER;\n    }\n    var path = getPathName(url);\n    for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {\n        var _a = RESOURCE_TYPES_1[_i], type = _a[0], isType = _a[1];\n        if (isType(timing.initiatorType, path)) {\n            return type;\n        }\n    }\n    return ResourceKind.OTHER;\n}\nfunction areInOrder() {\n    var numbers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        numbers[_i] = arguments[_i];\n    }\n    for (var i = 1; i < numbers.length; i += 1) {\n        if (numbers[i - 1] > numbers[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computePerformanceResourceDuration(entry) {\n    var duration = entry.duration, startTime = entry.startTime, responseEnd = entry.responseEnd;\n    // Safari duration is always 0 on timings blocked by cross origin policies.\n    if (duration === 0 && startTime < responseEnd) {\n        return msToNs(responseEnd - startTime);\n    }\n    return msToNs(duration);\n}\nexport function computePerformanceResourceDetails(entry) {\n    var startTime = entry.startTime, fetchStart = entry.fetchStart, domainLookupStart = entry.domainLookupStart, domainLookupEnd = entry.domainLookupEnd, connectStart = entry.connectStart, secureConnectionStart = entry.secureConnectionStart, connectEnd = entry.connectEnd, requestStart = entry.requestStart, responseStart = entry.responseStart, responseEnd = entry.responseEnd;\n    var redirectStart = entry.redirectStart, redirectEnd = entry.redirectEnd;\n    // Ensure timings are in the right order.  On top of filtering out potential invalid\n    // PerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n    // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n    // it.\n    if (!areInOrder(startTime, fetchStart, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, responseEnd)) {\n        return undefined;\n    }\n    // The only time fetchStart is different than startTime is if a redirection occured.\n    var hasRedirectionOccured = fetchStart !== startTime;\n    if (hasRedirectionOccured) {\n        // Firefox doesn't provide redirect timings on cross origin requests.  Provide a default for\n        // those.\n        if (redirectStart < startTime) {\n            redirectStart = startTime;\n        }\n        if (redirectEnd < startTime) {\n            redirectEnd = fetchStart;\n        }\n        // Make sure redirect timings are in order\n        if (!areInOrder(startTime, redirectStart, redirectEnd, fetchStart)) {\n            return undefined;\n        }\n    }\n    var details = {\n        download: formatTiming(startTime, responseStart, responseEnd),\n        firstByte: formatTiming(startTime, requestStart, responseStart),\n    };\n    // Make sure a connection occured\n    if (connectEnd !== fetchStart) {\n        details.connect = formatTiming(startTime, connectStart, connectEnd);\n        // Make sure a secure connection occured\n        if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n        }\n    }\n    // Make sure a domain lookup occured\n    if (domainLookupEnd !== fetchStart) {\n        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n    }\n    if (hasRedirectionOccured) {\n        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n    }\n    return details;\n}\nfunction formatTiming(origin, start, end) {\n    return {\n        duration: msToNs(end - start),\n        start: msToNs(start - origin),\n    };\n}\nexport function computeSize(entry) {\n    // Make sure a request actually occured\n    if (entry.startTime < entry.responseStart) {\n        return entry.decodedBodySize;\n    }\n    return undefined;\n}\nexport function isValidResource(url, configuration) {\n    return url && !isBrowserAgentRequest(url, configuration);\n}\nfunction isBrowserAgentRequest(url, configuration) {\n    return (haveSameOrigin(url, configuration.logsEndpoint) ||\n        haveSameOrigin(url, configuration.rumEndpoint) ||\n        haveSameOrigin(url, configuration.traceEndpoint) ||\n        (configuration.internalMonitoringEndpoint && haveSameOrigin(url, configuration.internalMonitoringEndpoint)));\n}\n//# sourceMappingURL=resourceUtils.js.map"]},"metadata":{},"sourceType":"module"}