{"ast":null,"code":"// tslint:disable no-unsafe-any\nimport { monitor } from './internalMonitoring';\nvar UNKNOWN_FUNCTION = '?'; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\n// tslint:disable-next-line max-line-length\n\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\n\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\n\n\nfunction isUndefined(what) {\n  return typeof what === 'undefined';\n}\n/**\n * Wrap any function in a TraceKit reporter<br/>\n * Example: `func = wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof TraceKit\n */\n// tslint:disable-next-line ban-types\n\n\nexport function wrap(func) {\n  function wrapped() {\n    try {\n      return func.apply(this, arguments);\n    } catch (e) {\n      report(e);\n      throw e;\n    }\n  }\n\n  return wrapped;\n}\n/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   report.subscribe(function(stackInfo) { ... })\n *   report.unsubscribe(function(stackInfo) { ... })\n *   report(exception)\n *   try { ...code... } catch(ex) { report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where report was called.\n *\n * Handlers receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport var report = function reportModuleWrapper() {\n  var handlers = [];\n  var lastException;\n  var lastExceptionStack;\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   * @memberof report\n   */\n\n  function subscribe(handler) {\n    installGlobalHandler();\n    installGlobalUnhandledRejectionHandler();\n    handlers.push(handler);\n  }\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   * @memberof report\n   */\n\n\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; i -= 1) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n\n    if (handlers.length === 0) {\n      uninstallGlobalHandler();\n      uninstallGlobalUnhandledRejectionHandler();\n    }\n  }\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {StackTrace} stack\n   * @param {boolean} isWindowError Is this a top-level window error?\n   * @param {Error=} error The error that's being handled (if available, null otherwise)\n   * @memberof report\n   * @throws An exception if an error occurs while calling an handler.\n   */\n\n\n  function notifyHandlers(stack, isWindowError, error) {\n    var exception;\n\n    for (var i in handlers) {\n      if (has(handlers, i)) {\n        try {\n          handlers[i](stack, isWindowError, error);\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n\n    if (exception) {\n      throw exception;\n    }\n  }\n\n  var oldOnerrorHandler;\n  var onErrorHandlerInstalled;\n  var oldOnunhandledrejectionHandler;\n  var onUnhandledRejectionHandlerInstalled;\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {Event|string} message Error message.\n   * @param {string=} url URL of script that generated the exception.\n   * @param {(number|string)=} lineNo The line number at which the error occurred.\n   * @param {(number|string)=} columnNo The column number at which the error occurred.\n   * @param {Error=} errorObj The actual Error object.\n   * @memberof report\n   */\n\n  function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {\n    var stack;\n\n    if (lastExceptionStack) {\n      computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, \"\" + message);\n      processLastException();\n    } else if (errorObj) {\n      stack = computeStackTrace(errorObj);\n      notifyHandlers(stack, true, errorObj);\n    } else {\n      var location_1 = {\n        url: url,\n        column: columnNo,\n        line: lineNo\n      };\n      var name_1;\n      var msg = message;\n\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = msg.match(ERROR_TYPES_RE);\n\n        if (groups) {\n          name_1 = groups[1];\n          msg = groups[2];\n        }\n      }\n\n      stack = {\n        name: name_1,\n        message: msg,\n        stack: [location_1]\n      };\n      notifyHandlers(stack, true);\n    }\n\n    if (oldOnerrorHandler) {\n      return oldOnerrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  }\n  /**\n   * Ensures all unhandled rejections are recorded.\n   * @param {PromiseRejectionEvent} e event.\n   * @memberof report\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n   */\n\n\n  function traceKitWindowOnUnhandledRejection(e) {\n    var reason = e.reason || 'Empty reason';\n    var stack = computeStackTrace(reason);\n    notifyHandlers(stack, true, reason);\n  }\n  /**\n   * Install a global onerror handler\n   * @memberof report\n   */\n\n\n  function installGlobalHandler() {\n    if (onErrorHandlerInstalled) {\n      return;\n    }\n\n    oldOnerrorHandler = window.onerror;\n    window.onerror = monitor(traceKitWindowOnError);\n    onErrorHandlerInstalled = true;\n  }\n  /**\n   * Uninstall the global onerror handler\n   * @memberof report\n   */\n\n\n  function uninstallGlobalHandler() {\n    if (onErrorHandlerInstalled) {\n      window.onerror = oldOnerrorHandler;\n      onErrorHandlerInstalled = false;\n    }\n  }\n  /**\n   * Install a global onunhandledrejection handler\n   * @memberof report\n   */\n\n\n  function installGlobalUnhandledRejectionHandler() {\n    if (onUnhandledRejectionHandlerInstalled) {\n      return;\n    }\n\n    oldOnunhandledrejectionHandler = window.onunhandledrejection !== null ? window.onunhandledrejection : undefined;\n    window.onunhandledrejection = monitor(traceKitWindowOnUnhandledRejection);\n    onUnhandledRejectionHandlerInstalled = true;\n  }\n  /**\n   * Uninstall the global onunhandledrejection handler\n   * @memberof report\n   */\n\n\n  function uninstallGlobalUnhandledRejectionHandler() {\n    if (onUnhandledRejectionHandlerInstalled) {\n      window.onunhandledrejection = oldOnunhandledrejectionHandler;\n      onUnhandledRejectionHandlerInstalled = false;\n    }\n  }\n  /**\n   * Process the most recent exception\n   * @memberof report\n   */\n\n\n  function processLastException() {\n    var currentLastExceptionStack = lastExceptionStack;\n    var currentLastException = lastException;\n    lastExceptionStack = undefined;\n    lastException = undefined;\n    notifyHandlers(currentLastExceptionStack, false, currentLastException);\n  }\n  /**\n   * Reports an unhandled Error.\n   * @param {Error} ex\n   * @memberof report\n   * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n   */\n\n\n  function doReport(ex) {\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      }\n\n      processLastException();\n    }\n\n    var stack = computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex; // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n\n    setTimeout(function () {\n      if (lastException === ex) {\n        processLastException();\n      }\n    }, stack.incomplete ? 2000 : 0);\n    throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n  }\n\n  doReport.subscribe = subscribe;\n  doReport.unsubscribe = unsubscribe;\n  doReport.traceKitWindowOnError = traceKitWindowOnError;\n  return doReport;\n}();\n/**\n * computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = computeStackTrace.ofCaller([depth])\n *   s = computeStackTrace(exception) // consider using report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with report,\n * which builds on top of computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         let stackInfo = computeStackTrace.ofCaller();\n *         let data = message + \"\\n\";\n *         for(let i in stackInfo.stack) {\n *             let item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\n\nexport var computeStackTrace = function computeStackTraceWrapper() {\n  var debug = false; // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?StackTrace} Stack trace information.\n   * @memberof computeStackTrace\n   */\n\n  function computeStackTraceFromStackProp(ex) {\n    if (!ex.stack) {\n      return;\n    } // tslint:disable-next-line max-line-length\n\n\n    var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i; // tslint:disable-next-line max-line-length\n\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i; // tslint:disable-next-line max-line-length\n\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i; // Used to additionally parse URL/line/column from eval frames\n\n    var isEval;\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = ex.stack.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n\n    for (var i = 0, j = lines.length; i < j; i += 1) {\n      if (chrome.exec(lines[i])) {\n        parts = chrome.exec(lines[i]);\n        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n        isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n        submatch = chromeEval.exec(parts[2]);\n\n        if (isEval && submatch) {\n          // throw out eval line/column and use top-most line/column number\n          parts[2] = submatch[1]; // url\n\n          parts[3] = submatch[2]; // line\n\n          parts[4] = submatch[3]; // column\n        }\n\n        element = {\n          args: isNative ? [parts[2]] : [],\n          column: parts[4] ? +parts[4] : undefined,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          line: parts[3] ? +parts[3] : undefined,\n          url: !isNative ? parts[2] : undefined\n        };\n      } else if (winjs.exec(lines[i])) {\n        parts = winjs.exec(lines[i]);\n        element = {\n          args: [],\n          column: parts[4] ? +parts[4] : undefined,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          line: +parts[3],\n          url: parts[2]\n        };\n      } else if (gecko.exec(lines[i])) {\n        parts = gecko.exec(lines[i]);\n        isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        submatch = geckoEval.exec(parts[3]);\n\n        if (isEval && submatch) {\n          // throw out eval line/column and use top-most line number\n          parts[3] = submatch[1];\n          parts[4] = submatch[2];\n          parts[5] = undefined; // no column when eval\n        } else if (i === 0 && !parts[5] && !isUndefined(ex.columnNumber)) {\n          // FireFox uses this awesome columnNumber property for its top frame\n          // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n          // so adding 1\n          // NOTE: this hack doesn't work if top-most frame is eval\n          stack[0].column = ex.columnNumber + 1;\n        }\n\n        element = {\n          args: parts[2] ? parts[2].split(',') : [],\n          column: parts[5] ? +parts[5] : undefined,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          line: parts[4] ? +parts[4] : undefined,\n          url: parts[3]\n        };\n      } else {\n        continue;\n      }\n\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n\n      stack.push(element);\n    }\n\n    if (!stack.length) {\n      return;\n    }\n\n    return {\n      stack: stack,\n      message: ex.message,\n      name: ex.name\n    };\n  }\n  /**\n   * Computes stack trace information from the stacktrace property.\n   * Opera 10+ uses this property.\n   * @param {Error} ex\n   * @return {?StackTrace} Stack trace information.\n   * @memberof computeStackTrace\n   */\n\n\n  function computeStackTraceFromStacktraceProp(ex) {\n    // Access and store the stacktrace property before doing ANYTHING\n    // else to it because Opera is not very good at providing it\n    // reliably in other circumstances.\n    var stacktrace = ex.stacktrace;\n\n    if (!stacktrace) {\n      return;\n    }\n\n    var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i; // tslint:disable-next-line max-line-length\n\n    var opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i;\n    var lines = stacktrace.split('\\n');\n    var stack = [];\n    var parts;\n\n    for (var line = 0; line < lines.length; line += 2) {\n      var element = void 0;\n\n      if (opera10Regex.exec(lines[line])) {\n        parts = opera10Regex.exec(lines[line]);\n        element = {\n          args: [],\n          column: undefined,\n          func: parts[3],\n          line: +parts[1],\n          url: parts[2]\n        };\n      } else if (opera11Regex.exec(lines[line])) {\n        parts = opera11Regex.exec(lines[line]);\n        element = {\n          args: parts[5] ? parts[5].split(',') : [],\n          column: +parts[2],\n          func: parts[3] || parts[4],\n          line: +parts[1],\n          url: parts[6]\n        };\n      }\n\n      if (element) {\n        if (!element.func && element.line) {\n          element.func = UNKNOWN_FUNCTION;\n        }\n\n        element.context = [lines[line + 1]];\n        stack.push(element);\n      }\n    }\n\n    if (!stack.length) {\n      return;\n    }\n\n    return {\n      stack: stack,\n      message: ex.message,\n      name: ex.name\n    };\n  }\n  /**\n   * NOT TESTED.\n   * Computes stack trace information from an error message that includes\n   * the stack trace.\n   * Opera 9 and earlier use this method if the option to show stack\n   * traces is turned on in opera:config.\n   * @param {Error} ex\n   * @return {?StackTrace} Stack information.\n   * @memberof computeStackTrace\n   */\n\n\n  function computeStackTraceFromOperaMultiLineMessage(ex) {\n    // TODO: Clean this function up\n    // Opera includes a stack trace into the exception message. An example is:\n    //\n    // Statement on line 3: Undefined variable: undefinedFunc\n    // Backtrace:\n    //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js:\n    //   In function zzz\n    //         undefinedFunc(a);\n    //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n    //   In function yyy\n    //           zzz(x, y, z);\n    //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n    //   In function xxx\n    //           yyy(a, a, a);\n    //   Line 1 of function script\n    //     try { xxx('hi'); return false; } catch(ex) { report(ex); }\n    //   ...\n    var lines = ex.message.split('\\n');\n\n    if (lines.length < 4) {\n      return;\n    }\n\n    var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n    var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n    var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i;\n    var stack = [];\n    var scripts = window && window.document && window.document.getElementsByTagName('script');\n    var inlineScriptBlocks = [];\n    var parts;\n\n    for (var s in scripts) {\n      if (has(scripts, s) && !scripts[s].src) {\n        inlineScriptBlocks.push(scripts[s]);\n      }\n    }\n\n    for (var line = 2; line < lines.length; line += 2) {\n      var item = void 0;\n\n      if (lineRE1.exec(lines[line])) {\n        parts = lineRE1.exec(lines[line]);\n        item = {\n          args: [],\n          column: undefined,\n          func: parts[3],\n          line: +parts[1],\n          url: parts[2]\n        };\n      } else if (lineRE2.exec(lines[line])) {\n        parts = lineRE2.exec(lines[line]);\n        item = {\n          args: [],\n          column: undefined,\n          func: parts[4],\n          line: +parts[1],\n          url: parts[3]\n        };\n      } else if (lineRE3.exec(lines[line])) {\n        parts = lineRE3.exec(lines[line]);\n        var url = window.location.href.replace(/#.*$/, '');\n        item = {\n          url: url,\n          args: [],\n          column: undefined,\n          func: '',\n          line: +parts[1]\n        };\n      }\n\n      if (item) {\n        if (!item.func) {\n          item.func = UNKNOWN_FUNCTION;\n        }\n\n        item.context = [lines[line + 1]];\n        stack.push(item);\n      }\n    }\n\n    if (!stack.length) {\n      return; // could not parse multiline exception message as Opera stack trace\n    }\n\n    return {\n      stack: stack,\n      message: lines[0],\n      name: ex.name\n    };\n  }\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {StackTrace} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string=} url The URL of the script that caused an error.\n   * @param {(number|string)=} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   * @memberof computeStackTrace\n   */\n\n\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      url: url,\n      line: lineNo ? +lineNo : undefined\n    };\n\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n      var stack = stackInfo.stack;\n\n      if (stack.length > 0) {\n        if (stack[0].url === initial.url) {\n          if (stack[0].line === initial.line) {\n            return false; // already in stack trace\n          }\n\n          if (!stack[0].line && stack[0].func === initial.func) {\n            stack[0].line = initial.line;\n            stack[0].context = initial.context;\n            return false;\n          }\n        }\n      }\n\n      stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    }\n\n    stackInfo.incomplete = true;\n    return false;\n  }\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @param {number} depth\n   * @return {StackTrace} Stack trace information.\n   * @memberof computeStackTrace\n   */\n\n\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n    var stack = [];\n    var funcs = {};\n    var recursion = false;\n    var parts;\n    var item;\n\n    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n      if (curr === computeStackTrace || curr === report) {\n        continue;\n      }\n\n      item = {\n        args: [],\n        column: undefined,\n        func: UNKNOWN_FUNCTION,\n        line: undefined,\n        url: undefined\n      };\n      parts = functionName.exec(curr.toString());\n\n      if (curr.name) {\n        item.func = curr.name;\n      } else if (parts) {\n        item.func = parts[1];\n      }\n\n      if (typeof item.func === 'undefined') {\n        item.func = parts ? parts.input.substring(0, parts.input.indexOf('{')) : undefined;\n      }\n\n      if (funcs[\"\" + curr]) {\n        recursion = true;\n      } else {\n        funcs[\"\" + curr] = true;\n      }\n\n      stack.push(item);\n    }\n\n    if (depth) {\n      stack.splice(0, depth);\n    }\n\n    var result = {\n      stack: stack,\n      message: ex.message,\n      name: ex.name\n    };\n    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n    return result;\n  }\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   * @memberof computeStackTrace\n   */\n\n\n  function doComputeStackTrace(ex, depth) {\n    var stack;\n    var normalizedDepth = depth === undefined ? 0 : +depth;\n\n    try {\n      // This must be tried first because Opera 10 *destroys*\n      // its stacktrace property if you try to access the stack\n      // property first!!\n      stack = computeStackTraceFromStacktraceProp(ex);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceFromOperaMultiLineMessage(ex);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, normalizedDepth + 1);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (debug) {\n        throw e;\n      }\n    }\n\n    return {\n      message: ex.message,\n      name: ex.name,\n      stack: []\n    };\n  }\n  /**\n   * Logs a stacktrace starting from the previous call and working down.\n   * @param {(number|string)=} depth How many frames deep to trace.\n   * @return {StackTrace} Stack trace information.\n   * @memberof computeStackTrace\n   */\n\n\n  function computeStackTraceOfCaller(depth) {\n    var currentDepth = (depth === undefined ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n\n    try {\n      throw new Error();\n    } catch (ex) {\n      return computeStackTrace(ex, currentDepth + 1);\n    }\n  }\n\n  doComputeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  doComputeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n  doComputeStackTrace.ofCaller = computeStackTraceOfCaller;\n  return doComputeStackTrace;\n}();\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof TraceKit\n */\n\nexport function extendToAsynchronousCallbacks() {\n  function helper(fnName) {\n    var originalFn = window[fnName];\n\n    window[fnName] = function traceKitAsyncExtension() {\n      // Make a copy of the arguments\n      var args = [].slice.call(arguments);\n      var originalCallback = args[0];\n\n      if (typeof originalCallback === 'function') {\n        args[0] = wrap(originalCallback);\n      } // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n      // also only supports 2 argument and doesn't care what \"this\" is, so we\n      // can just call the original function directly.\n\n\n      if (originalFn.apply) {\n        return originalFn.apply(this, args);\n      }\n\n      return originalFn(args[0], args[1]);\n    };\n  }\n\n  helper('setTimeout');\n  helper('setInterval');\n}","map":{"version":3,"sources":["../src/tracekit.ts"],"names":[],"mappings":"AAAA;AAEA,SAAS,OAAT,QAAwB,sBAAxB;AAkDA,IAAM,gBAAgB,GAAG,GAAzB,C,CAEA;AACA;;AACA,IAAM,cAAc,GAAG,yGAAvB;AAEA;;;;;;;;;AAQA,SAAS,GAAT,CAAa,MAAb,EAA6B,GAA7B,EAAwC;AACtC,SAAO,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,MAArC,EAA6C,GAA7C,CAAP;AACD;AAED;;;;;;;;;AAOA,SAAS,WAAT,CAAqB,IAArB,EAA8B;AAC5B,SAAO,OAAO,IAAP,KAAgB,WAAvB;AACD;AAED;;;;;;;;AAQA;;;AACA,OAAM,SAAU,IAAV,CAAe,IAAf,EAA6B;AACjC,WAAS,OAAT,GAAgB;AACd,QAAI;AACF,aAAO,IAAI,CAAC,KAAL,CAAW,IAAX,EAAiB,SAAjB,CAAP;AACD,KAFD,CAEE,OAAO,CAAP,EAAU;AACV,MAAA,MAAM,CAAC,CAAD,CAAN;AACA,YAAM,CAAN;AACD;AACF;;AACD,SAAO,OAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA,OAAO,IAAM,MAAM,GAAI,SAAS,mBAAT,GAA4B;AACjD,MAAM,QAAQ,GAAc,EAA5B;AACA,MAAI,aAAJ;AACA,MAAI,kBAAJ;AAEA;;;;;;AAKA,WAAS,SAAT,CAAmB,OAAnB,EAAmC;AACjC,IAAA,oBAAoB;AACpB,IAAA,sCAAsC;AACtC,IAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;AACD;AAED;;;;;;;AAKA,WAAS,WAAT,CAAqB,OAArB,EAAqC;AACnC,SAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAT,GAAkB,CAA/B,EAAkC,CAAC,IAAI,CAAvC,EAA0C,CAAC,IAAI,CAA/C,EAAkD;AAChD,UAAI,QAAQ,CAAC,CAAD,CAAR,KAAgB,OAApB,EAA6B;AAC3B,QAAA,QAAQ,CAAC,MAAT,CAAgB,CAAhB,EAAmB,CAAnB;AACD;AACF;;AAED,QAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,MAAA,sBAAsB;AACtB,MAAA,wCAAwC;AACzC;AACF;AAED;;;;;;;;;;AAQA,WAAS,cAAT,CAAwB,KAAxB,EAA2C,aAA3C,EAAmE,KAAnE,EAA8E;AAC5E,QAAI,SAAJ;;AACA,SAAK,IAAM,CAAX,IAAgB,QAAhB,EAA0B;AACxB,UAAI,GAAG,CAAC,QAAD,EAAW,CAAX,CAAP,EAAsB;AACpB,YAAI;AACF,UAAA,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAZ,EAAmB,aAAnB,EAAkC,KAAlC;AACD,SAFD,CAEE,OAAO,KAAP,EAAc;AACd,UAAA,SAAS,GAAG,KAAZ;AACD;AACF;AACF;;AAED,QAAI,SAAJ,EAAe;AACb,YAAM,SAAN;AACD;AACF;;AAED,MAAI,iBAAJ;AACA,MAAI,uBAAJ;AACA,MAAI,8BAAJ;AACA,MAAI,oCAAJ;AAEA;;;;;;;;;;;AAUA,WAAS,qBAAT,CAEE,OAFF,EAGE,GAHF,EAIE,MAJF,EAKE,QALF,EAME,QANF,EAMkB;AAEhB,QAAI,KAAJ;;AAEA,QAAI,kBAAJ,EAAwB;AACtB,MAAA,iBAAiB,CAAC,mCAAlB,CAAsD,kBAAtD,EAA0E,GAA1E,EAA+E,MAA/E,EAAuF,KAAG,OAA1F;AACA,MAAA,oBAAoB;AACrB,KAHD,MAGO,IAAI,QAAJ,EAAc;AACnB,MAAA,KAAK,GAAG,iBAAiB,CAAC,QAAD,CAAzB;AACA,MAAA,cAAc,CAAC,KAAD,EAAQ,IAAR,EAAc,QAAd,CAAd;AACD,KAHM,MAGA;AACL,UAAM,UAAQ,GAAG;AACf,QAAA,GAAG,EAAA,GADY;AAEf,QAAA,MAAM,EAAE,QAFO;AAGf,QAAA,IAAI,EAAE;AAHS,OAAjB;AAMA,UAAI,MAAJ;AACA,UAAI,GAAG,GAAG,OAAV;;AACA,UAAI,GAAG,QAAH,CAAY,IAAZ,CAAiB,OAAjB,MAA8B,iBAAlC,EAAqD;AACnD,YAAM,MAAM,GAAI,GAAc,CAAC,KAAf,CAAqB,cAArB,CAAhB;;AACA,YAAI,MAAJ,EAAY;AACV,UAAA,MAAI,GAAG,MAAM,CAAC,CAAD,CAAb;AACA,UAAA,GAAG,GAAG,MAAM,CAAC,CAAD,CAAZ;AACD;AACF;;AAED,MAAA,KAAK,GAAG;AACN,QAAA,IAAI,EAAA,MADE;AAEN,QAAA,OAAO,EAAE,GAFH;AAGN,QAAA,KAAK,EAAE,CAAC,UAAD;AAHD,OAAR;AAMA,MAAA,cAAc,CAAC,KAAD,EAAQ,IAAR,CAAd;AACD;;AAED,QAAI,iBAAJ,EAAuB;AACrB,aAAO,iBAAiB,CAAC,KAAlB,CAAwB,IAAxB,EAA8B,SAA9B,CAAP;AACD;;AAED,WAAO,KAAP;AACD;AAED;;;;;;;;;AAOA,WAAS,kCAAT,CAA4C,CAA5C,EAAoE;AAClE,QAAM,MAAM,GAAG,CAAC,CAAC,MAAF,IAAY,cAA3B;AACA,QAAM,KAAK,GAAG,iBAAiB,CAAC,MAAD,CAA/B;AACA,IAAA,cAAc,CAAC,KAAD,EAAQ,IAAR,EAAc,MAAd,CAAd;AACD;AAED;;;;;;AAIA,WAAS,oBAAT,GAA6B;AAC3B,QAAI,uBAAJ,EAA6B;AAC3B;AACD;;AAED,IAAA,iBAAiB,GAAG,MAAM,CAAC,OAA3B;AACA,IAAA,MAAM,CAAC,OAAP,GAAiB,OAAO,CAAC,qBAAD,CAAxB;AACA,IAAA,uBAAuB,GAAG,IAA1B;AACD;AAED;;;;;;AAIA,WAAS,sBAAT,GAA+B;AAC7B,QAAI,uBAAJ,EAA6B;AAC3B,MAAA,MAAM,CAAC,OAAP,GAAiB,iBAAjB;AACA,MAAA,uBAAuB,GAAG,KAA1B;AACD;AACF;AAED;;;;;;AAIA,WAAS,sCAAT,GAA+C;AAC7C,QAAI,oCAAJ,EAA0C;AACxC;AACD;;AAED,IAAA,8BAA8B,GAAG,MAAM,CAAC,oBAAP,KAAgC,IAAhC,GAAuC,MAAM,CAAC,oBAA9C,GAAqE,SAAtG;AACA,IAAA,MAAM,CAAC,oBAAP,GAA8B,OAAO,CAAC,kCAAD,CAArC;AACA,IAAA,oCAAoC,GAAG,IAAvC;AACD;AAED;;;;;;AAIA,WAAS,wCAAT,GAAiD;AAC/C,QAAI,oCAAJ,EAA0C;AACxC,MAAA,MAAM,CAAC,oBAAP,GAA8B,8BAA9B;AACA,MAAA,oCAAoC,GAAG,KAAvC;AACD;AACF;AAED;;;;;;AAIA,WAAS,oBAAT,GAA6B;AAC3B,QAAM,yBAAyB,GAAG,kBAAlC;AACA,QAAM,oBAAoB,GAAG,aAA7B;AACA,IAAA,kBAAkB,GAAG,SAArB;AACA,IAAA,aAAa,GAAG,SAAhB;AACA,IAAA,cAAc,CAAC,yBAAD,EAA4B,KAA5B,EAAmC,oBAAnC,CAAd;AACD;AAED;;;;;;;;AAMA,WAAS,QAAT,CAAkB,EAAlB,EAA2B;AACzB,QAAI,kBAAJ,EAAwB;AACtB,UAAI,aAAa,KAAK,EAAtB,EAA0B;AACxB,eADwB,CACjB;AACR;;AACD,MAAA,oBAAoB;AACrB;;AAED,QAAM,KAAK,GAAG,iBAAiB,CAAC,EAAD,CAA/B;AACA,IAAA,kBAAkB,GAAG,KAArB;AACA,IAAA,aAAa,GAAG,EAAhB,CAVyB,CAYzB;AACA;AACA;AACA;;AACA,IAAA,UAAU,CACR,YAAA;AACE,UAAI,aAAa,KAAK,EAAtB,EAA0B;AACxB,QAAA,oBAAoB;AACrB;AACF,KALO,EAMR,KAAK,CAAC,UAAN,GAAmB,IAAnB,GAA0B,CANlB,CAAV;AASA,UAAM,EAAN,CAzByB,CAyBhB;AACV;;AAED,EAAA,QAAQ,CAAC,SAAT,GAAqB,SAArB;AACA,EAAA,QAAQ,CAAC,WAAT,GAAuB,WAAvB;AACA,EAAA,QAAQ,CAAC,qBAAT,GAAiC,qBAAjC;AAEA,SAAO,QAAP;AACD,CA7OqB,EAAf;AA+OP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DA,OAAO,IAAM,iBAAiB,GAAI,SAAS,wBAAT,GAAiC;AACjE,MAAM,KAAK,GAAG,KAAd,CADiE,CAGjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AAOA,WAAS,8BAAT,CAAwC,EAAxC,EAAiD;AAC/C,QAAI,CAAC,EAAE,CAAC,KAAR,EAAe;AACb;AACD,KAH8C,CAK/C;;;AACA,QAAM,MAAM,GAAG,6HAAf,CAN+C,CAO/C;;AACA,QAAM,KAAK,GAAG,iIAAd,CAR+C,CAS/C;;AACA,QAAM,KAAK,GAAG,+GAAd,CAV+C,CAY/C;;AACA,QAAI,MAAJ;AACA,QAAM,SAAS,GAAG,+CAAlB;AACA,QAAM,UAAU,GAAG,+BAAnB;AACA,QAAM,KAAK,GAAG,EAAE,CAAC,KAAH,CAAS,KAAT,CAAe,IAAf,CAAd;AACA,QAAM,KAAK,GAAG,EAAd;AACA,QAAI,QAAJ;AACA,QAAI,KAAJ;AACA,QAAI,OAAJ;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,GAAG,CAAtC,EAAyC,CAAC,IAAI,CAA9C,EAAiD;AAC/C,UAAI,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,CAAD,CAAjB,CAAJ,EAA2B;AACzB,QAAA,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,CAAD,CAAjB,CAAR;AACA,YAAM,QAAQ,GAAG,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,QAAjB,MAA+B,CAA5D,CAFyB,CAEqC;;AAC9D,QAAA,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,MAAjB,MAA6B,CAAlD,CAHyB,CAG2B;;AACpD,QAAA,QAAQ,GAAG,UAAU,CAAC,IAAX,CAAgB,KAAK,CAAC,CAAD,CAArB,CAAX;;AACA,YAAI,MAAM,IAAI,QAAd,EAAwB;AACtB;AACA,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,CAAC,CAAD,CAAnB,CAFsB,CAEC;;AACvB,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,CAAC,CAAD,CAAnB,CAHsB,CAGC;;AACvB,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,CAAC,CAAD,CAAnB,CAJsB,CAIC;AACxB;;AACD,QAAA,OAAO,GAAG;AACR,UAAA,IAAI,EAAE,QAAQ,GAAG,CAAC,KAAK,CAAC,CAAD,CAAN,CAAH,GAAgB,EADtB;AAER,UAAA,MAAM,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,GAAuB,SAFvB;AAGR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,IAAY,gBAHV;AAIR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,GAAuB,SAJrB;AAKR,UAAA,GAAG,EAAE,CAAC,QAAD,GAAY,KAAK,CAAC,CAAD,CAAjB,GAAuB;AALpB,SAAV;AAOD,OAlBD,MAkBO,IAAI,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,CAAD,CAAhB,CAAJ,EAA0B;AAC/B,QAAA,KAAK,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,CAAD,CAAhB,CAAR;AACA,QAAA,OAAO,GAAG;AACR,UAAA,IAAI,EAAE,EADE;AAER,UAAA,MAAM,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,GAAuB,SAFvB;AAGR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,IAAY,gBAHV;AAIR,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD,CAJJ;AAKR,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALF,SAAV;AAOD,OATM,MASA,IAAI,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,CAAD,CAAhB,CAAJ,EAA0B;AAC/B,QAAA,KAAK,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,CAAD,CAAhB,CAAR;AACA,QAAA,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,SAAjB,IAA8B,CAAC,CAApD;AACA,QAAA,QAAQ,GAAG,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,CAAD,CAApB,CAAX;;AACA,YAAI,MAAM,IAAI,QAAd,EAAwB;AACtB;AACA,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,CAAC,CAAD,CAAnB;AACA,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,CAAC,CAAD,CAAnB;AACA,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,SAAX,CAJsB,CAIA;AACvB,SALD,MAKO,IAAI,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,IAAwB,CAAC,WAAW,CAAE,EAAU,CAAC,YAAb,CAAxC,EAAoE;AACzE;AACA;AACA;AACA;AACA,UAAA,KAAK,CAAC,CAAD,CAAL,CAAS,MAAT,GAAmB,EAAU,CAAC,YAAX,GAA0B,CAA7C;AACD;;AACD,QAAA,OAAO,GAAG;AACR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,KAAK,CAAC,CAAD,CAAL,CAAS,KAAT,CAAe,GAAf,CAAX,GAAiC,EAD/B;AAER,UAAA,MAAM,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,GAAuB,SAFvB;AAGR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,IAAY,gBAHV;AAIR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,KAAK,CAAC,CAAD,CAAjB,GAAuB,SAJrB;AAKR,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALF,SAAV;AAOD,OAvBM,MAuBA;AACL;AACD;;AAED,UAAI,CAAC,OAAO,CAAC,IAAT,IAAiB,OAAO,CAAC,IAA7B,EAAmC;AACjC,QAAA,OAAO,CAAC,IAAR,GAAe,gBAAf;AACD;;AACD,MAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACD;;AAED,QAAI,CAAC,KAAK,CAAC,MAAX,EAAmB;AACjB;AACD;;AAED,WAAO;AACL,MAAA,KAAK,EAAA,KADA;AAEL,MAAA,OAAO,EAAE,EAAE,CAAC,OAFP;AAGL,MAAA,IAAI,EAAE,EAAE,CAAC;AAHJ,KAAP;AAKD;AAED;;;;;;;;;AAOA,WAAS,mCAAT,CAA6C,EAA7C,EAAsD;AACpD;AACA;AACA;AACA,QAAM,UAAU,GAAI,EAAU,CAAC,UAA/B;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf;AACD;;AAED,QAAM,YAAY,GAAG,6DAArB,CAToD,CAUpD;;AACA,QAAM,YAAY,GAAG,sGAArB;AACA,QAAM,KAAK,GAAG,UAAU,CAAC,KAAX,CAAiB,IAAjB,CAAd;AACA,QAAM,KAAK,GAAG,EAAd;AACA,QAAI,KAAJ;;AAEA,SAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,KAAK,CAAC,MAAhC,EAAwC,IAAI,IAAI,CAAhD,EAAmD;AACjD,UAAI,OAAO,GAAA,KAAA,CAAX;;AACA,UAAI,YAAY,CAAC,IAAb,CAAkB,KAAK,CAAC,IAAD,CAAvB,CAAJ,EAAoC;AAClC,QAAA,KAAK,GAAG,YAAY,CAAC,IAAb,CAAkB,KAAK,CAAC,IAAD,CAAvB,CAAR;AACA,QAAA,OAAO,GAAG;AACR,UAAA,IAAI,EAAE,EADE;AAER,UAAA,MAAM,EAAE,SAFA;AAGR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAHH;AAIR,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD,CAJJ;AAKR,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALF,SAAV;AAOD,OATD,MASO,IAAI,YAAY,CAAC,IAAb,CAAkB,KAAK,CAAC,IAAD,CAAvB,CAAJ,EAAoC;AACzC,QAAA,KAAK,GAAG,YAAY,CAAC,IAAb,CAAkB,KAAK,CAAC,IAAD,CAAvB,CAAR;AACA,QAAA,OAAO,GAAG;AACR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,GAAW,KAAK,CAAC,CAAD,CAAL,CAAS,KAAT,CAAe,GAAf,CAAX,GAAiC,EAD/B;AAER,UAAA,MAAM,EAAE,CAAC,KAAK,CAAC,CAAD,CAFN;AAGR,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CAHf;AAIR,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD,CAJJ;AAKR,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALF,SAAV;AAOD;;AAED,UAAI,OAAJ,EAAa;AACX,YAAI,CAAC,OAAO,CAAC,IAAT,IAAiB,OAAO,CAAC,IAA7B,EAAmC;AACjC,UAAA,OAAO,CAAC,IAAR,GAAe,gBAAf;AACD;;AACD,QAAA,OAAO,CAAC,OAAR,GAAkB,CAAC,KAAK,CAAC,IAAI,GAAG,CAAR,CAAN,CAAlB;AAEA,QAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACD;AACF;;AAED,QAAI,CAAC,KAAK,CAAC,MAAX,EAAmB;AACjB;AACD;;AAED,WAAO;AACL,MAAA,KAAK,EAAA,KADA;AAEL,MAAA,OAAO,EAAE,EAAE,CAAC,OAFP;AAGL,MAAA,IAAI,EAAE,EAAE,CAAC;AAHJ,KAAP;AAKD;AAED;;;;;;;;;;;;AAUA,WAAS,0CAAT,CAAoD,EAApD,EAA6D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,QAAM,KAAK,GAAG,EAAE,CAAC,OAAH,CAAW,KAAX,CAAiB,IAAjB,CAAd;;AACA,QAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB;AACD;;AAED,QAAM,OAAO,GAAG,wFAAhB;AACA,QAAM,OAAO,GAAG,iGAAhB;AACA,QAAM,OAAO,GAAG,wCAAhB;AACA,QAAM,KAAK,GAAG,EAAd;AACA,QAAM,OAAO,GAAG,MAAM,IAAI,MAAM,CAAC,QAAjB,IAA6B,MAAM,CAAC,QAAP,CAAgB,oBAAhB,CAAqC,QAArC,CAA7C;AACA,QAAM,kBAAkB,GAAG,EAA3B;AACA,QAAI,KAAJ;;AAEA,SAAK,IAAM,CAAX,IAAgB,OAAhB,EAAyB;AACvB,UAAI,GAAG,CAAC,OAAD,EAAU,CAAV,CAAH,IAAmB,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,GAAnC,EAAwC;AACtC,QAAA,kBAAkB,CAAC,IAAnB,CAAwB,OAAO,CAAC,CAAD,CAA/B;AACD;AACF;;AAED,SAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,KAAK,CAAC,MAAhC,EAAwC,IAAI,IAAI,CAAhD,EAAmD;AACjD,UAAI,IAAI,GAAA,KAAA,CAAR;;AACA,UAAI,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAJ,EAA+B;AAC7B,QAAA,KAAK,GAAG,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAR;AACA,QAAA,IAAI,GAAG;AACL,UAAA,IAAI,EAAE,EADD;AAEL,UAAA,MAAM,EAAE,SAFH;AAGL,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAHN;AAIL,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD,CAJP;AAKL,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALL,SAAP;AAOD,OATD,MASO,IAAI,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAJ,EAA+B;AACpC,QAAA,KAAK,GAAG,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAR;AACA,QAAA,IAAI,GAAG;AACL,UAAA,IAAI,EAAE,EADD;AAEL,UAAA,MAAM,EAAE,SAFH;AAGL,UAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CAHN;AAIL,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD,CAJP;AAKL,UAAA,GAAG,EAAE,KAAK,CAAC,CAAD;AALL,SAAP;AAOD,OATM,MASA,IAAI,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAJ,EAA+B;AACpC,QAAA,KAAK,GAAG,OAAO,CAAC,IAAR,CAAa,KAAK,CAAC,IAAD,CAAlB,CAAR;AACA,YAAM,GAAG,GAAG,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAqB,OAArB,CAA6B,MAA7B,EAAqC,EAArC,CAAZ;AACA,QAAA,IAAI,GAAG;AACL,UAAA,GAAG,EAAA,GADE;AAEL,UAAA,IAAI,EAAE,EAFD;AAGL,UAAA,MAAM,EAAE,SAHH;AAIL,UAAA,IAAI,EAAE,EAJD;AAKL,UAAA,IAAI,EAAE,CAAC,KAAK,CAAC,CAAD;AALP,SAAP;AAOD;;AAED,UAAI,IAAJ,EAAU;AACR,YAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AACd,UAAA,IAAI,CAAC,IAAL,GAAY,gBAAZ;AACD;;AACD,QAAA,IAAI,CAAC,OAAL,GAAe,CAAC,KAAK,CAAC,IAAI,GAAG,CAAR,CAAN,CAAf;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACD;AACF;;AACD,QAAI,CAAC,KAAK,CAAC,MAAX,EAAmB;AACjB,aADiB,CACV;AACR;;AAED,WAAO;AACL,MAAA,KAAK,EAAA,KADA;AAEL,MAAA,OAAO,EAAE,KAAK,CAAC,CAAD,CAFT;AAGL,MAAA,IAAI,EAAE,EAAE,CAAC;AAHJ,KAAP;AAKD;AAED;;;;;;;;;;;;;;;;AAcA,WAAS,mCAAT,CACE,SADF,EAEE,GAFF,EAGE,MAHF,EAIE,OAJF,EAIkB;AAEhB,QAAM,OAAO,GAAe;AAC1B,MAAA,GAAG,EAAA,GADuB;AAE1B,MAAA,IAAI,EAAE,MAAM,GAAG,CAAC,MAAJ,GAAa;AAFC,KAA5B;;AAKA,QAAI,OAAO,CAAC,GAAR,IAAe,OAAO,CAAC,IAA3B,EAAiC;AAC/B,MAAA,SAAS,CAAC,UAAV,GAAuB,KAAvB;AAEA,UAAM,KAAK,GAAG,SAAS,CAAC,KAAxB;;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,YAAI,KAAK,CAAC,CAAD,CAAL,CAAS,GAAT,KAAiB,OAAO,CAAC,GAA7B,EAAkC;AAChC,cAAI,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,KAAkB,OAAO,CAAC,IAA9B,EAAoC;AAClC,mBAAO,KAAP,CADkC,CACrB;AACd;;AACD,cAAI,CAAC,KAAK,CAAC,CAAD,CAAL,CAAS,IAAV,IAAkB,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,KAAkB,OAAO,CAAC,IAAhD,EAAsD;AACpD,YAAA,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,GAAgB,OAAO,CAAC,IAAxB;AACA,YAAA,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,GAAmB,OAAO,CAAC,OAA3B;AACA,mBAAO,KAAP;AACD;AACF;AACF;;AAED,MAAA,KAAK,CAAC,OAAN,CAAc,OAAd;AACA,MAAA,SAAS,CAAC,OAAV,GAAoB,IAApB;AACA,aAAO,IAAP;AACD;;AACD,IAAA,SAAS,CAAC,UAAV,GAAuB,IAAvB;AAEA,WAAO,KAAP;AACD;AAED;;;;;;;;;;;;;AAWA,WAAS,qCAAT,CAA+C,EAA/C,EAAiE,KAAjE,EAA8E;AAC5E,QAAM,YAAY,GAAG,oEAArB;AACA,QAAM,KAAK,GAAG,EAAd;AACA,QAAM,KAAK,GAAQ,EAAnB;AACA,QAAI,SAAS,GAAG,KAAhB;AACA,QAAI,KAAJ;AACA,QAAI,IAAJ;;AAEA,SAAK,IAAI,IAAI,GAAG,qCAAqC,CAAC,MAAtD,EAA8D,IAAI,IAAI,CAAC,SAAvE,EAAkF,IAAI,GAAG,IAAI,CAAC,MAA9F,EAAsG;AACpG,UAAI,IAAI,KAAK,iBAAT,IAA8B,IAAI,KAAK,MAA3C,EAAmD;AACjD;AACD;;AAED,MAAA,IAAI,GAAG;AACL,QAAA,IAAI,EAAE,EADD;AAEL,QAAA,MAAM,EAAE,SAFH;AAGL,QAAA,IAAI,EAAE,gBAHD;AAIL,QAAA,IAAI,EAAE,SAJD;AAKL,QAAA,GAAG,EAAE;AALA,OAAP;AAQA,MAAA,KAAK,GAAG,YAAY,CAAC,IAAb,CAAkB,IAAI,CAAC,QAAL,EAAlB,CAAR;;AACA,UAAK,IAAY,CAAC,IAAlB,EAAwB;AACtB,QAAA,IAAI,CAAC,IAAL,GAAa,IAAY,CAAC,IAA1B;AACD,OAFD,MAEO,IAAI,KAAJ,EAAW;AAChB,QAAA,IAAI,CAAC,IAAL,GAAY,KAAK,CAAC,CAAD,CAAjB;AACD;;AAED,UAAI,OAAO,IAAI,CAAC,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,QAAA,IAAI,CAAC,IAAL,GAAY,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,SAAZ,CAAsB,CAAtB,EAAyB,KAAK,CAAC,KAAN,CAAY,OAAZ,CAAoB,GAApB,CAAzB,CAAH,GAAwD,SAAzE;AACD;;AAED,UAAI,KAAK,CAAC,KAAG,IAAJ,CAAT,EAAsB;AACpB,QAAA,SAAS,GAAG,IAAZ;AACD,OAFD,MAEO;AACL,QAAA,KAAK,CAAC,KAAG,IAAJ,CAAL,GAAmB,IAAnB;AACD;;AAED,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACD;;AAED,QAAI,KAAJ,EAAW;AACT,MAAA,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,KAAhB;AACD;;AAED,QAAM,MAAM,GAAe;AACzB,MAAA,KAAK,EAAA,KADoB;AAEzB,MAAA,OAAO,EAAE,EAAE,CAAC,OAFa;AAGzB,MAAA,IAAI,EAAE,EAAE,CAAC;AAHgB,KAA3B;AAKA,IAAA,mCAAmC,CACjC,MADiC,EAEjC,EAAE,CAAC,SAAH,IAAgB,EAAE,CAAC,QAFc,EAGjC,EAAE,CAAC,IAAH,IAAW,EAAE,CAAC,UAHmB,EAIjC,EAAE,CAAC,OAAH,IAAc,EAAE,CAAC,WAJgB,CAAnC;AAMA,WAAO,MAAP;AACD;AAED;;;;;;;;AAMA,WAAS,mBAAT,CAA6B,EAA7B,EAAwC,KAAxC,EAA+D;AAC7D,QAAI,KAAJ;AACA,QAAM,eAAe,GAAG,KAAK,KAAK,SAAV,GAAsB,CAAtB,GAA0B,CAAC,KAAnD;;AAEA,QAAI;AACF;AACA;AACA;AACA,MAAA,KAAK,GAAG,mCAAmC,CAAC,EAAD,CAA3C;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,KAAP;AACD;AACF,KARD,CAQE,OAAO,CAAP,EAAU;AACV,UAAI,KAAJ,EAAW;AACT,cAAM,CAAN;AACD;AACF;;AAED,QAAI;AACF,MAAA,KAAK,GAAG,8BAA8B,CAAC,EAAD,CAAtC;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,KAAP;AACD;AACF,KALD,CAKE,OAAO,CAAP,EAAU;AACV,UAAI,KAAJ,EAAW;AACT,cAAM,CAAN;AACD;AACF;;AAED,QAAI;AACF,MAAA,KAAK,GAAG,0CAA0C,CAAC,EAAD,CAAlD;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,KAAP;AACD;AACF,KALD,CAKE,OAAO,CAAP,EAAU;AACV,UAAI,KAAJ,EAAW;AACT,cAAM,CAAN;AACD;AACF;;AAED,QAAI;AACF,MAAA,KAAK,GAAG,qCAAqC,CAAC,EAAD,EAAK,eAAe,GAAG,CAAvB,CAA7C;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,KAAP;AACD;AACF,KALD,CAKE,OAAO,CAAP,EAAU;AACV,UAAI,KAAJ,EAAW;AACT,cAAM,CAAN;AACD;AACF;;AAED,WAAO;AACL,MAAA,OAAO,EAAE,EAAE,CAAC,OADP;AAEL,MAAA,IAAI,EAAE,EAAE,CAAC,IAFJ;AAGL,MAAA,KAAK,EAAE;AAHF,KAAP;AAKD;AAED;;;;;;;;AAMA,WAAS,yBAAT,CAAmC,KAAnC,EAAiD;AAC/C,QAAM,YAAY,GAAG,CAAC,KAAK,KAAK,SAAV,GAAsB,CAAtB,GAA0B,CAAC,KAA5B,IAAqC,CAA1D,CAD+C,CACa;;AAC5D,QAAI;AACF,YAAM,IAAI,KAAJ,EAAN;AACD,KAFD,CAEE,OAAO,EAAP,EAAW;AACX,aAAO,iBAAiB,CAAC,EAAD,EAAK,YAAY,GAAG,CAApB,CAAxB;AACD;AACF;;AAED,EAAA,mBAAmB,CAAC,mCAApB,GAA0D,mCAA1D;AACA,EAAA,mBAAmB,CAAC,8BAApB,GAAqD,8BAArD;AACA,EAAA,mBAAmB,CAAC,QAApB,GAA+B,yBAA/B;AAEA,SAAO,mBAAP;AACD,CA/fgC,EAA1B;AAigBP;;;;;;AAKA,OAAM,SAAU,6BAAV,GAAuC;AAC3C,WAAS,MAAT,CAAgB,MAAhB,EAA2B;AACzB,QAAM,UAAU,GAAI,MAAc,CAAC,MAAD,CAAlC;;AACE,IAAA,MAAc,CAAC,MAAD,CAAd,GAAyB,SAAS,sBAAT,GAA+B;AACxD;AACA,UAAM,IAAI,GAAU,GAAG,KAAH,CAAS,IAAT,CAAc,SAAd,CAApB;AACA,UAAM,gBAAgB,GAAG,IAAI,CAAC,CAAD,CAA7B;;AACA,UAAI,OAAO,gBAAP,KAA4B,UAAhC,EAA4C;AAC1C,QAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,CAAC,gBAAD,CAAd;AACD,OANuD,CAOxD;AACA;AACA;;;AACA,UAAI,UAAU,CAAC,KAAf,EAAsB;AACpB,eAAO,UAAU,CAAC,KAAX,CAAiB,IAAjB,EAAuB,IAAvB,CAAP;AACD;;AACD,aAAO,UAAU,CAAC,IAAI,CAAC,CAAD,CAAL,EAAU,IAAI,CAAC,CAAD,CAAd,CAAjB;AACD,KAdC;AAeH;;AAED,EAAA,MAAM,CAAC,YAAD,CAAN;AACA,EAAA,MAAM,CAAC,aAAD,CAAN;AACD","sourceRoot":"","sourcesContent":["// tslint:disable no-unsafe-any\nimport { monitor } from './internalMonitoring';\nvar UNKNOWN_FUNCTION = '?';\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\n// tslint:disable-next-line max-line-length\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nfunction has(object, key) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n}\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nfunction isUndefined(what) {\n    return typeof what === 'undefined';\n}\n/**\n * Wrap any function in a TraceKit reporter<br/>\n * Example: `func = wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof TraceKit\n */\n// tslint:disable-next-line ban-types\nexport function wrap(func) {\n    function wrapped() {\n        try {\n            return func.apply(this, arguments);\n        }\n        catch (e) {\n            report(e);\n            throw e;\n        }\n    }\n    return wrapped;\n}\n/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   report.subscribe(function(stackInfo) { ... })\n *   report.unsubscribe(function(stackInfo) { ... })\n *   report(exception)\n *   try { ...code... } catch(ex) { report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where report was called.\n *\n * Handlers receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\nexport var report = (function reportModuleWrapper() {\n    var handlers = [];\n    var lastException;\n    var lastExceptionStack;\n    /**\n     * Add a crash handler.\n     * @param {Function} handler\n     * @memberof report\n     */\n    function subscribe(handler) {\n        installGlobalHandler();\n        installGlobalUnhandledRejectionHandler();\n        handlers.push(handler);\n    }\n    /**\n     * Remove a crash handler.\n     * @param {Function} handler\n     * @memberof report\n     */\n    function unsubscribe(handler) {\n        for (var i = handlers.length - 1; i >= 0; i -= 1) {\n            if (handlers[i] === handler) {\n                handlers.splice(i, 1);\n            }\n        }\n        if (handlers.length === 0) {\n            uninstallGlobalHandler();\n            uninstallGlobalUnhandledRejectionHandler();\n        }\n    }\n    /**\n     * Dispatch stack information to all handlers.\n     * @param {StackTrace} stack\n     * @param {boolean} isWindowError Is this a top-level window error?\n     * @param {Error=} error The error that's being handled (if available, null otherwise)\n     * @memberof report\n     * @throws An exception if an error occurs while calling an handler.\n     */\n    function notifyHandlers(stack, isWindowError, error) {\n        var exception;\n        for (var i in handlers) {\n            if (has(handlers, i)) {\n                try {\n                    handlers[i](stack, isWindowError, error);\n                }\n                catch (inner) {\n                    exception = inner;\n                }\n            }\n        }\n        if (exception) {\n            throw exception;\n        }\n    }\n    var oldOnerrorHandler;\n    var onErrorHandlerInstalled;\n    var oldOnunhandledrejectionHandler;\n    var onUnhandledRejectionHandlerInstalled;\n    /**\n     * Ensures all global unhandled exceptions are recorded.\n     * Supported by Gecko and IE.\n     * @param {Event|string} message Error message.\n     * @param {string=} url URL of script that generated the exception.\n     * @param {(number|string)=} lineNo The line number at which the error occurred.\n     * @param {(number|string)=} columnNo The column number at which the error occurred.\n     * @param {Error=} errorObj The actual Error object.\n     * @memberof report\n     */\n    function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {\n        var stack;\n        if (lastExceptionStack) {\n            computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, \"\" + message);\n            processLastException();\n        }\n        else if (errorObj) {\n            stack = computeStackTrace(errorObj);\n            notifyHandlers(stack, true, errorObj);\n        }\n        else {\n            var location_1 = {\n                url: url,\n                column: columnNo,\n                line: lineNo,\n            };\n            var name_1;\n            var msg = message;\n            if ({}.toString.call(message) === '[object String]') {\n                var groups = msg.match(ERROR_TYPES_RE);\n                if (groups) {\n                    name_1 = groups[1];\n                    msg = groups[2];\n                }\n            }\n            stack = {\n                name: name_1,\n                message: msg,\n                stack: [location_1],\n            };\n            notifyHandlers(stack, true);\n        }\n        if (oldOnerrorHandler) {\n            return oldOnerrorHandler.apply(this, arguments);\n        }\n        return false;\n    }\n    /**\n     * Ensures all unhandled rejections are recorded.\n     * @param {PromiseRejectionEvent} e event.\n     * @memberof report\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n     */\n    function traceKitWindowOnUnhandledRejection(e) {\n        var reason = e.reason || 'Empty reason';\n        var stack = computeStackTrace(reason);\n        notifyHandlers(stack, true, reason);\n    }\n    /**\n     * Install a global onerror handler\n     * @memberof report\n     */\n    function installGlobalHandler() {\n        if (onErrorHandlerInstalled) {\n            return;\n        }\n        oldOnerrorHandler = window.onerror;\n        window.onerror = monitor(traceKitWindowOnError);\n        onErrorHandlerInstalled = true;\n    }\n    /**\n     * Uninstall the global onerror handler\n     * @memberof report\n     */\n    function uninstallGlobalHandler() {\n        if (onErrorHandlerInstalled) {\n            window.onerror = oldOnerrorHandler;\n            onErrorHandlerInstalled = false;\n        }\n    }\n    /**\n     * Install a global onunhandledrejection handler\n     * @memberof report\n     */\n    function installGlobalUnhandledRejectionHandler() {\n        if (onUnhandledRejectionHandlerInstalled) {\n            return;\n        }\n        oldOnunhandledrejectionHandler = window.onunhandledrejection !== null ? window.onunhandledrejection : undefined;\n        window.onunhandledrejection = monitor(traceKitWindowOnUnhandledRejection);\n        onUnhandledRejectionHandlerInstalled = true;\n    }\n    /**\n     * Uninstall the global onunhandledrejection handler\n     * @memberof report\n     */\n    function uninstallGlobalUnhandledRejectionHandler() {\n        if (onUnhandledRejectionHandlerInstalled) {\n            window.onunhandledrejection = oldOnunhandledrejectionHandler;\n            onUnhandledRejectionHandlerInstalled = false;\n        }\n    }\n    /**\n     * Process the most recent exception\n     * @memberof report\n     */\n    function processLastException() {\n        var currentLastExceptionStack = lastExceptionStack;\n        var currentLastException = lastException;\n        lastExceptionStack = undefined;\n        lastException = undefined;\n        notifyHandlers(currentLastExceptionStack, false, currentLastException);\n    }\n    /**\n     * Reports an unhandled Error.\n     * @param {Error} ex\n     * @memberof report\n     * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n     */\n    function doReport(ex) {\n        if (lastExceptionStack) {\n            if (lastException === ex) {\n                return; // already caught by an inner catch block, ignore\n            }\n            processLastException();\n        }\n        var stack = computeStackTrace(ex);\n        lastExceptionStack = stack;\n        lastException = ex;\n        // If the stack trace is incomplete, wait for 2 seconds for\n        // slow slow IE to see if onerror occurs or not before reporting\n        // this exception; otherwise, we will end up with an incomplete\n        // stack trace\n        setTimeout(function () {\n            if (lastException === ex) {\n                processLastException();\n            }\n        }, stack.incomplete ? 2000 : 0);\n        throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n    doReport.subscribe = subscribe;\n    doReport.unsubscribe = unsubscribe;\n    doReport.traceKitWindowOnError = traceKitWindowOnError;\n    return doReport;\n})();\n/**\n * computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = computeStackTrace.ofCaller([depth])\n *   s = computeStackTrace(exception) // consider using report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with report,\n * which builds on top of computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         let stackInfo = computeStackTrace.ofCaller();\n *         let data = message + \"\\n\";\n *         for(let i in stackInfo.stack) {\n *             let item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\nexport var computeStackTrace = (function computeStackTraceWrapper() {\n    var debug = false;\n    // Contents of Exception in various browsers.\n    //\n    // SAFARI:\n    // ex.message = Can't find variable: qq\n    // ex.line = 59\n    // ex.sourceId = 580238192\n    // ex.sourceURL = http://...\n    // ex.expressionBeginOffset = 96\n    // ex.expressionCaretOffset = 98\n    // ex.expressionEndOffset = 98\n    // ex.name = ReferenceError\n    //\n    // FIREFOX:\n    // ex.message = qq is not defined\n    // ex.fileName = http://...\n    // ex.lineNumber = 59\n    // ex.columnNumber = 69\n    // ex.stack = ...stack trace... (see the example below)\n    // ex.name = ReferenceError\n    //\n    // CHROME:\n    // ex.message = qq is not defined\n    // ex.name = ReferenceError\n    // ex.type = not_defined\n    // ex.arguments = ['aa']\n    // ex.stack = ...stack trace...\n    //\n    // INTERNET EXPLORER:\n    // ex.message = ...\n    // ex.name = ReferenceError\n    //\n    // OPERA:\n    // ex.message = ...message... (see the example below)\n    // ex.name = ReferenceError\n    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n    /**\n     * Computes stack trace information from the stack property.\n     * Chrome and Gecko use this property.\n     * @param {Error} ex\n     * @return {?StackTrace} Stack trace information.\n     * @memberof computeStackTrace\n     */\n    function computeStackTraceFromStackProp(ex) {\n        if (!ex.stack) {\n            return;\n        }\n        // tslint:disable-next-line max-line-length\n        var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n        // tslint:disable-next-line max-line-length\n        var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n        // tslint:disable-next-line max-line-length\n        var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n        // Used to additionally parse URL/line/column from eval frames\n        var isEval;\n        var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n        var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n        var lines = ex.stack.split('\\n');\n        var stack = [];\n        var submatch;\n        var parts;\n        var element;\n        for (var i = 0, j = lines.length; i < j; i += 1) {\n            if (chrome.exec(lines[i])) {\n                parts = chrome.exec(lines[i]);\n                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n                submatch = chromeEval.exec(parts[2]);\n                if (isEval && submatch) {\n                    // throw out eval line/column and use top-most line/column number\n                    parts[2] = submatch[1]; // url\n                    parts[3] = submatch[2]; // line\n                    parts[4] = submatch[3]; // column\n                }\n                element = {\n                    args: isNative ? [parts[2]] : [],\n                    column: parts[4] ? +parts[4] : undefined,\n                    func: parts[1] || UNKNOWN_FUNCTION,\n                    line: parts[3] ? +parts[3] : undefined,\n                    url: !isNative ? parts[2] : undefined,\n                };\n            }\n            else if (winjs.exec(lines[i])) {\n                parts = winjs.exec(lines[i]);\n                element = {\n                    args: [],\n                    column: parts[4] ? +parts[4] : undefined,\n                    func: parts[1] || UNKNOWN_FUNCTION,\n                    line: +parts[3],\n                    url: parts[2],\n                };\n            }\n            else if (gecko.exec(lines[i])) {\n                parts = gecko.exec(lines[i]);\n                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n                submatch = geckoEval.exec(parts[3]);\n                if (isEval && submatch) {\n                    // throw out eval line/column and use top-most line number\n                    parts[3] = submatch[1];\n                    parts[4] = submatch[2];\n                    parts[5] = undefined; // no column when eval\n                }\n                else if (i === 0 && !parts[5] && !isUndefined(ex.columnNumber)) {\n                    // FireFox uses this awesome columnNumber property for its top frame\n                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n                    // so adding 1\n                    // NOTE: this hack doesn't work if top-most frame is eval\n                    stack[0].column = ex.columnNumber + 1;\n                }\n                element = {\n                    args: parts[2] ? parts[2].split(',') : [],\n                    column: parts[5] ? +parts[5] : undefined,\n                    func: parts[1] || UNKNOWN_FUNCTION,\n                    line: parts[4] ? +parts[4] : undefined,\n                    url: parts[3],\n                };\n            }\n            else {\n                continue;\n            }\n            if (!element.func && element.line) {\n                element.func = UNKNOWN_FUNCTION;\n            }\n            stack.push(element);\n        }\n        if (!stack.length) {\n            return;\n        }\n        return {\n            stack: stack,\n            message: ex.message,\n            name: ex.name,\n        };\n    }\n    /**\n     * Computes stack trace information from the stacktrace property.\n     * Opera 10+ uses this property.\n     * @param {Error} ex\n     * @return {?StackTrace} Stack trace information.\n     * @memberof computeStackTrace\n     */\n    function computeStackTraceFromStacktraceProp(ex) {\n        // Access and store the stacktrace property before doing ANYTHING\n        // else to it because Opera is not very good at providing it\n        // reliably in other circumstances.\n        var stacktrace = ex.stacktrace;\n        if (!stacktrace) {\n            return;\n        }\n        var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n        // tslint:disable-next-line max-line-length\n        var opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i;\n        var lines = stacktrace.split('\\n');\n        var stack = [];\n        var parts;\n        for (var line = 0; line < lines.length; line += 2) {\n            var element = void 0;\n            if (opera10Regex.exec(lines[line])) {\n                parts = opera10Regex.exec(lines[line]);\n                element = {\n                    args: [],\n                    column: undefined,\n                    func: parts[3],\n                    line: +parts[1],\n                    url: parts[2],\n                };\n            }\n            else if (opera11Regex.exec(lines[line])) {\n                parts = opera11Regex.exec(lines[line]);\n                element = {\n                    args: parts[5] ? parts[5].split(',') : [],\n                    column: +parts[2],\n                    func: parts[3] || parts[4],\n                    line: +parts[1],\n                    url: parts[6],\n                };\n            }\n            if (element) {\n                if (!element.func && element.line) {\n                    element.func = UNKNOWN_FUNCTION;\n                }\n                element.context = [lines[line + 1]];\n                stack.push(element);\n            }\n        }\n        if (!stack.length) {\n            return;\n        }\n        return {\n            stack: stack,\n            message: ex.message,\n            name: ex.name,\n        };\n    }\n    /**\n     * NOT TESTED.\n     * Computes stack trace information from an error message that includes\n     * the stack trace.\n     * Opera 9 and earlier use this method if the option to show stack\n     * traces is turned on in opera:config.\n     * @param {Error} ex\n     * @return {?StackTrace} Stack information.\n     * @memberof computeStackTrace\n     */\n    function computeStackTraceFromOperaMultiLineMessage(ex) {\n        // TODO: Clean this function up\n        // Opera includes a stack trace into the exception message. An example is:\n        //\n        // Statement on line 3: Undefined variable: undefinedFunc\n        // Backtrace:\n        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js:\n        //   In function zzz\n        //         undefinedFunc(a);\n        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n        //   In function yyy\n        //           zzz(x, y, z);\n        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n        //   In function xxx\n        //           yyy(a, a, a);\n        //   Line 1 of function script\n        //     try { xxx('hi'); return false; } catch(ex) { report(ex); }\n        //   ...\n        var lines = ex.message.split('\\n');\n        if (lines.length < 4) {\n            return;\n        }\n        var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n        var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n        var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i;\n        var stack = [];\n        var scripts = window && window.document && window.document.getElementsByTagName('script');\n        var inlineScriptBlocks = [];\n        var parts;\n        for (var s in scripts) {\n            if (has(scripts, s) && !scripts[s].src) {\n                inlineScriptBlocks.push(scripts[s]);\n            }\n        }\n        for (var line = 2; line < lines.length; line += 2) {\n            var item = void 0;\n            if (lineRE1.exec(lines[line])) {\n                parts = lineRE1.exec(lines[line]);\n                item = {\n                    args: [],\n                    column: undefined,\n                    func: parts[3],\n                    line: +parts[1],\n                    url: parts[2],\n                };\n            }\n            else if (lineRE2.exec(lines[line])) {\n                parts = lineRE2.exec(lines[line]);\n                item = {\n                    args: [],\n                    column: undefined,\n                    func: parts[4],\n                    line: +parts[1],\n                    url: parts[3],\n                };\n            }\n            else if (lineRE3.exec(lines[line])) {\n                parts = lineRE3.exec(lines[line]);\n                var url = window.location.href.replace(/#.*$/, '');\n                item = {\n                    url: url,\n                    args: [],\n                    column: undefined,\n                    func: '',\n                    line: +parts[1],\n                };\n            }\n            if (item) {\n                if (!item.func) {\n                    item.func = UNKNOWN_FUNCTION;\n                }\n                item.context = [lines[line + 1]];\n                stack.push(item);\n            }\n        }\n        if (!stack.length) {\n            return; // could not parse multiline exception message as Opera stack trace\n        }\n        return {\n            stack: stack,\n            message: lines[0],\n            name: ex.name,\n        };\n    }\n    /**\n     * Adds information about the first frame to incomplete stack traces.\n     * Safari and IE require this to get complete data on the first frame.\n     * @param {StackTrace} stackInfo Stack trace information from\n     * one of the compute* methods.\n     * @param {string=} url The URL of the script that caused an error.\n     * @param {(number|string)=} lineNo The line number of the script that\n     * caused an error.\n     * @param {string=} message The error generated by the browser, which\n     * hopefully contains the name of the object that caused the error.\n     * @return {boolean} Whether or not the stack information was\n     * augmented.\n     * @memberof computeStackTrace\n     */\n    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n        var initial = {\n            url: url,\n            line: lineNo ? +lineNo : undefined,\n        };\n        if (initial.url && initial.line) {\n            stackInfo.incomplete = false;\n            var stack = stackInfo.stack;\n            if (stack.length > 0) {\n                if (stack[0].url === initial.url) {\n                    if (stack[0].line === initial.line) {\n                        return false; // already in stack trace\n                    }\n                    if (!stack[0].line && stack[0].func === initial.func) {\n                        stack[0].line = initial.line;\n                        stack[0].context = initial.context;\n                        return false;\n                    }\n                }\n            }\n            stack.unshift(initial);\n            stackInfo.partial = true;\n            return true;\n        }\n        stackInfo.incomplete = true;\n        return false;\n    }\n    /**\n     * Computes stack trace information by walking the arguments.caller\n     * chain at the time the exception occurred. This will cause earlier\n     * frames to be missed but is the only way to get any stack trace in\n     * Safari and IE. The top frame is restored by\n     * {@link augmentStackTraceWithInitialElement}.\n     * @param {Error} ex\n     * @param {number} depth\n     * @return {StackTrace} Stack trace information.\n     * @memberof computeStackTrace\n     */\n    function computeStackTraceByWalkingCallerChain(ex, depth) {\n        var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n        var stack = [];\n        var funcs = {};\n        var recursion = false;\n        var parts;\n        var item;\n        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n            if (curr === computeStackTrace || curr === report) {\n                continue;\n            }\n            item = {\n                args: [],\n                column: undefined,\n                func: UNKNOWN_FUNCTION,\n                line: undefined,\n                url: undefined,\n            };\n            parts = functionName.exec(curr.toString());\n            if (curr.name) {\n                item.func = curr.name;\n            }\n            else if (parts) {\n                item.func = parts[1];\n            }\n            if (typeof item.func === 'undefined') {\n                item.func = parts ? parts.input.substring(0, parts.input.indexOf('{')) : undefined;\n            }\n            if (funcs[\"\" + curr]) {\n                recursion = true;\n            }\n            else {\n                funcs[\"\" + curr] = true;\n            }\n            stack.push(item);\n        }\n        if (depth) {\n            stack.splice(0, depth);\n        }\n        var result = {\n            stack: stack,\n            message: ex.message,\n            name: ex.name,\n        };\n        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n        return result;\n    }\n    /**\n     * Computes a stack trace for an exception.\n     * @param {Error} ex\n     * @param {(string|number)=} depth\n     * @memberof computeStackTrace\n     */\n    function doComputeStackTrace(ex, depth) {\n        var stack;\n        var normalizedDepth = depth === undefined ? 0 : +depth;\n        try {\n            // This must be tried first because Opera 10 *destroys*\n            // its stacktrace property if you try to access the stack\n            // property first!!\n            stack = computeStackTraceFromStacktraceProp(ex);\n            if (stack) {\n                return stack;\n            }\n        }\n        catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n        try {\n            stack = computeStackTraceFromStackProp(ex);\n            if (stack) {\n                return stack;\n            }\n        }\n        catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n        try {\n            stack = computeStackTraceFromOperaMultiLineMessage(ex);\n            if (stack) {\n                return stack;\n            }\n        }\n        catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n        try {\n            stack = computeStackTraceByWalkingCallerChain(ex, normalizedDepth + 1);\n            if (stack) {\n                return stack;\n            }\n        }\n        catch (e) {\n            if (debug) {\n                throw e;\n            }\n        }\n        return {\n            message: ex.message,\n            name: ex.name,\n            stack: [],\n        };\n    }\n    /**\n     * Logs a stacktrace starting from the previous call and working down.\n     * @param {(number|string)=} depth How many frames deep to trace.\n     * @return {StackTrace} Stack trace information.\n     * @memberof computeStackTrace\n     */\n    function computeStackTraceOfCaller(depth) {\n        var currentDepth = (depth === undefined ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n        try {\n            throw new Error();\n        }\n        catch (ex) {\n            return computeStackTrace(ex, currentDepth + 1);\n        }\n    }\n    doComputeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n    doComputeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n    doComputeStackTrace.ofCaller = computeStackTraceOfCaller;\n    return doComputeStackTrace;\n})();\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof TraceKit\n */\nexport function extendToAsynchronousCallbacks() {\n    function helper(fnName) {\n        var originalFn = window[fnName];\n        window[fnName] = function traceKitAsyncExtension() {\n            // Make a copy of the arguments\n            var args = [].slice.call(arguments);\n            var originalCallback = args[0];\n            if (typeof originalCallback === 'function') {\n                args[0] = wrap(originalCallback);\n            }\n            // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n            // also only supports 2 argument and doesn't care what \"this\" is, so we\n            // can just call the original function directly.\n            if (originalFn.apply) {\n                return originalFn.apply(this, args);\n            }\n            return originalFn(args[0], args[1]);\n        };\n    }\n    helper('setTimeout');\n    helper('setInterval');\n}\n//# sourceMappingURL=tracekit.js.map"]},"metadata":{},"sourceType":"module"}