{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { toStackTraceString } from './errorCollection';\nimport { computeStackTrace } from './tracekit';\nimport { Batch, HttpRequest } from './transport';\nimport * as utils from './utils';\nvar StatusType;\n\n(function (StatusType) {\n  StatusType[\"info\"] = \"info\";\n  StatusType[\"error\"] = \"error\";\n})(StatusType || (StatusType = {}));\n\nvar monitoringConfiguration = {\n  maxMessagesPerPage: 0,\n  sentMessageCount: 0\n};\nvar externalContextProvider;\nexport function startInternalMonitoring(configuration) {\n  if (configuration.internalMonitoringEndpoint) {\n    var batch = new Batch(new HttpRequest(configuration.internalMonitoringEndpoint, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, function () {\n      return utils.deepMerge({\n        date: new Date().getTime(),\n        view: {\n          referrer: document.referrer,\n          url: window.location.href\n        }\n      }, externalContextProvider !== undefined ? externalContextProvider() : {});\n    });\n    utils.assign(monitoringConfiguration, {\n      batch: batch,\n      maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,\n      sentMessageCount: 0\n    });\n  }\n\n  return {\n    setExternalContextProvider: function (provider) {\n      externalContextProvider = provider;\n    }\n  };\n}\nexport function resetInternalMonitoring() {\n  monitoringConfiguration.batch = undefined;\n}\nexport function monitored(_, __, descriptor) {\n  var originalMethod = descriptor.value;\n\n  descriptor.value = function () {\n    var decorated = monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod;\n    return decorated.apply(this, arguments);\n  };\n}\nexport function monitor(fn) {\n  return function () {\n    try {\n      return fn.apply(this, arguments);\n    } catch (e) {\n      logErrorIfDebug(e);\n\n      try {\n        addErrorToMonitoringBatch(e);\n      } catch (e) {\n        logErrorIfDebug(e);\n      }\n    }\n  }; // consider output type has input type\n}\nexport function addMonitoringMessage(message) {\n  logMessageIfDebug(message);\n  addToMonitoringBatch({\n    message: message,\n    status: StatusType.info\n  });\n}\n\nfunction addErrorToMonitoringBatch(e) {\n  addToMonitoringBatch(__assign(__assign({}, formatError(e)), {\n    status: StatusType.error\n  }));\n}\n\nfunction addToMonitoringBatch(message) {\n  if (monitoringConfiguration.batch && monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {\n    monitoringConfiguration.sentMessageCount += 1;\n    monitoringConfiguration.batch.add(message);\n  }\n}\n\nfunction formatError(e) {\n  if (e instanceof Error) {\n    var stackTrace = computeStackTrace(e);\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(stackTrace)\n      },\n      message: stackTrace.message\n    };\n  }\n\n  return {\n    error: {\n      stack: 'Not an instance of error'\n    },\n    message: \"Uncaught \" + utils.jsonStringify(e)\n  };\n}\n\nexport function setDebugMode(debugMode) {\n  monitoringConfiguration.debugMode = debugMode;\n}\n\nfunction logErrorIfDebug(e) {\n  if (monitoringConfiguration.debugMode) {\n    // Log as warn to not forward the logs.\n    console.warn('[INTERNAL ERROR]', e);\n  }\n}\n\nfunction logMessageIfDebug(message) {\n  if (monitoringConfiguration.debugMode) {\n    console.log('[MONITORING MESSAGE]', message);\n  }\n}","map":{"version":3,"sources":["../src/internalMonitoring.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { toStackTraceString } from './errorCollection';\nimport { computeStackTrace } from './tracekit';\nimport { Batch, HttpRequest } from './transport';\nimport * as utils from './utils';\nvar StatusType;\n(function (StatusType) {\n    StatusType[\"info\"] = \"info\";\n    StatusType[\"error\"] = \"error\";\n})(StatusType || (StatusType = {}));\nvar monitoringConfiguration = { maxMessagesPerPage: 0, sentMessageCount: 0 };\nvar externalContextProvider;\nexport function startInternalMonitoring(configuration) {\n    if (configuration.internalMonitoringEndpoint) {\n        var batch = new Batch(new HttpRequest(configuration.internalMonitoringEndpoint, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, function () {\n            return utils.deepMerge({\n                date: new Date().getTime(),\n                view: {\n                    referrer: document.referrer,\n                    url: window.location.href,\n                },\n            }, externalContextProvider !== undefined ? externalContextProvider() : {});\n        });\n        utils.assign(monitoringConfiguration, {\n            batch: batch,\n            maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,\n            sentMessageCount: 0,\n        });\n    }\n    return {\n        setExternalContextProvider: function (provider) {\n            externalContextProvider = provider;\n        },\n    };\n}\nexport function resetInternalMonitoring() {\n    monitoringConfiguration.batch = undefined;\n}\nexport function monitored(_, __, descriptor) {\n    var originalMethod = descriptor.value;\n    descriptor.value = function () {\n        var decorated = (monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod);\n        return decorated.apply(this, arguments);\n    };\n}\nexport function monitor(fn) {\n    return function () {\n        try {\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            logErrorIfDebug(e);\n            try {\n                addErrorToMonitoringBatch(e);\n            }\n            catch (e) {\n                logErrorIfDebug(e);\n            }\n        }\n    }; // consider output type has input type\n}\nexport function addMonitoringMessage(message) {\n    logMessageIfDebug(message);\n    addToMonitoringBatch({\n        message: message,\n        status: StatusType.info,\n    });\n}\nfunction addErrorToMonitoringBatch(e) {\n    addToMonitoringBatch(__assign(__assign({}, formatError(e)), { status: StatusType.error }));\n}\nfunction addToMonitoringBatch(message) {\n    if (monitoringConfiguration.batch &&\n        monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {\n        monitoringConfiguration.sentMessageCount += 1;\n        monitoringConfiguration.batch.add(message);\n    }\n}\nfunction formatError(e) {\n    if (e instanceof Error) {\n        var stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(stackTrace),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: 'Not an instance of error',\n        },\n        message: \"Uncaught \" + utils.jsonStringify(e),\n    };\n}\nexport function setDebugMode(debugMode) {\n    monitoringConfiguration.debugMode = debugMode;\n}\nfunction logErrorIfDebug(e) {\n    if (monitoringConfiguration.debugMode) {\n        // Log as warn to not forward the logs.\n        console.warn('[INTERNAL ERROR]', e);\n    }\n}\nfunction logMessageIfDebug(message) {\n    if (monitoringConfiguration.debugMode) {\n        console.log('[MONITORING MESSAGE]', message);\n    }\n}\n//# sourceMappingURL=internalMonitoring.js.map"]},"metadata":{},"sourceType":"module"}