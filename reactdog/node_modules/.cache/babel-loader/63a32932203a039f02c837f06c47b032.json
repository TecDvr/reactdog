{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { monitor } from './internalMonitoring';\nimport { deepMerge, DOM_EVENT, jsonStringify, noop, objectValues } from './utils';\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nvar HttpRequest =\n/** @class */\nfunction () {\n  function HttpRequest(endpointUrl, bytesLimit, withBatchTime) {\n    if (withBatchTime === void 0) {\n      withBatchTime = false;\n    }\n\n    this.endpointUrl = endpointUrl;\n    this.bytesLimit = bytesLimit;\n    this.withBatchTime = withBatchTime;\n  }\n\n  HttpRequest.prototype.send = function (data, size) {\n    var url = this.withBatchTime ? addBatchTime(this.endpointUrl) : this.endpointUrl;\n\n    if (navigator.sendBeacon && size < this.bytesLimit) {\n      var isQueued = navigator.sendBeacon(url, data);\n\n      if (isQueued) {\n        return;\n      }\n    }\n\n    var request = new XMLHttpRequest();\n    request.open('POST', url, true);\n    request.send(data);\n  };\n\n  return HttpRequest;\n}();\n\nexport { HttpRequest };\n\nfunction addBatchTime(url) {\n  return \"\" + url + (url.indexOf('?') === -1 ? '?' : '&') + \"batch_time=\" + new Date().getTime();\n}\n\nvar Batch =\n/** @class */\nfunction () {\n  function Batch(request, maxSize, bytesLimit, maxMessageSize, flushTimeout, contextProvider, beforeUnloadCallback) {\n    if (beforeUnloadCallback === void 0) {\n      beforeUnloadCallback = noop;\n    }\n\n    this.request = request;\n    this.maxSize = maxSize;\n    this.bytesLimit = bytesLimit;\n    this.maxMessageSize = maxMessageSize;\n    this.flushTimeout = flushTimeout;\n    this.contextProvider = contextProvider;\n    this.beforeUnloadCallback = beforeUnloadCallback;\n    this.pushOnlyBuffer = [];\n    this.upsertBuffer = {};\n    this.bufferBytesSize = 0;\n    this.bufferMessageCount = 0;\n    this.flushOnVisibilityHidden();\n    this.flushPeriodically();\n  }\n\n  Batch.prototype.add = function (message) {\n    this.addOrUpdate(message);\n  };\n\n  Batch.prototype.upsert = function (message, key) {\n    this.addOrUpdate(message, key);\n  };\n\n  Batch.prototype.flush = function () {\n    if (this.bufferMessageCount !== 0) {\n      var messages = __spreadArrays(this.pushOnlyBuffer, objectValues(this.upsertBuffer));\n\n      this.request.send(messages.join('\\n'), this.bufferBytesSize);\n      this.pushOnlyBuffer = [];\n      this.upsertBuffer = {};\n      this.bufferBytesSize = 0;\n      this.bufferMessageCount = 0;\n    }\n  };\n\n  Batch.prototype.addOrUpdate = function (message, key) {\n    var _a = this.process(message),\n        processedMessage = _a.processedMessage,\n        messageBytesSize = _a.messageBytesSize;\n\n    if (messageBytesSize >= this.maxMessageSize) {\n      console.warn(\"Discarded a message whose size was bigger than the maximum allowed size \" + this.maxMessageSize + \"KB.\");\n      return;\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key);\n    }\n\n    if (this.willReachedBytesLimitWith(messageBytesSize)) {\n      this.flush();\n    }\n\n    this.push(processedMessage, messageBytesSize, key);\n\n    if (this.isFull()) {\n      this.flush();\n    }\n  };\n\n  Batch.prototype.process = function (message) {\n    var contextualizedMessage = deepMerge({}, this.contextProvider(), message);\n    var processedMessage = jsonStringify(contextualizedMessage);\n    var messageBytesSize = this.sizeInBytes(processedMessage);\n    return {\n      processedMessage: processedMessage,\n      messageBytesSize: messageBytesSize\n    };\n  };\n\n  Batch.prototype.push = function (processedMessage, messageBytesSize, key) {\n    if (this.bufferMessageCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesSize += 1;\n    }\n\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage;\n    } else {\n      this.pushOnlyBuffer.push(processedMessage);\n    }\n\n    this.bufferBytesSize += messageBytesSize;\n    this.bufferMessageCount += 1;\n  };\n\n  Batch.prototype.remove = function (key) {\n    var removedMessage = this.upsertBuffer[key];\n    delete this.upsertBuffer[key];\n    var messageBytesSize = this.sizeInBytes(removedMessage);\n    this.bufferBytesSize -= messageBytesSize;\n    this.bufferMessageCount -= 1;\n\n    if (this.bufferMessageCount > 0) {\n      this.bufferBytesSize -= 1;\n    }\n  };\n\n  Batch.prototype.hasMessageFor = function (key) {\n    return key !== undefined && this.upsertBuffer[key] !== undefined;\n  };\n\n  Batch.prototype.willReachedBytesLimitWith = function (messageBytesSize) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesSize + messageBytesSize + 1 >= this.bytesLimit;\n  };\n\n  Batch.prototype.isFull = function () {\n    return this.bufferMessageCount === this.maxSize || this.bufferBytesSize >= this.bytesLimit;\n  };\n\n  Batch.prototype.sizeInBytes = function (candidate) {\n    // tslint:disable-next-line no-bitwise\n    return ~-encodeURI(candidate).split(/%..|./).length;\n  };\n\n  Batch.prototype.flushPeriodically = function () {\n    var _this = this;\n\n    setTimeout(function () {\n      _this.flush();\n\n      _this.flushPeriodically();\n    }, this.flushTimeout);\n  };\n\n  Batch.prototype.flushOnVisibilityHidden = function () {\n    var _this = this;\n    /**\n     * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n     */\n    // @ts-ignore this function is not always defined\n\n\n    if (navigator.sendBeacon) {\n      /**\n       * beforeunload is called before visibilitychange\n       * register first to be sure to be called before flush on beforeunload\n       * caveat: unload can still be canceled by another listener\n       */\n      window.addEventListener(DOM_EVENT.BEFORE_UNLOAD, monitor(this.beforeUnloadCallback));\n      /**\n       * Only event that guarantee to fire on mobile devices when the page transitions to background state\n       * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n       */\n\n      document.addEventListener(DOM_EVENT.VISIBILITY_CHANGE, monitor(function () {\n        if (document.visibilityState === 'hidden') {\n          _this.flush();\n        }\n      }));\n      /**\n       * Safari does not support yet to send a request during:\n       * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n       * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n       */\n\n      window.addEventListener(DOM_EVENT.BEFORE_UNLOAD, monitor(function () {\n        return _this.flush();\n      }));\n    }\n  };\n\n  return Batch;\n}();\n\nexport { Batch };","map":{"version":3,"sources":["../src/transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport { monitor } from './internalMonitoring';\nimport { deepMerge, DOM_EVENT, jsonStringify, noop, objectValues } from './utils';\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\nvar HttpRequest = /** @class */ (function () {\n    function HttpRequest(endpointUrl, bytesLimit, withBatchTime) {\n        if (withBatchTime === void 0) { withBatchTime = false; }\n        this.endpointUrl = endpointUrl;\n        this.bytesLimit = bytesLimit;\n        this.withBatchTime = withBatchTime;\n    }\n    HttpRequest.prototype.send = function (data, size) {\n        var url = this.withBatchTime ? addBatchTime(this.endpointUrl) : this.endpointUrl;\n        if (navigator.sendBeacon && size < this.bytesLimit) {\n            var isQueued = navigator.sendBeacon(url, data);\n            if (isQueued) {\n                return;\n            }\n        }\n        var request = new XMLHttpRequest();\n        request.open('POST', url, true);\n        request.send(data);\n    };\n    return HttpRequest;\n}());\nexport { HttpRequest };\nfunction addBatchTime(url) {\n    return \"\" + url + (url.indexOf('?') === -1 ? '?' : '&') + \"batch_time=\" + new Date().getTime();\n}\nvar Batch = /** @class */ (function () {\n    function Batch(request, maxSize, bytesLimit, maxMessageSize, flushTimeout, contextProvider, beforeUnloadCallback) {\n        if (beforeUnloadCallback === void 0) { beforeUnloadCallback = noop; }\n        this.request = request;\n        this.maxSize = maxSize;\n        this.bytesLimit = bytesLimit;\n        this.maxMessageSize = maxMessageSize;\n        this.flushTimeout = flushTimeout;\n        this.contextProvider = contextProvider;\n        this.beforeUnloadCallback = beforeUnloadCallback;\n        this.pushOnlyBuffer = [];\n        this.upsertBuffer = {};\n        this.bufferBytesSize = 0;\n        this.bufferMessageCount = 0;\n        this.flushOnVisibilityHidden();\n        this.flushPeriodically();\n    }\n    Batch.prototype.add = function (message) {\n        this.addOrUpdate(message);\n    };\n    Batch.prototype.upsert = function (message, key) {\n        this.addOrUpdate(message, key);\n    };\n    Batch.prototype.flush = function () {\n        if (this.bufferMessageCount !== 0) {\n            var messages = __spreadArrays(this.pushOnlyBuffer, objectValues(this.upsertBuffer));\n            this.request.send(messages.join('\\n'), this.bufferBytesSize);\n            this.pushOnlyBuffer = [];\n            this.upsertBuffer = {};\n            this.bufferBytesSize = 0;\n            this.bufferMessageCount = 0;\n        }\n    };\n    Batch.prototype.addOrUpdate = function (message, key) {\n        var _a = this.process(message), processedMessage = _a.processedMessage, messageBytesSize = _a.messageBytesSize;\n        if (messageBytesSize >= this.maxMessageSize) {\n            console.warn(\"Discarded a message whose size was bigger than the maximum allowed size \" + this.maxMessageSize + \"KB.\");\n            return;\n        }\n        if (this.hasMessageFor(key)) {\n            this.remove(key);\n        }\n        if (this.willReachedBytesLimitWith(messageBytesSize)) {\n            this.flush();\n        }\n        this.push(processedMessage, messageBytesSize, key);\n        if (this.isFull()) {\n            this.flush();\n        }\n    };\n    Batch.prototype.process = function (message) {\n        var contextualizedMessage = deepMerge({}, this.contextProvider(), message);\n        var processedMessage = jsonStringify(contextualizedMessage);\n        var messageBytesSize = this.sizeInBytes(processedMessage);\n        return { processedMessage: processedMessage, messageBytesSize: messageBytesSize };\n    };\n    Batch.prototype.push = function (processedMessage, messageBytesSize, key) {\n        if (this.bufferMessageCount > 0) {\n            // \\n separator at serialization\n            this.bufferBytesSize += 1;\n        }\n        if (key !== undefined) {\n            this.upsertBuffer[key] = processedMessage;\n        }\n        else {\n            this.pushOnlyBuffer.push(processedMessage);\n        }\n        this.bufferBytesSize += messageBytesSize;\n        this.bufferMessageCount += 1;\n    };\n    Batch.prototype.remove = function (key) {\n        var removedMessage = this.upsertBuffer[key];\n        delete this.upsertBuffer[key];\n        var messageBytesSize = this.sizeInBytes(removedMessage);\n        this.bufferBytesSize -= messageBytesSize;\n        this.bufferMessageCount -= 1;\n        if (this.bufferMessageCount > 0) {\n            this.bufferBytesSize -= 1;\n        }\n    };\n    Batch.prototype.hasMessageFor = function (key) {\n        return key !== undefined && this.upsertBuffer[key] !== undefined;\n    };\n    Batch.prototype.willReachedBytesLimitWith = function (messageBytesSize) {\n        // byte of the separator at the end of the message\n        return this.bufferBytesSize + messageBytesSize + 1 >= this.bytesLimit;\n    };\n    Batch.prototype.isFull = function () {\n        return this.bufferMessageCount === this.maxSize || this.bufferBytesSize >= this.bytesLimit;\n    };\n    Batch.prototype.sizeInBytes = function (candidate) {\n        // tslint:disable-next-line no-bitwise\n        return ~-encodeURI(candidate).split(/%..|./).length;\n    };\n    Batch.prototype.flushPeriodically = function () {\n        var _this = this;\n        setTimeout(function () {\n            _this.flush();\n            _this.flushPeriodically();\n        }, this.flushTimeout);\n    };\n    Batch.prototype.flushOnVisibilityHidden = function () {\n        var _this = this;\n        /**\n         * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n         */\n        // @ts-ignore this function is not always defined\n        if (navigator.sendBeacon) {\n            /**\n             * beforeunload is called before visibilitychange\n             * register first to be sure to be called before flush on beforeunload\n             * caveat: unload can still be canceled by another listener\n             */\n            window.addEventListener(DOM_EVENT.BEFORE_UNLOAD, monitor(this.beforeUnloadCallback));\n            /**\n             * Only event that guarantee to fire on mobile devices when the page transitions to background state\n             * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n             */\n            document.addEventListener(DOM_EVENT.VISIBILITY_CHANGE, monitor(function () {\n                if (document.visibilityState === 'hidden') {\n                    _this.flush();\n                }\n            }));\n            /**\n             * Safari does not support yet to send a request during:\n             * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n             * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n             */\n            window.addEventListener(DOM_EVENT.BEFORE_UNLOAD, monitor(function () { return _this.flush(); }));\n        }\n    };\n    return Batch;\n}());\nexport { Batch };\n//# sourceMappingURL=transport.js.map"]},"metadata":{},"sourceType":"module"}