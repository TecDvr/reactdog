{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 8372b59d96ae75891b29","webpack:///./src/index.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/AbstractHistogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/EncodableHistogram.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/formatters.ts","webpack:///./src/ulp.ts","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/PackedHistogram.ts","webpack:///./src/packedarray/PackedArray.ts","webpack:///./src/packedarray/PackedArrayContext.ts","webpack:///./src/packedarray/ResizeError.ts","webpack:///./src/SparseArrayHistogram.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/encoding.ts","webpack:///./src/AbstractHistogram.encoding.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///external \"pako\"","webpack:///./~/base64-js/index.js","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Recorder.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC,IAAI;AACL;AACA,8BAA6B,0BAA0B;AACvD,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChFA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvEA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzFA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,SAAQ,6DAA6D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,sDAAqD,iCAAiC;AACtF,uCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,mFAAmF;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,YAAY,0CAA0C,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;;;;;;AC1vBA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzDA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClDA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACjGA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,8BAA6B,+CAA+C;AAC5E;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D,yBAAwB,mDAAmD;AAC3E;;;;;;;ACVA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzFA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzFA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzFA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,sBAAsB;AAC1B;AACA;AACA;AACA;AACA,KAAI,sBAAsB;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAA+G;AAC/G,4BAA2B,KAAK,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC3GA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,iBAAiB,GAAG,iBAAiB;AAC9F,KAAI,iBAAiB,MAAM,6BAA6B;AACxD;AACA,QAAO,sBAAsB,OAAO,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,oFAAoF;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpMA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,yCAAyC;AAChG;AACA,6EAA4E;AAC5E,yDAAwD,sBAAsB;AAC9E;AACA;AACA;AACA;AACA,oEAAmE,yBAAyB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,yBAAyB;AAChD,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA,iCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA,4FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,wBAAwB;AAChE;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D;AAC9D;AACA;AACA,uBAAsB;AACtB;AACA;AACA,kDAAiD,gCAAgC;AACjF;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA,0BAAyB;AACzB;AACA,+CAA8C,2BAA2B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAiE;AACjE;AACA,0EAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA,gCAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7eA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACfA;AACA;AACA;AACA;AACA,eAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,8BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAkG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,uBAAuB;AAClE,0CAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,yCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kCAAiC,0DAA0D,EAAE;AAC7F,+BAA8B,6DAA6D,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7JA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,4CAA4C;AACjF,qDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,kDAAiD;AACjD,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChMA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACjJA,iD;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACvJA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,2EAA2E;AACtH,0CAAyC,uEAAuE;AAChH,4CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA,0DAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,eAAe;AACnB,KAAI,2BAA2B;AAC/B,KAAI,+CAA+C;AACnD;AACA;AACA;AACA;AACA,oCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,iCAAgC,gBAAgB;AAChD,gCAA+B,sBAAsB,6BAA6B,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ,sCAAsC;AAC9C,SAAQ,mEAAmE;AAC3E,SAAQ,yBAAyB;AACjC;AACA,SAAQ;AACR,iDAAgD;AAChD,SAAQ,sCAAsC;AAC9C;AACA;AACA;AACA;AACA,iBAAgB;AAChB,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,yBAAwB,sBAAsB;AAC9C;AACA,iBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"hdrhistogram.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_25__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8372b59d96ae75891b29","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nexports.ByteBuffer = ByteBuffer_1.default;\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\nexports.Int8Histogram = Int8Histogram_1.default;\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\nexports.Int16Histogram = Int16Histogram_1.default;\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nexports.Int32Histogram = Int32Histogram_1.default;\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\nexports.Float64Histogram = Float64Histogram_1.default;\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\nexports.PackedHistogram = PackedHistogram_1.default;\nvar SparseArrayHistogram_1 = require(\"./SparseArrayHistogram\");\nexports.SparseArrayHistogram = SparseArrayHistogram_1.default;\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nexports.AbstractHistogram = AbstractHistogram_1.default;\nexports.Histogram = AbstractHistogram_1.default;\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\nexports.HistogramLogReader = HistogramLogReader_1.default;\nexports.listTags = HistogramLogReader_1.listTags;\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\nvar encoding_1 = require(\"./encoding\");\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\nvar Recorder_1 = require(\"./Recorder\");\nexports.Recorder = Recorder_1.default;\nvar defaultRequest = {\n    bitBucketSize: 32,\n    autoResize: true,\n    lowestDiscernibleValue: 1,\n    highestTrackableValue: 2,\n    numberOfSignificantValueDigits: 3\n};\nexports.defaultRequest = defaultRequest;\n/*const bigIntAvailable = (() => {\n  try {\n    eval(\"123n\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();*/\nvar build = function (request) {\n    if (request === void 0) { request = defaultRequest; }\n    var parameters = Object.assign({}, defaultRequest, request);\n    var histogramConstr;\n    switch (parameters.bitBucketSize) {\n        case 8:\n            histogramConstr = Int8Histogram_1.default;\n            break;\n        case 16:\n            histogramConstr = Int16Histogram_1.default;\n            break;\n        case 32:\n            histogramConstr = Int32Histogram_1.default;\n            break;\n        case \"sparse_array\":\n            histogramConstr = SparseArrayHistogram_1.default;\n            break;\n        case \"packed\":\n            histogramConstr = PackedHistogram_1.default;\n            break;\n        default:\n            //histogramConstr = bigIntAvailable ? BigIntHistogram : Float64Histogram;\n            histogramConstr = Float64Histogram_1.default;\n    }\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n    histogram.autoResize = parameters.autoResize;\n    return histogram;\n};\nexports.build = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_32 = pow(2, 32);\n/**\n * Mimic Java's ByteBufffer with big endian order\n */\nvar ByteBuffer = /** @class */ (function () {\n    function ByteBuffer(data) {\n        this.position = 0;\n        this.data = data;\n        this.int32ArrayForConvert = new Uint32Array(1);\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n    }\n    ByteBuffer.allocate = function (size) {\n        if (size === void 0) { size = 16; }\n        return new ByteBuffer(new Uint8Array(size));\n    };\n    ByteBuffer.prototype.put = function (value) {\n        if (this.position === this.data.length) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2);\n            this.data.set(oldArray);\n        }\n        this.data[this.position] = value;\n        this.position++;\n    };\n    ByteBuffer.prototype.putInt32 = function (value) {\n        if (this.data.length - this.position < 4) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2 + 4);\n            this.data.set(oldArray);\n        }\n        this.int32ArrayForConvert[0] = value;\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n        this.position += 4;\n    };\n    ByteBuffer.prototype.putInt64 = function (value) {\n        this.putInt32(floor(value / TWO_POW_32));\n        this.putInt32(value);\n    };\n    ByteBuffer.prototype.putArray = function (array) {\n        if (this.data.length - this.position < array.byteLength) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.position + array.byteLength);\n            this.data.set(oldArray);\n        }\n        this.data.set(array, this.position);\n        this.position += array.byteLength;\n    };\n    ByteBuffer.prototype.get = function () {\n        var value = this.data[this.position];\n        this.position++;\n        return value;\n    };\n    ByteBuffer.prototype.getInt32 = function () {\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n        var value = this.int32ArrayForConvert[0];\n        this.position += 4;\n        return value;\n    };\n    ByteBuffer.prototype.getInt64 = function () {\n        var high = this.getInt32();\n        var low = this.getInt32();\n        return high * TWO_POW_32 + low;\n    };\n    ByteBuffer.prototype.resetPosition = function () {\n        this.position = 0;\n    };\n    return ByteBuffer;\n}());\nexports.default = ByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int8Histogram = /** @class */ (function (_super) {\n    __extends(Int8Histogram, _super);\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint8Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int8Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint8Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int8Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int8Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int8Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int8Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int8Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int8Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\nvar formatters_1 = require(\"./formatters\");\nvar ulp_1 = require(\"./ulp\");\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\nvar AbstractHistogram = /** @class */ (function (_super) {\n    __extends(AbstractHistogram, _super);\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this) || this;\n        _this.maxValue = 0;\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n        // Verify argument validity\n        if (lowestDiscernibleValue < 1) {\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n        }\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue ( 2 * \" + lowestDiscernibleValue + \" )\");\n        }\n        if (numberOfSignificantValueDigits < 0 ||\n            numberOfSignificantValueDigits > 5) {\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n        }\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n        return _this;\n    }\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n        var internalValue = value + this.unitMagnitudeMask;\n        this.maxValue = internalValue;\n    };\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n        if (value <= this.unitMagnitudeMask) {\n            return;\n        }\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue = internalValue;\n    };\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue =\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\n                ? minNonZeroValue\n                : internalValue;\n    };\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\n        this.highestTrackableValue = highestTrackableValue;\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n        if (normalizingIndexOffset !== 0) {\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\n        }\n        /*\n         * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n         * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n         * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n         */\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n        this.subBucketHalfCountMagnitude =\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n        this.subBucketHalfCount = this.subBucketCount / 2;\n        this.subBucketMask =\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n        this.establishSize(highestTrackableValue);\n        this.leadingZeroCountBase =\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n    };\n    /**\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n     *\n     * <pre>\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n     * ...\n     * </pre>\n     *\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n     * values as it has better precision.\n     */\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n        // establish counts array length:\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n        // establish exponent range needed to support the trackable value with no overflow:\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n        // establish the new highest trackable value:\n        this.highestTrackableValue = newHighestTrackableValue;\n    };\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue (\" +\n                highestTrackableValue +\n                \") cannot be < (2 * lowestDiscernibleValue)\");\n        }\n        //determine counts array length needed:\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n        return countsArrayLength;\n    };\n    /**\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n     * value if we consider the sub-bucket length to be halved.\n     */\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n        return lengthNeeded;\n    };\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n        // always have at least 1 bucket\n        var bucketsNeeded = 1;\n        while (smallestUntrackableValue <= value) {\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n                // TODO check array max size in JavaScript\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n                return bucketsNeeded + 1;\n            }\n            smallestUntrackableValue = smallestUntrackableValue * 2;\n            bucketsNeeded++;\n        }\n        return bucketsNeeded;\n    };\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValue = function (value) {\n        this.recordSingleValue(value);\n    };\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(1, value);\n        }\n        else {\n            this.incrementCountAtIndex(countsIndex);\n        }\n        this.updateMinAndMax(value);\n        this.incrementTotalCount();\n    };\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n        if (!this.autoResize) {\n            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n        }\n        this.resize(value);\n        var countsIndex = this.countsArrayIndex(value);\n        this.addToCountAtIndex(countsIndex, count);\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n    };\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n        if (value < 0) {\n            throw new Error(\"Histogram recorded value cannot be negative.\");\n        }\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n    };\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n        // TODO\n        //assert(subBucketIndex < subBucketCount);\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n        // However, this works out since we give bucket 0 twice as much space.\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n        return bucketBaseIndex + offsetInBucket;\n    };\n    /**\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n     */\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n        // The mask maps small values to bucket 0.\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n        return max(floor(log2(value)) -\n            this.subBucketHalfCountMagnitude -\n            this.unitMagnitude, 0);\n    };\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n        // and therefore in the top half of subBucketCount.\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n    };\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n        if (value > this.maxValue) {\n            this.updatedMaxValue(value);\n        }\n        if (value < this.minNonZeroValue && value !== 0) {\n            this.updateMinNonZeroValue(value);\n        }\n    };\n    /**\n     * Get the value at a given percentile.\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n     * percentage of the overall recorded value entries in the histogram are either smaller than\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n     * entries in the histogram are either larger than or equivalent to.\n     * <p>\n     * Note that two values are \"equivalent\" in this statement if\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n     *\n     * @param percentile  The percentile for which to return the associated value\n     * @return The value that the given percentage of the overall recorded value entries in the\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n     * value that all value entries in the histogram are either larger than or equivalent to.\n     */\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n        // of overall recorded values is actually included. However, this must be done with care:\n        //\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n        // being 1 ulp larger than the correct integer count for this percentile:\n        var fpCountAtPercentile = (requestedPercentile / 100.0) * this.getTotalCount();\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n        // making us skip a count:\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n        1 // Make sure we at least reach the first recorded entry\n        );\n        var totalToCurrentIndex = 0;\n        for (var i = 0; i < this.countsArrayLength; i++) {\n            totalToCurrentIndex += this.getCountAtIndex(i);\n            if (totalToCurrentIndex >= countAtPercentile) {\n                var valueAtIndex = this.valueFromIndex(i);\n                return percentile === 0.0\n                    ? this.lowestEquivalentValue(valueAtIndex)\n                    : this.highestEquivalentValue(valueAtIndex);\n            }\n        }\n        return 0;\n    };\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n    };\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n        var subBucketIndex = (index % this.subBucketHalfCount) + this.subBucketHalfCount;\n        if (bucketIndex < 0) {\n            subBucketIndex -= this.subBucketHalfCount;\n            bucketIndex = 0;\n        }\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n    };\n    /**\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n        return thisValueBaseLevel;\n    };\n    /**\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n        return this.nextNonEquivalentValue(value) - 1;\n    };\n    /**\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n    };\n    /**\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The size of the range of values equivalent to the given value.\n     */\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var distanceToNextValue = pow(2, this.unitMagnitude +\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n        return distanceToNextValue;\n    };\n    /**\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n     */\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) +\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\n    };\n    /**\n     * Get the computed mean value of all recorded values in the histogram\n     *\n     * @return the mean value (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getMean = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        this.recordedValuesIterator.reset();\n        var totalValue = 0;\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            totalValue +=\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n                    iterationValue.countAtValueIteratedTo;\n        }\n        return (totalValue * 1.0) / this.getTotalCount();\n    };\n    /**\n     * Get the computed standard deviation of all recorded values in the histogram\n     *\n     * @return the standard deviation (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getStdDeviation = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        var mean = this.getMean();\n        var geometric_deviation_total = 0.0;\n        this.recordedValuesIterator.reset();\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n            geometric_deviation_total +=\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n        }\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n        return std_deviation;\n    };\n    /**\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n     *\n     * @param printStream    Stream into which the distribution will be output\n     * <p>\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n     * <p>\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n     *                                     output\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n     */\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\n        var result = \"\";\n        if (useCsvFormat) {\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n        }\n        else {\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n        }\n        var iterator = this.percentileIterator;\n        iterator.reset(percentileTicksPerHalfDistance);\n        var lineFormatter;\n        var lastLineFormatter;\n        if (useCsvFormat) {\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",\" +\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",Infinity\\n\";\n            };\n        }\n        else {\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \" \" +\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \"\\n\";\n            };\n        }\n        while (iterator.hasNext()) {\n            var iterationValue = iterator.next();\n            if (iterationValue.percentileLevelIteratedTo < 100) {\n                result += lineFormatter(iterationValue);\n            }\n            else {\n                result += lastLineFormatter(iterationValue);\n            }\n        }\n        if (!useCsvFormat) {\n            // Calculate and output mean and std. deviation.\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n            // response time distribution associated with GC pauses). However, reporting these numbers\n            // can be very useful for contrasting with the detailed percentile distribution\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\n            // percentile distributions where results fall many tens or even hundreds of standard\n            // deviations away from the mean - such results simply indicate that the data sampled\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\n            // deviation metric is a useless indicator.\n            //\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n            var intFormatter = formatters_1.integerFormatter(12);\n            var totalCount = intFormatter(this.getTotalCount());\n            var bucketCount = intFormatter(this.bucketCount);\n            var subBucketCount = intFormatter(this.subBucketCount);\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n        }\n        return result;\n    };\n    /**\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n     *\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n     */\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n        return this._getEstimatedFootprintInBytes();\n    };\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValue(value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordSingleValue(missingValue);\n        }\n    };\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(count, value);\n        }\n        else {\n            this.addToCountAtIndex(countsIndex, count);\n        }\n        this.updateMinAndMax(value);\n        this.addToTotalCount(count);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n        this.recordCountAtValue(count, value);\n    };\n    /**\n     * Record a value in the histogram.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n        this.recordCountAtValue(count, value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordCountAtValue(count, missingValue);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, the values added will include an auto-generated additional series of\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n     *\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * by\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n     */\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n        var toHistogram = this;\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n        while (otherValues.hasNext()) {\n            var v = otherValues.next();\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one.\n     * <p>\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\n     * extended to include the start/end timestamp range of the other histogram.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws (may throw) if values in fromHistogram's are\n     * higher than highestTrackableValue.\n     */\n    AbstractHistogram.prototype.add = function (otherHistogram) {\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            var observedOtherTotalCount = 0;\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, otherCount);\n                    observedOtherTotalCount += otherCount;\n                }\n            }\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n        }\n        else {\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n            // so we can't just stream through and add them. Instead, go through the array and add each\n            // non-zero value found at it's proper value:\n            // Do max value first, to avoid max value updates on each iteration:\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n            // Record the remaining values, up to but not including the max value:\n            for (var i = 0; i < otherMaxIndex; i++) {\n                otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n                }\n            }\n        }\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n    };\n    /**\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n     *\n     * @param value The value for which to provide the recorded count\n     * @return The total count of values recorded in the histogram within the value range that is\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n     */\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n        return this.getCountAtIndex(index);\n    };\n    /**\n     * Subtract the contents of another histogram from this one.\n     * <p>\n     * The start/end timestamps of this histogram will remain unchanged.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n     *\n     */\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // optim\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, -otherCount);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    var otherValue = otherHistogram.valueFromIndex(i);\n                    if (this.getCountAtValue(otherValue) < otherCount) {\n                        throw new Error(\"otherHistogram count (\" +\n                            otherCount +\n                            \") at value \" +\n                            otherValue +\n                            \" is larger than this one's (\" +\n                            this.getCountAtValue(otherValue) +\n                            \")\");\n                    }\n                    this.recordCountAtValue(-otherCount, otherValue);\n                }\n            }\n        }\n        // With subtraction, the max and minNonZero values could have changed:\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n            this.establishInternalTackingValues();\n        }\n    };\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_VALUE;\n        var maxIndex = -1;\n        var minNonZeroIndex = -1;\n        var observedTotalCount = 0;\n        for (var index = 0; index < lengthToCover; index++) {\n            var countAtIndex = this.getCountAtIndex(index);\n            if (countAtIndex > 0) {\n                observedTotalCount += countAtIndex;\n                maxIndex = index;\n                if (minNonZeroIndex == -1 && index != 0) {\n                    minNonZeroIndex = index;\n                }\n            }\n        }\n        if (maxIndex >= 0) {\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n        }\n        if (minNonZeroIndex >= 0) {\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n        }\n        this.setTotalCount(observedTotalCount);\n    };\n    AbstractHistogram.prototype.reset = function () {\n        this.clearCounts();\n        this.setTotalCount(0);\n        this.startTimeStampMsec = 0;\n        this.endTimeStampMsec = 0;\n        this.tag = AbstractHistogramBase_1.NO_TAG;\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n    };\n    return AbstractHistogram;\n}(AbstractHistogramBase_1.AbstractHistogramBase));\nexports.AbstractHistogram = AbstractHistogram;\nexports.default = AbstractHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\nexports.NO_TAG = \"NO TAG\";\nvar AbstractHistogramBase = /** @class */ (function (_super) {\n    __extends(AbstractHistogramBase, _super);\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n    //intermediateUncompressedByteArray : number[] = null;\n    /* useless ?\n    getIntegerToDoubleValueConversionRatio(): number {\n        return this.integerToDoubleValueConversionRatio;\n    }\n  \n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n    }*/\n    function AbstractHistogramBase() {\n        var _this = _super.call(this) || this;\n        _this.autoResize = false;\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n        _this.endTimeStampMsec = 0;\n        _this.tag = exports.NO_TAG;\n        _this.integerToDoubleValueConversionRatio = 1.0;\n        _this.identity = 0;\n        _this.highestTrackableValue = 0;\n        _this.lowestDiscernibleValue = 0;\n        _this.numberOfSignificantValueDigits = 0;\n        _this.bucketCount = 0;\n        _this.subBucketCount = 0;\n        _this.countsArrayLength = 0;\n        _this.wordSizeInBytes = 0;\n        return _this;\n    }\n    return AbstractHistogramBase;\n}(EncodableHistogram_1.EncodableHistogram));\nexports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodableHistogram = /** @class */ (function () {\n    function EncodableHistogram() {\n    }\n    return EncodableHistogram;\n}());\nexports.EncodableHistogram = EncodableHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\n/**\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n * all recorded histogram values are exhausted.\n */\nvar RecordedValuesIterator = /** @class */ (function (_super) {\n    __extends(RecordedValuesIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     */\n    function RecordedValuesIterator(histogram) {\n        var _this = _super.call(this) || this;\n        _this.doReset(histogram);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     */\n    RecordedValuesIterator.prototype.reset = function () {\n        this.doReset(this.histogram);\n    };\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.visitedIndex = -1;\n    };\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n        this.visitedIndex = this.currentIndex;\n    };\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n    };\n    return RecordedValuesIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = RecordedValuesIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\n/**\n * Used for iterating through histogram values.\n */\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n    function AbstractHistogramIterator() {\n        this.currentIterationValue = new HistogramIterationValue_1.default();\n    }\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n        this.histogram = histogram;\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n        this.arrayTotalCount = histogram.getTotalCount();\n        this.currentIndex = 0;\n        this.currentValueAtIndex = 0;\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n        this.prevValueIteratedTo = 0;\n        this.totalCountToPrevIndex = 0;\n        this.totalCountToCurrentIndex = 0;\n        this.totalValueToCurrentIndex = 0;\n        this.countAtThisValue = 0;\n        this.freshSubBucket = true;\n        this.currentIterationValue.reset();\n    };\n    /**\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n     * element rather than throwing an exception.)\n     *\n     * @return true if the iterator has more elements.\n     */\n    AbstractHistogramIterator.prototype.hasNext = function () {\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n            throw \"Concurrent Modification Exception\";\n        }\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n    };\n    /**\n     * Returns the next element in the iteration.\n     *\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n     */\n    AbstractHistogramIterator.prototype.next = function () {\n        // Move through the sub buckets and buckets until we hit the next reporting level:\n        while (!this.exhaustedSubBuckets()) {\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n            if (this.freshSubBucket) {\n                // Don't add unless we've incremented since last bucket...\n                this.totalCountToCurrentIndex += this.countAtThisValue;\n                this.totalValueToCurrentIndex +=\n                    this.countAtThisValue *\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n                this.freshSubBucket = false;\n            }\n            if (this.reachedIterationLevel()) {\n                var valueIteratedTo = this.getValueIteratedTo();\n                Object.assign(this.currentIterationValue, {\n                    valueIteratedTo: valueIteratedTo,\n                    valueIteratedFrom: this.prevValueIteratedTo,\n                    countAtValueIteratedTo: this.countAtThisValue,\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n                });\n                this.prevValueIteratedTo = valueIteratedTo;\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n                this.incrementIterationLevel();\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n                    throw new Error(\"Concurrent Modification Exception\");\n                }\n                return this.currentIterationValue;\n            }\n            this.incrementSubBucket();\n        }\n        throw new Error(\"Index Out Of Bounds Exception\");\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n    };\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n        return this.currentIndex >= this.histogram.countsArrayLength;\n    };\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n        this.freshSubBucket = true;\n        this.currentIndex++;\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n    };\n    return AbstractHistogramIterator;\n}());\nexports.default = AbstractHistogramIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a value point iterated through in a Histogram, with associated stats.\n * <ul>\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n * range.</li>\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n * values equal or smaller than valueIteratedTo.</li>\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n * equal or smaller than valueIteratedTo.</li>\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n * or smaller than valueIteratedTo.</li>\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n * range of multiple percentiles in the requested percentile iteration points).</li>\n * </ul>\n */\nvar HistogramIterationValue = /** @class */ (function () {\n    function HistogramIterationValue() {\n        this.reset();\n    }\n    HistogramIterationValue.prototype.reset = function () {\n        this.valueIteratedTo = 0;\n        this.valueIteratedFrom = 0;\n        this.countAtValueIteratedTo = 0;\n        this.countAddedInThisIterationStep = 0;\n        this.totalCountToThisValue = 0;\n        this.totalValueToThisValue = 0;\n        this.percentile = 0.0;\n        this.percentileLevelIteratedTo = 0.0;\n    };\n    return HistogramIterationValue;\n}());\nexports.default = HistogramIterationValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n/**\n * Used for iterating through histogram values according to percentile levels. The iteration is\n * performed in steps that start at 0% and reduce their distance to 100% according to the\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n * values are exhausted.\n */\nvar PercentileIterator = /** @class */ (function (_super) {\n    __extends(PercentileIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n     */\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n        var _this = _super.call(this) || this;\n        _this.percentileTicksPerHalfDistance = 0;\n        _this.percentileLevelToIterateTo = 0;\n        _this.percentileLevelToIterateFrom = 0;\n        _this.reachedLastRecordedValue = false;\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     *\n     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n     */\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n    };\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n        this.percentileLevelToIterateTo = 0;\n        this.percentileLevelToIterateFrom = 0;\n        this.reachedLastRecordedValue = false;\n    };\n    PercentileIterator.prototype.hasNext = function () {\n        if (_super.prototype.hasNext.call(this))\n            return true;\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n            this.percentileLevelToIterateTo = 100;\n            this.reachedLastRecordedValue = true;\n            return true;\n        }\n        return false;\n    };\n    PercentileIterator.prototype.incrementIterationLevel = function () {\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\n        // steps are much easier to browse through in a percentile distribution output, for example.\n        //\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n        // by at the current scale. The scale is detemined by the percentile level we are\n        // iterating to. The following math determines the tick size for the current scale,\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n        // [from either 0% or from the previous half-distance]. When that half-distance is\n        // crossed, the scale changes and the tick size is effectively cut in half.\n        // percentileTicksPerHalfDistance = 5\n        // percentileReportingTicks = 10,\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n    };\n    PercentileIterator.prototype.reachedIterationLevel = function () {\n        if (this.countAtThisValue === 0) {\n            return false;\n        }\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n        return currentPercentile >= this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n        return this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n        return this.percentileLevelToIterateFrom;\n    };\n    return PercentileIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = PercentileIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leftPadding = function (size) {\n    return function (input) {\n        if (input.length < size) {\n            return \" \".repeat(size - input.length) + input;\n        }\n        return input;\n    };\n};\nexports.integerFormatter = function (size) {\n    var padding = leftPadding(size);\n    return function (integer) { return padding(\"\" + integer); };\n};\nexports.floatFormatter = function (size, fractionDigits) {\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n        maximumFractionDigits: fractionDigits,\n        minimumFractionDigits: fractionDigits,\n        useGrouping: false\n    });\n    var padding = leftPadding(size);\n    return function (float) { return padding(numberFormatter.format(float)); };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\nexports.default = ulp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int16Histogram = /** @class */ (function (_super) {\n    __extends(Int16Histogram, _super);\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint16Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int16Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint16Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int16Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int16Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int16Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int16Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 2 * this.counts.length;\n    };\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int16Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int16Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram = /** @class */ (function (_super) {\n    __extends(Int32Histogram, _super);\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint32Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int32Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint32Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int32Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int32Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int32Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int32Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 4 * this.counts.length;\n    };\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int32Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int32Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Float64Histogram = /** @class */ (function (_super) {\n    __extends(Float64Histogram, _super);\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Float64Array(_this.countsArrayLength);\n        return _this;\n    }\n    Float64Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Float64Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Float64Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Float64Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Float64Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Float64Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 8 * this.counts.length;\n    };\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Float64Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Float64Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar PackedArray_1 = require(\"./packedarray/PackedArray\");\n/**\n * <h3>A High Dynamic Range (HDR) Histogram that uses a packed internal representation</h3>\n * <p>\n * {@link PackedHistogram} supports the recording and analyzing sampled data value counts across a configurable\n * integer value range with configurable value precision within the range. Value precision is expressed as the\n * number of significant digits in the value recording, and provides control over value quantization behavior\n * across the value range and the subsequent value resolution at any given level.\n * <p>\n * {@link PackedHistogram} tracks value counts in a packed internal representation optimized\n * for typical histogram recoded values are sparse in the value range and tend to be incremented in small unit counts.\n * This packed representation tends to require significantly smaller amounts of stoarge when compared to unpacked\n * representations, but can incur additional recording cost due to resizing and repacking operations that may\n * occur as previously unrecorded values are encountered.\n * <p>\n * For example, a {@link PackedHistogram} could be configured to track the counts of observed integer values between 0 and\n * 3,600,000,000,000 while maintaining a value precision of 3 significant digits across that range. Value quantization\n * within the range will thus be no larger than 1/1,000th (or 0.1%) of any value. This example Histogram could\n * be used to track and analyze the counts of observed response times ranging between 1 nanosecond and 1 hour\n * in magnitude, while maintaining a value resolution of 1 microsecond up to 1 millisecond, a resolution of\n * 1 millisecond (or better) up to one second, and a resolution of 1 second (or better) up to 1,000 seconds. At its\n * maximum tracked value (1 hour), it would still maintain a resolution of 3.6 seconds (or better).\n * <p>\n * Auto-resizing: When constructed with no specified value range range (or when auto-resize is turned on with {@link\n * Histogram#setAutoResize}) a {@link PackedHistogram} will auto-resize its dynamic range to include recorded values as\n * they are encountered. Note that recording calls that cause auto-resizing may take longer to execute, as resizing\n * incurs allocation and copying of internal data structures.\n * <p>\n */\nvar PackedHistogram = /** @class */ (function (_super) {\n    __extends(PackedHistogram, _super);\n    function PackedHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.packedCounts = new PackedArray_1.PackedArray(_this.countsArrayLength);\n        return _this;\n    }\n    PackedHistogram.prototype.clearCounts = function () {\n        this.packedCounts.clear();\n        this.totalCount = 0;\n    };\n    PackedHistogram.prototype.incrementCountAtIndex = function (index) {\n        this.packedCounts.increment(index);\n    };\n    PackedHistogram.prototype.addToCountAtIndex = function (index, value) {\n        this.packedCounts.add(index, value);\n    };\n    PackedHistogram.prototype.setCountAtIndex = function (index, value) {\n        /* TODO move in packed array\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n          throw value + \" would overflow integer count\";\n        }*/\n        this.packedCounts.set(index, value);\n    };\n    PackedHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        this.packedCounts.setVirtualLength(this.countsArrayLength);\n    };\n    PackedHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    PackedHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    PackedHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    PackedHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    PackedHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    PackedHistogram.prototype.getCountAtIndex = function (index) {\n        return this.packedCounts.get(index);\n    };\n    PackedHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 192 + 8 * this.packedCounts.getPhysicalLength();\n    };\n    PackedHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new PackedHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return PackedHistogram;\n}(AbstractHistogram_1.default));\nexports.default = PackedHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PackedHistogram.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar PackedArrayContext_1 = require(\"./PackedArrayContext\");\nvar ResizeError_1 = require(\"./ResizeError\");\nvar NUMBER_OF_SETS = 8;\nvar pow = Math.pow, floor = Math.floor;\n/**\n * A Packed array of signed 64 bit values, and supports {@link #get get()}, {@link #set set()},\n * {@link #add add()} and {@link #increment increment()} operations on the logical contents of the array.\n *\n * An {@link PackedLongArray} Uses {@link PackedArrayContext} to track\n * the array's logical contents. Contexts may be switched when a context requires resizing\n * to complete logical array operations (get, set, add, increment). Contexts are\n * established and used within critical sections in order to facilitate concurrent\n * implementors.\n *\n */\nvar PackedArray = /** @class */ (function () {\n    function PackedArray(virtualLength, initialPhysicalLength) {\n        if (initialPhysicalLength === void 0) { initialPhysicalLength = PackedArrayContext_1.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY; }\n        this.arrayContext = new PackedArrayContext_1.PackedArrayContext(virtualLength, initialPhysicalLength);\n    }\n    PackedArray.prototype.setVirtualLength = function (newVirtualArrayLength) {\n        if (newVirtualArrayLength < this.length()) {\n            throw new Error(\"Cannot set virtual length, as requested length \" +\n                newVirtualArrayLength +\n                \" is smaller than the current virtual length \" +\n                this.length());\n        }\n        var currentArrayContext = this.arrayContext;\n        if (currentArrayContext.isPacked &&\n            currentArrayContext.determineTopLevelShiftForVirtualLength(newVirtualArrayLength) == currentArrayContext.getTopLevelShift()) {\n            // No changes to the array context contents is needed. Just change the virtual length.\n            currentArrayContext.setVirtualLength(newVirtualArrayLength);\n            return;\n        }\n        this.arrayContext = currentArrayContext.copyAndIncreaseSize(this.getPhysicalLength(), newVirtualArrayLength);\n    };\n    /**\n     * Get value at virtual index in the array\n     * @param index the virtual array index\n     * @return the array value at the virtual index given\n     */\n    PackedArray.prototype.get = function (index) {\n        var value = 0;\n        for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n            var byteValueAtPackedIndex = 0;\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                return this.arrayContext.getAtUnpackedIndex(index);\n            }\n            // Context is packed:\n            var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, false);\n            if (packedIndex < 0) {\n                return value;\n            }\n            byteValueAtPackedIndex =\n                this.arrayContext.getAtByteIndex(packedIndex) * pow(2, byteNum << 3);\n            value += byteValueAtPackedIndex;\n        }\n        return value;\n    };\n    /**\n     * Increment value at a virrual index in the array\n     * @param index virtual index of value to increment\n     */\n    PackedArray.prototype.increment = function (index) {\n        this.add(index, 1);\n    };\n    PackedArray.prototype.safeGetPackedIndexgetPackedIndex = function (setNumber, virtualIndex) {\n        do {\n            try {\n                return this.arrayContext.getPackedIndex(setNumber, virtualIndex, true);\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Add to a value at a virtual index in the array\n     * @param index the virtual index of the value to be added to\n     * @param value the value to add\n     */\n    PackedArray.prototype.add = function (index, value) {\n        var remainingValueToAdd = value;\n        for (var byteNum = 0, byteShift = 0; byteNum < NUMBER_OF_SETS; byteNum++, byteShift += 8) {\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                this.arrayContext.addAndGetAtUnpackedIndex(index, value);\n                return;\n            }\n            // Context is packed:\n            var packedIndex = this.safeGetPackedIndexgetPackedIndex(byteNum, index);\n            var byteToAdd = remainingValueToAdd & 0xff;\n            var afterAddByteValue = this.arrayContext.addAtByteIndex(packedIndex, byteToAdd);\n            // Reduce remaining value to add by amount just added:\n            remainingValueToAdd -= byteToAdd;\n            remainingValueToAdd = remainingValueToAdd / pow(2, 8);\n            // Account for carry:\n            remainingValueToAdd += floor(afterAddByteValue / pow(2, 8));\n            if (remainingValueToAdd == 0) {\n                return; // nothing to add to higher magnitudes\n            }\n        }\n    };\n    /**\n     * Set the value at a virtual index in the array\n     * @param index the virtual index of the value to set\n     * @param value the value to set\n     */\n    PackedArray.prototype.set = function (index, value) {\n        var bytesAlreadySet = 0;\n        do {\n            var valueForNextLevels = value;\n            try {\n                for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n                    // Establish context within: critical section\n                    // Deal with unpacked context:\n                    if (!this.arrayContext.isPacked) {\n                        this.arrayContext.setAtUnpackedIndex(index, value);\n                        return;\n                    }\n                    // Context is packed:\n                    if (valueForNextLevels == 0) {\n                        // Special-case zeros to avoid inflating packed array for no reason\n                        var packedIndex_1 = this.arrayContext.getPackedIndex(byteNum, index, false);\n                        if (packedIndex_1 < 0) {\n                            return; // no need to create entries for zero values if they don't already exist\n                        }\n                    }\n                    // Make sure byte is populated:\n                    var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, true);\n                    // Determine value to write, and prepare for next levels\n                    var byteToWrite = valueForNextLevels & 0xff;\n                    valueForNextLevels = floor(valueForNextLevels / pow(2, 8));\n                    if (byteNum < bytesAlreadySet) {\n                        // We want to avoid writing to the same byte twice when not doing so for the\n                        // entire 64 bit value atomically, as doing so opens a race with e.g. concurrent\n                        // adders. So dobn't actually write the byte if has been written before.\n                        continue;\n                    }\n                    this.arrayContext.setAtByteIndex(packedIndex, byteToWrite);\n                    bytesAlreadySet++;\n                }\n                return;\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Get the current physical length (in longs) of the array's backing storage\n     * @return the current physical length (in longs) of the array's current backing storage\n     */\n    PackedArray.prototype.getPhysicalLength = function () {\n        return this.arrayContext.physicalLength;\n    };\n    /**\n     * Get the (virtual) length of the array\n     * @return the (virtual) length of the array\n     */\n    PackedArray.prototype.length = function () {\n        return this.arrayContext.getVirtualLength();\n    };\n    /**\n     * Clear the array contents\n     */\n    PackedArray.prototype.clear = function () {\n        this.arrayContext.clear();\n    };\n    PackedArray.prototype.toString = function () {\n        var output = \"PackedArray:\\n\";\n        output += this.arrayContext.toString();\n        return output;\n    };\n    return PackedArray;\n}());\nexports.PackedArray = PackedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/PackedArray.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError_1 = require(\"./ResizeError\");\n/**\n * A packed-value, sparse array context used for storing 64 bit signed values.\n *\n * An array context is optimised for tracking sparsely set (as in mostly zeros) values that tend to not make\n * use pof the full 64 bit value range even when they are non-zero. The array context's internal representation\n * is such that the packed value at each virtual array index may be represented by 0-8 bytes of actual storage.\n *\n * An array context encodes the packed values in 8 \"set trees\" with each set tree representing one byte of the\n * packed value at the virtual index in question. The {@link #getPackedIndex(int, int, boolean)} method is used\n * to look up the byte-index corresponding to the given (set tree) value byte of the given virtual index, and can\n * be used to add entries to represent that byte as needed. As a succesful {@link #getPackedIndex(int, int, boolean)}\n * may require a resizing of the array, it can throw a {@link ResizeException} to indicate that the requested\n * packed index cannot be found or added without a resize of the physical storage.\n *\n */\nexports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY = 16;\nvar MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH = Math.pow(2, 13) - 1; //(Short.MAX_VALUE / 4);  TODO ALEX why ???\nvar SET_0_START_INDEX = 0;\nvar NUMBER_OF_SETS = 8;\nvar LEAF_LEVEL_SHIFT = 3;\nvar NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET = 0;\nvar NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS = 1;\nvar PACKED_ARRAY_GROWTH_INCREMENT = 16;\nvar PACKED_ARRAY_GROWTH_FRACTION_POW2 = 4;\nvar pow = Math.pow, ceil = Math.ceil, log2 = Math.log2, max = Math.max;\nvar bitCount = function (n) {\n    var bits = 0;\n    while (n !== 0) {\n        bits += bitCount32(n | 0);\n        n /= 0x100000000;\n    }\n    return bits;\n};\nvar bitCount32 = function (n) {\n    n = n - ((n >> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n};\nvar PackedArrayContext = /** @class */ (function () {\n    function PackedArrayContext(virtualLength, initialPhysicalLength) {\n        this.populatedShortLength = 0;\n        this.topLevelShift = Number.MAX_VALUE; // Make it non-sensical until properly initialized.\n        this.physicalLength = Math.max(initialPhysicalLength, exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY);\n        this.isPacked =\n            this.physicalLength <= MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH;\n        if (!this.isPacked) {\n            this.physicalLength = virtualLength;\n        }\n        this.array = new ArrayBuffer(this.physicalLength * 8);\n        this.initArrayViews(this.array);\n        this.init(virtualLength);\n    }\n    PackedArrayContext.prototype.initArrayViews = function (array) {\n        this.byteArray = new Uint8Array(array);\n        this.shortArray = new Uint16Array(array);\n        this.longArray = new Float64Array(array);\n    };\n    PackedArrayContext.prototype.init = function (virtualLength) {\n        if (!this.isPacked) {\n            // Deal with non-packed context init:\n            this.virtualLength = virtualLength;\n            return;\n        }\n        this.populatedShortLength = SET_0_START_INDEX + 8;\n        // Populate empty root entries, and point to them from the root indexes:\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            this.setAtShortIndex(SET_0_START_INDEX + i, 0);\n        }\n        this.setVirtualLength(virtualLength);\n    };\n    PackedArrayContext.prototype.clear = function () {\n        this.byteArray.fill(0);\n    };\n    PackedArrayContext.prototype.copyAndIncreaseSize = function (newPhysicalArrayLength, newVirtualArrayLength) {\n        var ctx = new PackedArrayContext(newVirtualArrayLength, newPhysicalArrayLength);\n        if (this.isPacked) {\n            ctx.populateEquivalentEntriesWithEntriesFromOther(this);\n        }\n        return ctx;\n    };\n    PackedArrayContext.prototype.getPopulatedShortLength = function () {\n        return this.populatedShortLength;\n    };\n    PackedArrayContext.prototype.getPopulatedLongLength = function () {\n        return (this.getPopulatedShortLength() + 3) >> 2; // round up\n    };\n    PackedArrayContext.prototype.setAtByteIndex = function (byteIndex, value) {\n        this.byteArray[byteIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtByteIndex = function (byteIndex) {\n        return this.byteArray[byteIndex];\n    };\n    /**\n     * add a byte value to a current byte value in the array\n     * @param byteIndex index of byte value to add to\n     * @param valueToAdd byte value to add\n     * @return the afterAddValue. ((afterAddValue & 0x100) != 0) indicates a carry.\n     */\n    PackedArrayContext.prototype.addAtByteIndex = function (byteIndex, valueToAdd) {\n        var newValue = this.byteArray[byteIndex] + valueToAdd;\n        this.byteArray[byteIndex] = newValue;\n        return newValue;\n    };\n    PackedArrayContext.prototype.setPopulatedLongLength = function (newPopulatedLongLength) {\n        this.populatedShortLength = newPopulatedLongLength << 2;\n    };\n    PackedArrayContext.prototype.getVirtualLength = function () {\n        return this.virtualLength;\n    };\n    PackedArrayContext.prototype.length = function () {\n        return this.physicalLength;\n    };\n    PackedArrayContext.prototype.setAtShortIndex = function (shortIndex, value) {\n        this.shortArray[shortIndex] = value;\n    };\n    PackedArrayContext.prototype.setAtLongIndex = function (longIndex, value) {\n        this.longArray[longIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.getIndexAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.setPackedSlotIndicators = function (entryIndex, newPackedSlotIndicators) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, newPackedSlotIndicators);\n    };\n    PackedArrayContext.prototype.getPackedSlotIndicators = function (entryIndex) {\n        return (this.shortArray[entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET] &\n            0xffff);\n    };\n    PackedArrayContext.prototype.getIndexAtEntrySlot = function (entryIndex, slot) {\n        return this.getAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot);\n    };\n    PackedArrayContext.prototype.setIndexAtEntrySlot = function (entryIndex, slot, newIndexValue) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot, newIndexValue);\n    };\n    PackedArrayContext.prototype.expandArrayIfNeeded = function (entryLengthInLongs) {\n        var currentLength = this.length();\n        if (currentLength < this.getPopulatedLongLength() + entryLengthInLongs) {\n            var growthIncrement = max(entryLengthInLongs, PACKED_ARRAY_GROWTH_INCREMENT, this.getPopulatedLongLength() >> PACKED_ARRAY_GROWTH_FRACTION_POW2);\n            throw new ResizeError_1.ResizeError(currentLength + growthIncrement);\n        }\n    };\n    PackedArrayContext.prototype.newEntry = function (entryLengthInShorts) {\n        // Add entry at the end of the array:\n        var newEntryIndex = this.populatedShortLength;\n        this.expandArrayIfNeeded((entryLengthInShorts >> 2) + 1);\n        this.populatedShortLength = newEntryIndex + entryLengthInShorts;\n        for (var i = 0; i < entryLengthInShorts; i++) {\n            this.setAtShortIndex(newEntryIndex + i, -1); // Poison value -1. Must be overriden before reads\n        }\n        return newEntryIndex;\n    };\n    PackedArrayContext.prototype.newLeafEntry = function () {\n        // Add entry at the end of the array:\n        var newEntryIndex;\n        newEntryIndex = this.getPopulatedLongLength();\n        this.expandArrayIfNeeded(1);\n        this.setPopulatedLongLength(newEntryIndex + 1);\n        this.setAtLongIndex(newEntryIndex, 0);\n        return newEntryIndex;\n    };\n    /**\n     * Consolidate entry with previous entry verison if one exists\n     *\n     * @param entryIndex The shortIndex of the entry to be consolidated\n     * @param previousVersionIndex the index of the previous version of the entry\n     */\n    PackedArrayContext.prototype.consolidateEntry = function (entryIndex, previousVersionIndex) {\n        var previousVersionPackedSlotsIndicators = this.getPackedSlotIndicators(previousVersionIndex);\n        // Previous version exists, needs consolidation\n        var packedSlotsIndicators = this.getPackedSlotIndicators(entryIndex);\n        var insertedSlotMask = packedSlotsIndicators ^ previousVersionPackedSlotsIndicators; // the only bit that differs\n        var slotsBelowBitNumber = packedSlotsIndicators & (insertedSlotMask - 1);\n        var insertedSlotIndex = bitCount(slotsBelowBitNumber);\n        var numberOfSlotsInEntry = bitCount(packedSlotsIndicators);\n        // Copy the entry slots from previous version, skipping the newly inserted slot in the target:\n        var sourceSlot = 0;\n        for (var targetSlot = 0; targetSlot < numberOfSlotsInEntry; targetSlot++) {\n            if (targetSlot !== insertedSlotIndex) {\n                var indexAtSlot = this.getIndexAtEntrySlot(previousVersionIndex, sourceSlot);\n                if (indexAtSlot !== 0) {\n                    this.setIndexAtEntrySlot(entryIndex, targetSlot, indexAtSlot);\n                }\n                sourceSlot++;\n            }\n        }\n    };\n    /**\n     * Expand entry as indicated.\n     *\n     * @param existingEntryIndex the index of the entry\n     * @param entryPointerIndex  index to the slot pointing to the entry (needs to be fixed up)\n     * @param insertedSlotIndex  realtive [packed] index of slot being inserted into entry\n     * @param insertedSlotMask   mask value fo slot being inserted\n     * @param nextLevelIsLeaf    the level below this one is a leaf level\n     * @return the updated index of the entry (-1 if epansion failed due to conflict)\n     * @throws RetryException if expansion fails due to concurrent conflict, and caller should try again.\n     */\n    PackedArrayContext.prototype.expandEntry = function (existingEntryIndex, entryPointerIndex, insertedSlotIndex, insertedSlotMask, nextLevelIsLeaf) {\n        var packedSlotIndicators = this.getAtShortIndex(existingEntryIndex) & 0xffff;\n        packedSlotIndicators |= insertedSlotMask;\n        var numberOfslotsInExpandedEntry = bitCount(packedSlotIndicators);\n        if (insertedSlotIndex >= numberOfslotsInExpandedEntry) {\n            throw new Error(\"inserted slot index is out of range given provided masks\");\n        }\n        var expandedEntryLength = numberOfslotsInExpandedEntry + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS;\n        // Create new next-level entry to refer to from slot at this level:\n        var indexOfNewNextLevelEntry = 0;\n        if (nextLevelIsLeaf) {\n            indexOfNewNextLevelEntry = this.newLeafEntry(); // Establish long-index to new leaf entry\n        }\n        else {\n            // TODO: Optimize this by creating the whole sub-tree here, rather than a step that will immediaterly expand\n            // Create a new 1 word (empty, no slots set) entry for the next level:\n            indexOfNewNextLevelEntry = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS); // Establish short-index to new leaf entry\n            this.setPackedSlotIndicators(indexOfNewNextLevelEntry, 0);\n        }\n        var insertedSlotValue = indexOfNewNextLevelEntry;\n        var expandedEntryIndex = this.newEntry(expandedEntryLength);\n        // populate the packed indicators word:\n        this.setPackedSlotIndicators(expandedEntryIndex, packedSlotIndicators);\n        // Populate the inserted slot with the index of the new next level entry:\n        this.setIndexAtEntrySlot(expandedEntryIndex, insertedSlotIndex, insertedSlotValue);\n        this.setAtShortIndex(entryPointerIndex, expandedEntryIndex);\n        this.consolidateEntry(expandedEntryIndex, existingEntryIndex);\n        return expandedEntryIndex;\n    };\n    //\n    //   ######   ######## ########    ##     ##    ###    ##             ## #### ##    ## ########  ######## ##     ##\n    //  ##    ##  ##          ##       ##     ##   ## ##   ##            ##   ##  ###   ## ##     ## ##        ##   ##\n    //  ##        ##          ##       ##     ##  ##   ##  ##           ##    ##  ####  ## ##     ## ##         ## ##\n    //  ##   #### ######      ##       ##     ## ##     ## ##          ##     ##  ## ## ## ##     ## ######      ###\n    //  ##    ##  ##          ##        ##   ##  ######### ##         ##      ##  ##  #### ##     ## ##         ## ##\n    //  ##    ##  ##          ##         ## ##   ##     ## ##        ##       ##  ##   ### ##     ## ##        ##   ##\n    //   ######   ########    ##          ###    ##     ## ######## ##       #### ##    ## ########  ######## ##     ##\n    //\n    PackedArrayContext.prototype.getRootEntry = function (setNumber, insertAsNeeded) {\n        if (insertAsNeeded === void 0) { insertAsNeeded = false; }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber;\n        var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        if (entryIndex == 0) {\n            if (!insertAsNeeded) {\n                return 0; // Index does not currently exist in packed array;\n            }\n            entryIndex = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS);\n            // Create a new empty (no slots set) entry for the next level:\n            this.setPackedSlotIndicators(entryIndex, 0);\n            this.setAtShortIndex(entryPointerIndex, entryIndex);\n        }\n        return entryIndex;\n    };\n    /**\n     * Get the byte-index (into the packed array) corresponding to a given (set tree) value byte of given virtual index.\n     * Inserts new set tree nodes as needed if indicated.\n     *\n     * @param setNumber      The set tree number (0-7, 0 corresponding with the LSByte set tree)\n     * @param virtualIndex   The virtual index into the PackedArray\n     * @param insertAsNeeded If true, will insert new set tree nodes as needed if they do not already exist\n     * @return the byte-index corresponding to the given (set tree) value byte of the given virtual index\n     */\n    PackedArrayContext.prototype.getPackedIndex = function (setNumber, virtualIndex, insertAsNeeded) {\n        if (virtualIndex >= this.virtualLength) {\n            throw new Error(\"Attempting access at index \" + virtualIndex + \", beyond virtualLength \" + this.virtualLength);\n        }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber; // TODO init needed ?\n        var entryIndex = this.getRootEntry(setNumber, insertAsNeeded);\n        if (entryIndex == 0) {\n            return -1; // Index does not currently exist in packed array;\n        }\n        // Work down the levels of non-leaf entries:\n        for (var indexShift = this.topLevelShift; indexShift >= LEAF_LEVEL_SHIFT; indexShift -= 4) {\n            var nextLevelIsLeaf = indexShift === LEAF_LEVEL_SHIFT;\n            // Target is a packedSlotIndicators entry\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            var slotBitNumber = (virtualIndex / pow(2, indexShift)) & 0xf; //(virtualIndex >>> indexShift) & 0xf;\n            var slotMask = 1 << slotBitNumber;\n            var slotsBelowBitNumber = packedSlotIndicators & (slotMask - 1);\n            var slotNumber = bitCount(slotsBelowBitNumber);\n            if ((packedSlotIndicators & slotMask) === 0) {\n                // The entryIndex slot does not have the contents we want\n                if (!insertAsNeeded) {\n                    return -1; // Index does not currently exist in packed array;\n                }\n                // Expand the entry, adding the index to new entry at the proper slot:\n                entryIndex = this.expandEntry(entryIndex, entryPointerIndex, slotNumber, slotMask, nextLevelIsLeaf);\n            }\n            // Next level's entry pointer index is in the appropriate slot in in the entries array in this entry:\n            entryPointerIndex =\n                entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slotNumber;\n            entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        }\n        // entryIndex is the long-index of a leaf entry that contains the value byte for the given set\n        var byteIndex = (entryIndex << 3) + (virtualIndex & 0x7); // Determine byte index offset within leaf entry\n        return byteIndex;\n    };\n    PackedArrayContext.prototype.determineTopLevelShiftForVirtualLength = function (virtualLength) {\n        var sizeMagnitude = ceil(log2(virtualLength));\n        var eightsSizeMagnitude = sizeMagnitude - 3;\n        var multipleOfFourSizeMagnitude = ceil(eightsSizeMagnitude / 4) * 4;\n        multipleOfFourSizeMagnitude = max(multipleOfFourSizeMagnitude, 8);\n        var topLevelShiftNeeded = multipleOfFourSizeMagnitude - 4 + 3;\n        return topLevelShiftNeeded;\n    };\n    PackedArrayContext.prototype.setVirtualLength = function (virtualLength) {\n        if (!this.isPacked) {\n            throw new Error(\"Should never be adjusting the virtual size of a non-packed context\");\n        }\n        this.topLevelShift = this.determineTopLevelShiftForVirtualLength(virtualLength);\n        this.virtualLength = virtualLength;\n    };\n    PackedArrayContext.prototype.getTopLevelShift = function () {\n        return this.topLevelShift;\n    };\n    //\n    //  ##     ##         ########   #######  ########  ##     ## ##          ###    ######## ########\n    //   ##   ##          ##     ## ##     ## ##     ## ##     ## ##         ## ##      ##    ##\n    //    ## ##           ##     ## ##     ## ##     ## ##     ## ##        ##   ##     ##    ##\n    //     ###    ####### ########  ##     ## ########  ##     ## ##       ##     ##    ##    ######\n    //    ## ##           ##        ##     ## ##        ##     ## ##       #########    ##    ##\n    //   ##   ##          ##        ##     ## ##        ##     ## ##       ##     ##    ##    ##\n    //  ##     ##         ##         #######  ##         #######  ######## ##     ##    ##    ########\n    //\n    PackedArrayContext.prototype.resizeArray = function (newLength) {\n        var tmp = new Uint8Array(newLength * 8);\n        tmp.set(this.byteArray);\n        this.array = tmp.buffer;\n        this.initArrayViews(this.array);\n        this.physicalLength = newLength;\n    };\n    PackedArrayContext.prototype.populateEquivalentEntriesWithEntriesFromOther = function (other) {\n        if (this.virtualLength < other.getVirtualLength()) {\n            throw new Error(\"Cannot populate array of smaller virtual length\");\n        }\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            var otherEntryIndex = other.getAtShortIndex(SET_0_START_INDEX + i);\n            if (otherEntryIndex == 0)\n                continue; // No tree to duplicate\n            var entryIndexPointer = SET_0_START_INDEX + i;\n            for (var i_1 = this.topLevelShift; i_1 > other.topLevelShift; i_1 -= 4) {\n                // for each inserted level:\n                // Allocate entry in other:\n                var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + 1;\n                var newEntryIndex = this.newEntry(sizeOfEntry);\n                // Link new level in.\n                this.setAtShortIndex(entryIndexPointer, newEntryIndex);\n                // Populate new level entry, use pointer to slot 0 as place to populate under:\n                this.setPackedSlotIndicators(newEntryIndex, 0x1); // Slot 0 populated\n                entryIndexPointer =\n                    newEntryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS; // Where the slot 0 index goes.\n            }\n            this.copyEntriesAtLevelFromOther(other, otherEntryIndex, entryIndexPointer, other.topLevelShift);\n        }\n    };\n    PackedArrayContext.prototype.copyEntriesAtLevelFromOther = function (other, otherLevelEntryIndex, levelEntryIndexPointer, otherIndexShift) {\n        var nextLevelIsLeaf = otherIndexShift == LEAF_LEVEL_SHIFT;\n        var packedSlotIndicators = other.getPackedSlotIndicators(otherLevelEntryIndex);\n        var numberOfSlots = bitCount(packedSlotIndicators);\n        var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + numberOfSlots;\n        var entryIndex = this.newEntry(sizeOfEntry);\n        this.setAtShortIndex(levelEntryIndexPointer, entryIndex);\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, packedSlotIndicators);\n        for (var i = 0; i < numberOfSlots; i++) {\n            if (nextLevelIsLeaf) {\n                // Make leaf in other:\n                var leafEntryIndex = this.newLeafEntry();\n                this.setIndexAtEntrySlot(entryIndex, i, leafEntryIndex);\n                // OPTIM\n                // avoid iteration on all the values of the source ctx\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.longArray[leafEntryIndex] =\n                    other.longArray[otherNextLevelEntryIndex];\n            }\n            else {\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.copyEntriesAtLevelFromOther(other, otherNextLevelEntryIndex, entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + i, otherIndexShift - 4);\n            }\n        }\n    };\n    PackedArrayContext.prototype.getAtUnpackedIndex = function (index) {\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.setAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.lazysetAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.incrementAndGetAtUnpackedIndex = function (index) {\n        this.longArray[index]++;\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.addAndGetAtUnpackedIndex = function (index, valueToAdd) {\n        this.longArray[index] += valueToAdd;\n        return this.longArray[index];\n    };\n    //\n    //   ########  #######           ######  ######## ########  #### ##    ##  ######\n    //      ##    ##     ##         ##    ##    ##    ##     ##  ##  ###   ## ##    ##\n    //      ##    ##     ##         ##          ##    ##     ##  ##  ####  ## ##\n    //      ##    ##     ## #######  ######     ##    ########   ##  ## ## ## ##   ####\n    //      ##    ##     ##               ##    ##    ##   ##    ##  ##  #### ##    ##\n    //      ##    ##     ##         ##    ##    ##    ##    ##   ##  ##   ### ##    ##\n    //      ##     #######           ######     ##    ##     ## #### ##    ##  ######\n    //\n    PackedArrayContext.prototype.nonLeafEntryToString = function (entryIndex, indexShift, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            output += \"slotIndiators: 0x\" + toHex(packedSlotIndicators) + \", prevVersionIndex: 0: [ \";\n            var numberOfslotsInEntry = bitCount(packedSlotIndicators);\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                output += this.getIndexAtEntrySlot(entryIndex, i);\n                if (i < numberOfslotsInEntry - 1) {\n                    output += \", \";\n                }\n            }\n            output += \" ] (indexShift = \" + indexShift + \")\\n\";\n            var nextLevelIsLeaf = indexShift == LEAF_LEVEL_SHIFT;\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                var nextLevelEntryIndex = this.getIndexAtEntrySlot(entryIndex, i);\n                if (nextLevelIsLeaf) {\n                    output += this.leafEntryToString(nextLevelEntryIndex, indentLevel + 4);\n                }\n                else {\n                    output += this.nonLeafEntryToString(nextLevelEntryIndex, indexShift - 4, indentLevel + 4);\n                }\n            }\n        }\n        catch (ex) {\n            output += \"Exception thrown at nonLeafEnty at index \" + entryIndex + \" with indexShift \" + indexShift + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.leafEntryToString = function (entryIndex, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            output += \"Leaf bytes : \";\n            for (var i = 0; i < 8; i++) {\n                output += \"0x\" + toHex(this.byteArray[entryIndex * 8 + i]) + \" \";\n            }\n            output += \"\\n\";\n        }\n        catch (ex) {\n            output += \"Exception thrown at leafEnty at index \" + entryIndex + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.toString = function () {\n        var output = \"PackedArrayContext:\\n\";\n        if (!this.isPacked) {\n            return output + \"Context is unpacked:\\n\"; // unpackedToString();\n        }\n        for (var setNumber = 0; setNumber < NUMBER_OF_SETS; setNumber++) {\n            try {\n                var entryPointerIndex = SET_0_START_INDEX + setNumber;\n                var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n                output += \"Set \" + setNumber + \": root = \" + entryIndex + \" \\n\";\n                if (entryIndex == 0)\n                    continue;\n                output += this.nonLeafEntryToString(entryIndex, this.topLevelShift, 4);\n            }\n            catch (ex) {\n                output += \"Exception thrown in set \" + setNumber + \"%d\\n\";\n            }\n        }\n        //output += recordedValuesToString();\n        return output;\n    };\n    return PackedArrayContext;\n}());\nexports.PackedArrayContext = PackedArrayContext;\nvar toHex = function (n) {\n    return Number(n)\n        .toString(16)\n        .padStart(2, \"0\");\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/PackedArrayContext.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError = /** @class */ (function () {\n    function ResizeError(newSize) {\n        this.newSize = newSize;\n    }\n    return ResizeError;\n}());\nexports.ResizeError = ResizeError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/ResizeError.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar SparseArrayHistogram = /** @class */ (function (_super) {\n    __extends(SparseArrayHistogram, _super);\n    function SparseArrayHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Array();\n        return _this;\n    }\n    SparseArrayHistogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    SparseArrayHistogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    SparseArrayHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n    };\n    SparseArrayHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    SparseArrayHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    SparseArrayHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    SparseArrayHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    SparseArrayHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    SparseArrayHistogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index] || 0;\n    };\n    SparseArrayHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    SparseArrayHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new SparseArrayHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return SparseArrayHistogram;\n}(AbstractHistogram_1.default));\nexports.default = SparseArrayHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SparseArrayHistogram.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar encoding_1 = require(\"./encoding\");\nvar TAG_PREFIX = \"Tag=\";\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n/**\n * A histogram log reader.\n * <p>\n * Histogram logs are used to capture full fidelity, per-time-interval\n * histograms of a recorded value.\n * <p>\n * For example, a histogram log can be used to capture high fidelity\n * reaction-time logs for some measured system or subsystem component.\n * Such a log would capture a full reaction time histogram for each\n * logged interval, and could be used to later reconstruct a full\n * HdrHistogram of the measured reaction time behavior for any arbitrary\n * time range within the log, by adding [only] the relevant interval\n * histograms.\n * <h3>Histogram log format:</h3>\n * A histogram log file consists of text lines. Lines beginning with\n * the \"#\" character are optional and treated as comments. Lines\n * containing the legend (starting with \"Timestamp\") are also optional\n * and ignored in parsing the histogram log. All other lines must\n * be valid interval description lines. Text fields are delimited by\n * commas, spaces.\n * <p>\n * A valid interval description line contains an optional Tag=tagString\n * text field, followed by an interval description.\n * <p>\n * A valid interval description must contain exactly four text fields:\n * <ul>\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n * representing the start timestamp of the interval in seconds.</li>\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n * representing the length of the interval in seconds.</li>\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n * which generally represents the maximum value of the interval histogram.</li>\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n * </ul>\n * The log file may contain an optional indication of a starting time. Starting time\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\n * by a number parse-able as a double, representing the start time (in seconds)\n * that may be added to timestamps in the file to determine an absolute\n * timestamp (e.g. since the epoch) for each interval.\n */\nvar HistogramLogReader = /** @class */ (function () {\n    function HistogramLogReader(logContent, options) {\n        var _a;\n        this.lines = splitLines(logContent);\n        this.currentLineIndex = 0;\n        this.histogramConstr = ((_a = options) === null || _a === void 0 ? void 0 : _a.histogramConstr) || Int32Histogram_1.default;\n    }\n    /**\n     * Read the next interval histogram from the log. Returns a Histogram object if\n     * an interval line was found, or null if not.\n     * <p>Upon encountering any unexpected format errors in reading the next interval\n     * from the file, this method will return a null.\n     * @return a DecodedInterval, or a null if no appropriate interval found\n     */\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n        while (this.currentLineIndex < this.lines.length) {\n            var currentLine = this.lines[this.currentLineIndex];\n            this.currentLineIndex++;\n            if (currentLine.startsWith(\"#[StartTime:\")) {\n                this.parseStartTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n                this.parseBaseTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#\") ||\n                currentLine.startsWith('\"StartTimestamp\"')) {\n                // skip legend & meta data for now\n            }\n            else if (currentLine.includes(\",\")) {\n                var tokens = currentLine.split(\",\");\n                var firstToken = tokens[0];\n                var tag = void 0;\n                if (firstToken.startsWith(TAG_PREFIX)) {\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n                    tokens.shift();\n                }\n                else {\n                    tag = AbstractHistogramBase_1.NO_TAG;\n                }\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n                if (!this.baseTimeSec) {\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n                        // StartTime), we assume that timestamps in the log are not absolute\n                        this.baseTimeSec = this.startTimeSec;\n                    }\n                    else {\n                        // Timestamps are absolute\n                        this.baseTimeSec = 0.0;\n                    }\n                }\n                if (rangeEndTimeSec < logTimeStampInSec) {\n                    return null;\n                }\n                if (logTimeStampInSec < rangeStartTimeSec) {\n                    continue;\n                }\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram, this.histogramConstr);\n                histogram.startTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n                histogram.endTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n                histogram.tag = tag;\n                return histogram;\n            }\n        }\n        return null;\n    };\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    return HistogramLogReader;\n}());\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\nvar shouldIncludeNoTag = function (lines) {\n    return lines.find(function (line) {\n        return !line.startsWith(\"#\") &&\n            !line.startsWith('\"') &&\n            !line.startsWith(TAG_PREFIX) &&\n            line.includes(\",\");\n    });\n};\nexports.listTags = function (content) {\n    var lines = splitLines(content);\n    var tags = lines\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n    var tagsWithoutDuplicates = new Set(tags);\n    var result = Array.from(tagsWithoutDuplicates);\n    if (shouldIncludeNoTag(lines)) {\n        result.unshift(\"NO TAG\");\n    }\n    return result;\n};\nexports.default = HistogramLogReader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nrequire(\"./AbstractHistogram.encoding\");\nvar base64 = require(\"base64-js\");\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String.trim()));\n    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n};\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\n    var buffer = ByteBuffer_1.default.allocate();\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\n    return base64.fromByteArray(encodedBuffer);\n};\nexports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\nvar max = Math.max;\nvar V2EncodingCookieBase = 0x1c849303;\nvar V2CompressedEncodingCookieBase = 0x1c849304;\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nfunction fillBufferFromCountsArray(self, buffer) {\n    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n    var srcIndex = 0;\n    while (srcIndex < countsLimit) {\n        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n        // while negative values indicate a repeat zero counts.\n        var count = self.getCountAtIndex(srcIndex++);\n        if (count < 0) {\n            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n                count +\n                \") at index \" +\n                srcIndex +\n                \", corresponding the value range [\" +\n                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \",\" +\n                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \")\");\n        }\n        // Count trailing 0s (which follow this count):\n        var zerosCount = 0;\n        if (count == 0) {\n            zerosCount = 1;\n            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n                zerosCount++;\n                srcIndex++;\n            }\n        }\n        if (zerosCount > 1) {\n            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n        }\n        else {\n            ZigZagEncoding_1.default.encode(buffer, count);\n        }\n    }\n}\n/**\n * Encode this histogram into a ByteBuffer\n * @param buffer The buffer to encode into\n * @return The number of bytes written to the buffer\n */\nfunction encodeIntoByteBuffer(buffer) {\n    var self = this;\n    var initialPosition = buffer.position;\n    buffer.putInt32(encodingCookie);\n    buffer.putInt32(0); // Placeholder for payload length in bytes.\n    buffer.putInt32(1);\n    buffer.putInt32(self.numberOfSignificantValueDigits);\n    buffer.putInt64(self.lowestDiscernibleValue);\n    buffer.putInt64(self.highestTrackableValue);\n    buffer.putInt64(1);\n    var payloadStartPosition = buffer.position;\n    fillBufferFromCountsArray(self, buffer);\n    var backupIndex = buffer.position;\n    buffer.position = initialPosition + 4;\n    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n    buffer.position = backupIndex;\n    return backupIndex - initialPosition;\n}\nexports.encodeIntoByteBuffer = encodeIntoByteBuffer;\nfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n    if (wordSizeInBytes != 2 &&\n        wordSizeInBytes != 4 &&\n        wordSizeInBytes != 8 &&\n        wordSizeInBytes != V2maxWordSizeInBytes) {\n        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n            V2maxWordSizeInBytes +\n            \") bytes\");\n    }\n    var dstIndex = 0;\n    var endPosition = sourceBuffer.position + lengthInBytes;\n    while (sourceBuffer.position < endPosition) {\n        var zerosCount = 0;\n        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n        if (count < 0) {\n            zerosCount = -count;\n            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n        }\n        else {\n            self.setCountAtIndex(dstIndex++, count);\n        }\n    }\n    return dstIndex; // this is the destination length\n}\nfunction getCookieBase(cookie) {\n    return cookie & ~0xf0;\n}\nfunction getWordSizeInBytesFromCookie(cookie) {\n    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n        return V2maxWordSizeInBytes;\n    }\n    var sizeByte = (cookie & 0xf0) >> 4;\n    return sizeByte & 0xe;\n}\nfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var cookie = buffer.getInt32();\n    var payloadLengthInBytes;\n    var numberOfSignificantValueDigits;\n    var lowestTrackableUnitValue;\n    var highestTrackableValue;\n    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n        }\n        payloadLengthInBytes = buffer.getInt32();\n        buffer.getInt32(); // normalizingIndexOffset not used\n        numberOfSignificantValueDigits = buffer.getInt32();\n        lowestTrackableUnitValue = buffer.getInt64();\n        highestTrackableValue = buffer.getInt64();\n        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n    }\n    else {\n        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n    }\n    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n    histogram.establishInternalTackingValues(filledLength);\n    return histogram;\n}\nexports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\nfunction findDeflateFunction() {\n    try {\n        return eval('require(\"zlib\").deflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/deflate\");\n        return pako.deflate;\n    }\n}\nfunction findInflateFunction() {\n    try {\n        return eval('require(\"zlib\").inflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/inflate\");\n        return pako.inflate;\n    }\n}\nvar deflate = findDeflateFunction();\nvar inflate = findInflateFunction();\nfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var initialTargetPosition = buffer.position;\n    var cookie = buffer.getInt32();\n    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n        throw new Error(\"Encoding not supported, only V2 is supported\");\n    }\n    var lengthOfCompressedContents = buffer.getInt32();\n    var uncompressedBuffer = inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n}\nexports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n/**\n * Encode this histogram in compressed form into a byte array\n * @param targetBuffer The buffer to encode into\n * @return The number of bytes written to the array\n */\nfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n    var self = this;\n    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n    targetBuffer.putInt32(compressedEncodingCookie);\n    var compressionOptions = compressionLevel\n        ? { level: compressionLevel }\n        : {};\n    var compressedArray = deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n    targetBuffer.putInt32(compressedArray.byteLength);\n    targetBuffer.putArray(compressedArray);\n    return targetBuffer.position;\n}\nexports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.encoding.ts\n// module id = 23\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_7 = pow(2, 7);\nvar TWO_POW_14 = pow(2, 14);\nvar TWO_POW_21 = pow(2, 21);\nvar TWO_POW_28 = pow(2, 28);\nvar TWO_POW_35 = pow(2, 35);\nvar TWO_POW_42 = pow(2, 42);\nvar TWO_POW_49 = pow(2, 49);\nvar TWO_POW_56 = pow(2, 56);\n/**\n * This class provides encoding and decoding methods for writing and reading\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n * allows small (closer to zero) negative values to use fewer bytes. Details\n * on both LEB128 and ZigZag can be readily found elsewhere.\n *\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n * value can take up to 10 bytes in the stream, where this variant's encoding\n * of a 64 bit values will max out at 9 bytes.\n *\n * As such, this encoder/decoder should NOT be used for encoding or decoding\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n */\nvar ZigZagEncoding = /** @class */ (function () {\n    function ZigZagEncoding() {\n    }\n    /**\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n     * (negative numbers not supported)\n     * @param buffer the buffer to write to\n     * @param value  the value to write to the buffer\n     */\n    ZigZagEncoding.encode = function (buffer, value) {\n        if (value >= 0) {\n            value = value * 2;\n        }\n        else {\n            value = -value * 2 - 1;\n        }\n        if (value < TWO_POW_7) {\n            buffer.put(value);\n        }\n        else {\n            buffer.put(value | 0x80);\n            if (value < TWO_POW_14) {\n                buffer.put(floor(value / TWO_POW_7));\n            }\n            else {\n                buffer.put(floor(value / TWO_POW_7) | 0x80);\n                if (value < TWO_POW_21) {\n                    buffer.put(floor(value / TWO_POW_14));\n                }\n                else {\n                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n                    if (value < TWO_POW_28) {\n                        buffer.put(floor(value / TWO_POW_21));\n                    }\n                    else {\n                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n                        if (value < TWO_POW_35) {\n                            buffer.put(floor(value / TWO_POW_28));\n                        }\n                        else {\n                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n                            if (value < TWO_POW_42) {\n                                buffer.put(floor(value / TWO_POW_35));\n                            }\n                            else {\n                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n                                if (value < TWO_POW_49) {\n                                    buffer.put(floor(value / TWO_POW_42));\n                                }\n                                else {\n                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n                                    if (value < TWO_POW_56) {\n                                        buffer.put(floor(value / TWO_POW_49));\n                                    }\n                                    else {\n                                        // should not happen\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n                                        buffer.put(floor(value / TWO_POW_56));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n     * (negative numbers not supported)\n     * @param buffer the buffer to read from\n     * @return the value read from the buffer\n     */\n    ZigZagEncoding.decode = function (buffer) {\n        var v = buffer.get();\n        var value = v & 0x7f;\n        if ((v & 0x80) != 0) {\n            v = buffer.get();\n            value += (v & 0x7f) * TWO_POW_7;\n            if ((v & 0x80) != 0) {\n                v = buffer.get();\n                value += (v & 0x7f) * TWO_POW_14;\n                if ((v & 0x80) != 0) {\n                    v = buffer.get();\n                    value += (v & 0x7f) * TWO_POW_21;\n                    if ((v & 0x80) != 0) {\n                        v = buffer.get();\n                        value += (v & 0x7f) * TWO_POW_28;\n                        if ((v & 0x80) != 0) {\n                            v = buffer.get();\n                            value += (v & 0x7f) * TWO_POW_35;\n                            if ((v & 0x80) != 0) {\n                                v = buffer.get();\n                                value += (v & 0x7f) * TWO_POW_42;\n                                if ((v & 0x80) != 0) {\n                                    v = buffer.get();\n                                    value += (v & 0x7f) * TWO_POW_49;\n                                    if ((v & 0x80) != 0) {\n                                        v = buffer.get();\n                                        value += (v & 0x7f) * TWO_POW_56;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (value % 2 === 0) {\n            value = value / 2;\n        }\n        else {\n            value = -(value + 1) / 2;\n        }\n        return value;\n    };\n    return ZigZagEncoding;\n}());\nexports.default = ZigZagEncoding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 24\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_25__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 25\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar formatters_1 = require(\"./formatters\");\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\nvar HistogramLogWriter = /** @class */ (function () {\n    function HistogramLogWriter(log) {\n        this.log = log;\n        /**\n         * Base time to subtract from supplied histogram start/end timestamps when\n         * logging based on histogram timestamps.\n         * Base time is expected to be in msec since the epoch, as histogram start/end times\n         * are typically stamped with absolute times in msec since the epoch.\n         */\n        this.baseTime = 0;\n    }\n    /**\n     * Output an interval histogram, with the given timestamp information and the [optional] tag\n     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n     * specified timestamp information will be used, and the timestamp information in the actual\n     * histogram will be ignored).\n     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n     * @param histogram The interval histogram to log.\n     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n     */\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\n        var start = timeFormatter(startTimeStampSec);\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n        }\n        else {\n            this.log(lineContent);\n        }\n    };\n    /**\n     * Log a comment to the log.\n     * Comments will be preceded with with the '#' character.\n     * @param comment the comment string.\n     */\n    HistogramLogWriter.prototype.outputComment = function (comment) {\n        this.log(\"#\" + comment + \"\\n\");\n    };\n    /**\n     * Log a start time in the log.\n     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n     */\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n    };\n    /**\n     * Output a legend line to the log.\n     */\n    HistogramLogWriter.prototype.outputLegend = function () {\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n    };\n    /**\n     * Output a log format version to the log.\n     */\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n    };\n    return HistogramLogWriter;\n}());\nexports.default = HistogramLogWriter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 27\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\n/**\n * Records integer values, and provides stable interval {@link Histogram} samples from\n * live recorded data without interrupting or stalling active recording of values. Each interval\n * histogram provided contains all value counts accumulated since the previous interval histogram\n * was taken.\n * <p>\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n * <p>\n * {@link Recorder} supports concurrent\n * {@link Recorder#recordValue} or\n * {@link Recorder#recordValueWithExpectedInterval} calls.\n *\n */\nvar Recorder = /** @class */ (function () {\n    /**\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n     *\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n     *                                       decimal digits to which the histogram will maintain value resolution\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\n     * @param packed Specifies whether the recorder will uses a packed internal representation or not.\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\n     */\n    function Recorder(numberOfSignificantValueDigits, packed, clock) {\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n        if (packed === void 0) { packed = false; }\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.packed = packed;\n        this.clock = clock;\n        this.histogramConstr = packed ? PackedHistogram_1.default : Int32Histogram_1.default;\n        this.activeHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n        Recorder.idGenerator++;\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n        this.activeHistogram.startTimeStampMsec = clock();\n    }\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValue = function (value) {\n        this.activeHistogram.recordValue(value);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithCount = function (value, count) {\n        this.activeHistogram.recordValueWithCount(value, count);\n    };\n    /**\n     * Record a value\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n     * for more explanations about coordinated omission and expected interval correction.\n     *      *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    /**\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\n     * accumulated since the last interval histogram was taken.\n     * <p>\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)}\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\n     * {@link Recorder#getIntervalHistogram()} and\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n     * {@code histogramToRecycle} must\n     * be either be null or an interval histogram returned by a previous call to\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} or\n     * {@link Recorder#getIntervalHistogram()}.\n     * <p>\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\n     * <p>\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n     * counts for the next interval\n     *\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n     *                           copy operations.\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n     */\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n        if (histogramToRecycle) {\n            var histogramToRecycleWithId = histogramToRecycle;\n            if (histogramToRecycleWithId.containingInstanceId !==\n                this.activeHistogram.containingInstanceId) {\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n            }\n        }\n        this.inactiveHistogram = histogramToRecycle;\n        this.performIntervalSample();\n        var sampledHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n        return sampledHistogram;\n    };\n    /**\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n     * was taken) into {@code targetHistogram}.\n     *\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n     * the value counts, and start accumulating value counts for the next interval.\n     *\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n     */\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n        this.performIntervalSample();\n        if (this.inactiveHistogram) {\n            targetHistogram.add(this.inactiveHistogram);\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n        }\n    };\n    /**\n     * Reset any value counts accumulated thus far.\n     */\n    Recorder.prototype.reset = function () {\n        this.activeHistogram.reset();\n        this.activeHistogram.startTimeStampMsec = this.clock();\n    };\n    Recorder.prototype.performIntervalSample = function () {\n        if (!this.inactiveHistogram) {\n            this.inactiveHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n        }\n        this.inactiveHistogram.reset();\n        var tempHistogram = this.activeHistogram;\n        this.activeHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = tempHistogram;\n        var currentTimeInMs = this.clock();\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n    };\n    Recorder.idGenerator = 0;\n    return Recorder;\n}());\nexports.default = Recorder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 28\n// module chunks = 0"],"sourceRoot":""}