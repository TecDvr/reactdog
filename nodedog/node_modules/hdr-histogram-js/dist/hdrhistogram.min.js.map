{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///hdrhistogram.min.js","webpack:///webpack/bootstrap f35eab19b43220a71e45","webpack:///./src/AbstractHistogram.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/encoding.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/PackedHistogram.ts","webpack:///./src/formatters.ts","webpack:///./src/packedarray/ResizeError.ts","webpack:///external \"pako\"","webpack:///./~/base64-js/index.js","webpack:///./src/AbstractHistogram.encoding.ts","webpack:///./src/EncodableHistogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/Recorder.ts","webpack:///./src/SparseArrayHistogram.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///./src/index.ts","webpack:///./src/packedarray/PackedArray.ts","webpack:///./src/packedarray/PackedArrayContext.ts","webpack:///./src/ulp.ts"],"names":["root","factory","exports","module","require","define","amd","hdr","pako","this","__WEBPACK_EXTERNAL_MODULE_10__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","AbstractHistogramBase_1","RecordedValuesIterator_1","PercentileIterator_1","formatters_1","ulp_1","pow","Math","floor","ceil","log2","max","min","AbstractHistogram","_super","lowestDiscernibleValue","highestTrackableValue","numberOfSignificantValueDigits","_this","maxValue","minNonZeroValue","Number","MAX_SAFE_INTEGER","Error","identity","AbstractHistogramBase","identityBuilder","init","updatedMaxValue","internalValue","unitMagnitudeMask","updateMinNonZeroValue","lowestDiscernibleValueRounded","resetMinNonZeroValue","integerToDoubleValueConversionRatio","normalizingIndexOffset","setNormalizingIndexOffset","largestValueWithSingleUnitResolution","unitMagnitude","subBucketCountMagnitude","subBucketHalfCountMagnitude","subBucketCount","subBucketHalfCount","subBucketMask","establishSize","leadingZeroCountBase","percentileIterator","default","recordedValuesIterator","newHighestTrackableValue","countsArrayLength","determineArrayLengthNeeded","bucketCount","getBucketsNeededToCoverValue","getLengthForNumberOfBuckets","numberOfBuckets","lengthNeeded","smallestUntrackableValue","bucketsNeeded","recordValue","recordSingleValue","countsIndex","countsArrayIndex","handleRecordException","incrementCountAtIndex","updateMinAndMax","incrementTotalCount","count","autoResize","resize","addToCountAtIndex","highestEquivalentValue","valueFromIndex","bucketIndex","getBucketIndex","subBucketIndex","getSubBucketIndex","computeCountsArrayIndex","bucketBaseIndex","offsetInBucket","getValueAtPercentile","percentile","requestedPercentile","fpCountAtPercentile","getTotalCount","countAtPercentile","totalToCurrentIndex","i","getCountAtIndex","valueAtIndex","lowestEquivalentValue","valueFromIndexes","index","thisValueBaseLevel","nextNonEquivalentValue","sizeOfEquivalentValueRange","distanceToNextValue","medianEquivalentValue","getMean","reset","totalValue","hasNext","iterationValue","next","valueIteratedTo","countAtValueIteratedTo","getStdDeviation","mean","geometric_deviation_total","deviation","countAddedInThisIterationStep","std_deviation","sqrt","outputPercentileDistribution","percentileTicksPerHalfDistance","outputValueUnitScalingRatio","useCsvFormat","result","iterator","lineFormatter","lastLineFormatter","valueFormatter_1","floatFormatter","percentileFormatter_1","lastFormatter_1","percentileLevelIteratedTo","totalCountToThisValue","valueFormatter_2","percentileFormatter_2","totalCountFormatter_1","integerFormatter","lastFormatter_2","formatter","max_1","intFormatter","totalCount","getEstimatedFootprintInBytes","_getEstimatedFootprintInBytes","recordSingleValueWithExpectedInterval","expectedIntervalBetweenValueSamples","missingValue","recordCountAtValue","addToTotalCount","recordValueWithCount","recordValueWithExpectedInterval","recordValueWithCountAndExpectedInterval","addWhileCorrectingForCoordinatedOmission","otherHistogram","toHistogram","otherValues","v","add","highestRecordableValue","observedOtherTotalCount","otherCount","setTotalCount","otherMaxIndex","startTimeStampMsec","endTimeStampMsec","getCountAtValue","subtract","otherValue","establishInternalTackingValues","lengthToCover","MAX_VALUE","maxIndex","minNonZeroIndex","observedTotalCount","countAtIndex","clearCounts","tag","NO_TAG","AbstractHistogram_1","Int32Histogram","counts","Uint32Array","fill","currentCount","newCount","MIN_SAFE_INTEGER","setCountAtIndex","newCounts","set","length","copyCorrectedForCoordinatedOmission","copy","EncodableHistogram_1","wordSizeInBytes","EncodableHistogram","TWO_POW_32","ByteBuffer","data","position","int32ArrayForConvert","int8ArrayForConvert","Uint8Array","buffer","allocate","size","put","oldArray","putInt32","reverse","putInt64","putArray","array","byteLength","get","getInt32","slice","getInt64","high","low","resetPosition","ByteBuffer_1","Int32Histogram_1","base64","decodeFromCompressedBase64","base64String","histogramConstr","minBarForHighestTrackableValue","toByteArray","trim","decodeFromCompressedByteBuffer","encodeIntoBase64String","histogram","compressionLevel","bufferSize","encodeIntoCompressedByteBuffer","encodedBuffer","fromByteArray","HistogramIterationValue_1","AbstractHistogramIterator","currentIterationValue","resetIterator","savedHistogramTotalRawCount","arrayTotalCount","currentIndex","currentValueAtIndex","nextValueAtIndex","prevValueIteratedTo","totalCountToPrevIndex","totalCountToCurrentIndex","totalValueToCurrentIndex","countAtThisValue","freshSubBucket","exhaustedSubBuckets","reachedIterationLevel","getValueIteratedTo","assign","valueIteratedFrom","totalValueToThisValue","getPercentileIteratedTo","incrementIterationLevel","incrementSubBucket","getPercentileIteratedFrom","PackedArray_1","PackedHistogram","packedCounts","PackedArray","clear","increment","setVirtualLength","getPhysicalLength","leftPadding","input","repeat","padding","integer","fractionDigits","numberFormatter","Intl","NumberFormat","maximumFractionDigits","minimumFractionDigits","useGrouping","float","format","ResizeError","newSize","getLens","b64","len","validLen","indexOf","placeHoldersLen","lens","_byteLength","tmp","arr","Arr","curByte","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","code","fillBufferFromCountsArray","self","countsLimit","srcIndex","zerosCount","ZigZagEncoding_1","encode","encodeIntoByteBuffer","initialPosition","encodingCookie","payloadStartPosition","backupIndex","fillCountsArrayFromSourceBuffer","sourceBuffer","lengthInBytes","V2maxWordSizeInBytes","dstIndex","endPosition","decode","getCookieBase","cookie","getWordSizeInBytesFromCookie","V2EncodingCookieBase","V2CompressedEncodingCookieBase","sizeByte","doDecodeFromByteBuffer","payloadLengthInBytes","lowestTrackableUnitValue","filledLength","findDeflateFunction","eval","error","deflate","findInflateFunction","inflate","doDecodeFromCompressedByteBuffer","initialTargetPosition","lengthOfCompressedContents","uncompressedBuffer","targetBuffer","intermediateUncompressedByteBuffer","uncompressedLength","compressedEncodingCookie","compressionOptions","level","compressedArray","decodeFromByteBuffer","Float64Histogram","Float64Array","HistogramIterationValue","encoding_1","TAG_PREFIX","TAG_PREFIX_LENGTH","HistogramLogReader","logContent","options","_a","lines","splitLines","currentLineIndex","nextIntervalHistogram","rangeStartTimeSec","rangeEndTimeSec","currentLine","startsWith","parseStartTimeFromLine","parseBaseTimeFromLine","includes","tokens","split","firstToken","substring","shift","rawLogTimeStampInSec","rawIntervalLengthSec","base64Histogram","logTimeStampInSec","parseFloat","baseTimeSec","startTimeSec","intervalLengthSec","line","shouldIncludeNoTag","find","listTags","content","tags","filter","map","tagsWithoutDuplicates","Set","from","unshift","HISTOGRAM_LOG_FORMAT_VERSION","timeFormatter","HistogramLogWriter","log","baseTime","outputIntervalHistogram","startTimeStampSec","endTimeStampSec","maxValueUnitRatio","duration","lineContent","outputComment","comment","outputStartTime","startTimeMsec","Date","outputLegend","outputLogFormatVersion","Int16Histogram","Uint16Array","Int8Histogram","AbstractHistogramIterator_1","PercentileIterator","percentileLevelToIterateTo","percentileLevelToIterateFrom","reachedLastRecordedValue","doReset","percentileReportingTicks","currentPercentile","RecordedValuesIterator","visitedIndex","PackedHistogram_1","Recorder","packed","clock","getTime","activeHistogram","idGenerator","containingInstanceId","getIntervalHistogram","histogramToRecycle","histogramToRecycleWithId","inactiveHistogram","performIntervalSample","sampledHistogram","getIntervalHistogramInto","targetHistogram","tempHistogram","currentTimeInMs","SparseArrayHistogram","TWO_POW_7","TWO_POW_14","TWO_POW_21","TWO_POW_28","TWO_POW_35","TWO_POW_42","TWO_POW_49","TWO_POW_56","ZigZagEncoding","Int8Histogram_1","Int16Histogram_1","Float64Histogram_1","SparseArrayHistogram_1","Histogram","HistogramLogReader_1","HistogramLogWriter_1","Recorder_1","defaultRequest","bitBucketSize","build","request","parameters","PackedArrayContext_1","ResizeError_1","NUMBER_OF_SETS","virtualLength","initialPhysicalLength","MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY","arrayContext","PackedArrayContext","newVirtualArrayLength","currentArrayContext","isPacked","determineTopLevelShiftForVirtualLength","getTopLevelShift","copyAndIncreaseSize","byteNum","byteValueAtPackedIndex","getAtUnpackedIndex","packedIndex","getPackedIndex","getAtByteIndex","safeGetPackedIndexgetPackedIndex","setNumber","virtualIndex","ex","resizeArray","remainingValueToAdd","byteShift","addAndGetAtUnpackedIndex","byteToAdd","afterAddByteValue","addAtByteIndex","bytesAlreadySet","valueForNextLevels","setAtUnpackedIndex","packedIndex_1","byteToWrite","setAtByteIndex","physicalLength","getVirtualLength","toString","MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH","SET_0_START_INDEX","LEAF_LEVEL_SHIFT","NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET","NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS","PACKED_ARRAY_GROWTH_INCREMENT","PACKED_ARRAY_GROWTH_FRACTION_POW2","bitCount","n","bits","bitCount32","populatedShortLength","topLevelShift","ArrayBuffer","initArrayViews","byteArray","shortArray","longArray","setAtShortIndex","newPhysicalArrayLength","ctx","populateEquivalentEntriesWithEntriesFromOther","getPopulatedShortLength","getPopulatedLongLength","byteIndex","valueToAdd","newValue","setPopulatedLongLength","newPopulatedLongLength","shortIndex","setAtLongIndex","longIndex","getAtShortIndex","getIndexAtShortIndex","setPackedSlotIndicators","entryIndex","newPackedSlotIndicators","getPackedSlotIndicators","getIndexAtEntrySlot","slot","setIndexAtEntrySlot","newIndexValue","expandArrayIfNeeded","entryLengthInLongs","currentLength","growthIncrement","newEntry","entryLengthInShorts","newEntryIndex","newLeafEntry","consolidateEntry","previousVersionIndex","previousVersionPackedSlotsIndicators","packedSlotsIndicators","insertedSlotMask","slotsBelowBitNumber","insertedSlotIndex","numberOfSlotsInEntry","sourceSlot","targetSlot","indexAtSlot","expandEntry","existingEntryIndex","entryPointerIndex","nextLevelIsLeaf","packedSlotIndicators","numberOfslotsInExpandedEntry","expandedEntryLength","indexOfNewNextLevelEntry","insertedSlotValue","expandedEntryIndex","getRootEntry","insertAsNeeded","indexShift","slotBitNumber","slotMask","slotNumber","sizeMagnitude","eightsSizeMagnitude","multipleOfFourSizeMagnitude","topLevelShiftNeeded","newLength","other","otherEntryIndex","entryIndexPointer","i_1","sizeOfEntry","copyEntriesAtLevelFromOther","otherLevelEntryIndex","levelEntryIndexPointer","otherIndexShift","numberOfSlots","leafEntryIndex","otherNextLevelEntryIndex","lazysetAtUnpackedIndex","incrementAndGetAtUnpackedIndex","nonLeafEntryToString","indentLevel","toHex","numberOfslotsInEntry","nextLevelEntryIndex","leafEntryToString","padStart","ulp","x"],"mappings":"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","file":"hdrhistogram.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_10__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_10__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(25);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogramBase_1 = __webpack_require__(3);\n\tvar RecordedValuesIterator_1 = __webpack_require__(21);\n\tvar PercentileIterator_1 = __webpack_require__(20);\n\tvar formatters_1 = __webpack_require__(8);\n\tvar ulp_1 = __webpack_require__(28);\n\tvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\n\tvar AbstractHistogram = /** @class */ (function (_super) {\n\t    __extends(AbstractHistogram, _super);\n\t    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this) || this;\n\t        _this.maxValue = 0;\n\t        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n\t        // Verify argument validity\n\t        if (lowestDiscernibleValue < 1) {\n\t            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n\t        }\n\t        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n\t            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue ( 2 * \" + lowestDiscernibleValue + \" )\");\n\t        }\n\t        if (numberOfSignificantValueDigits < 0 ||\n\t            numberOfSignificantValueDigits > 5) {\n\t            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n\t        }\n\t        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n\t        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n\t        return _this;\n\t    }\n\t    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n\t        var internalValue = value + this.unitMagnitudeMask;\n\t        this.maxValue = internalValue;\n\t    };\n\t    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n\t        if (value <= this.unitMagnitudeMask) {\n\t            return;\n\t        }\n\t        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n\t            this.lowestDiscernibleValueRounded;\n\t        this.minNonZeroValue = internalValue;\n\t    };\n\t    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n\t        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n\t            this.lowestDiscernibleValueRounded;\n\t        this.minNonZeroValue =\n\t            minNonZeroValue === Number.MAX_SAFE_INTEGER\n\t                ? minNonZeroValue\n\t                : internalValue;\n\t    };\n\t    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n\t        this.lowestDiscernibleValue = lowestDiscernibleValue;\n\t        this.highestTrackableValue = highestTrackableValue;\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n\t        if (normalizingIndexOffset !== 0) {\n\t            this.setNormalizingIndexOffset(normalizingIndexOffset);\n\t        }\n\t        /*\n\t         * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n\t         * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n\t         * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n\t         */\n\t        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n\t        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n\t        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n\t        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n\t        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n\t        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n\t        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n\t        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n\t        this.subBucketHalfCountMagnitude =\n\t            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n\t        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n\t        this.subBucketHalfCount = this.subBucketCount / 2;\n\t        this.subBucketMask =\n\t            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n\t        this.establishSize(highestTrackableValue);\n\t        this.leadingZeroCountBase =\n\t            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n\t        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n\t        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n\t    };\n\t    /**\n\t     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n\t     *\n\t     * <pre>\n\t     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n\t     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n\t     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n\t     * ...\n\t     * </pre>\n\t     *\n\t     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n\t     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n\t     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n\t     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n\t     * values as it has better precision.\n\t     */\n\t    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n\t        // establish counts array length:\n\t        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n\t        // establish exponent range needed to support the trackable value with no overflow:\n\t        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n\t        // establish the new highest trackable value:\n\t        this.highestTrackableValue = newHighestTrackableValue;\n\t    };\n\t    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n\t        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n\t            throw new Error(\"highestTrackableValue (\" +\n\t                highestTrackableValue +\n\t                \") cannot be < (2 * lowestDiscernibleValue)\");\n\t        }\n\t        //determine counts array length needed:\n\t        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n\t        return countsArrayLength;\n\t    };\n\t    /**\n\t     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n\t     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n\t     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n\t     * value if we consider the sub-bucket length to be halved.\n\t     */\n\t    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n\t        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n\t        return lengthNeeded;\n\t    };\n\t    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n\t        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n\t        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n\t        // always have at least 1 bucket\n\t        var bucketsNeeded = 1;\n\t        while (smallestUntrackableValue <= value) {\n\t            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n\t                // TODO check array max size in JavaScript\n\t                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n\t                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n\t                return bucketsNeeded + 1;\n\t            }\n\t            smallestUntrackableValue = smallestUntrackableValue * 2;\n\t            bucketsNeeded++;\n\t        }\n\t        return bucketsNeeded;\n\t    };\n\t    /**\n\t     * Record a value in the histogram\n\t     *\n\t     * @param value The value to be recorded\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValue = function (value) {\n\t        this.recordSingleValue(value);\n\t    };\n\t    AbstractHistogram.prototype.recordSingleValue = function (value) {\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        if (countsIndex >= this.countsArrayLength) {\n\t            this.handleRecordException(1, value);\n\t        }\n\t        else {\n\t            this.incrementCountAtIndex(countsIndex);\n\t        }\n\t        this.updateMinAndMax(value);\n\t        this.incrementTotalCount();\n\t    };\n\t    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n\t        if (!this.autoResize) {\n\t            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n\t        }\n\t        this.resize(value);\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        this.addToCountAtIndex(countsIndex, count);\n\t        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n\t    };\n\t    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n\t        if (value < 0) {\n\t            throw new Error(\"Histogram recorded value cannot be negative.\");\n\t        }\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n\t    };\n\t    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n\t        // TODO\n\t        //assert(subBucketIndex < subBucketCount);\n\t        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n\t        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n\t        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n\t        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n\t        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n\t        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n\t        // However, this works out since we give bucket 0 twice as much space.\n\t        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n\t        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n\t        return bucketBaseIndex + offsetInBucket;\n\t    };\n\t    /**\n\t     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n\t     */\n\t    AbstractHistogram.prototype.getBucketIndex = function (value) {\n\t        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n\t        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n\t        // The mask maps small values to bucket 0.\n\t        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n\t        return max(floor(log2(value)) -\n\t            this.subBucketHalfCountMagnitude -\n\t            this.unitMagnitude, 0);\n\t    };\n\t    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n\t        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n\t        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n\t        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n\t        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n\t        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n\t        // and therefore in the top half of subBucketCount.\n\t        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n\t    };\n\t    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n\t        if (value > this.maxValue) {\n\t            this.updatedMaxValue(value);\n\t        }\n\t        if (value < this.minNonZeroValue && value !== 0) {\n\t            this.updateMinNonZeroValue(value);\n\t        }\n\t    };\n\t    /**\n\t     * Get the value at a given percentile.\n\t     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n\t     * percentage of the overall recorded value entries in the histogram are either smaller than\n\t     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n\t     * entries in the histogram are either larger than or equivalent to.\n\t     * <p>\n\t     * Note that two values are \"equivalent\" in this statement if\n\t     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n\t     *\n\t     * @param percentile  The percentile for which to return the associated value\n\t     * @return The value that the given percentage of the overall recorded value entries in the\n\t     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n\t     * value that all value entries in the histogram are either larger than or equivalent to.\n\t     */\n\t    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n\t        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n\t        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n\t        // of overall recorded values is actually included. However, this must be done with care:\n\t        //\n\t        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n\t        // being 1 ulp larger than the correct integer count for this percentile:\n\t        var fpCountAtPercentile = (requestedPercentile / 100.0) * this.getTotalCount();\n\t        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n\t        // making us skip a count:\n\t        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n\t        1 // Make sure we at least reach the first recorded entry\n\t        );\n\t        var totalToCurrentIndex = 0;\n\t        for (var i = 0; i < this.countsArrayLength; i++) {\n\t            totalToCurrentIndex += this.getCountAtIndex(i);\n\t            if (totalToCurrentIndex >= countAtPercentile) {\n\t                var valueAtIndex = this.valueFromIndex(i);\n\t                return percentile === 0.0\n\t                    ? this.lowestEquivalentValue(valueAtIndex)\n\t                    : this.highestEquivalentValue(valueAtIndex);\n\t            }\n\t        }\n\t        return 0;\n\t    };\n\t    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n\t        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n\t    };\n\t    AbstractHistogram.prototype.valueFromIndex = function (index) {\n\t        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n\t        var subBucketIndex = (index % this.subBucketHalfCount) + this.subBucketHalfCount;\n\t        if (bucketIndex < 0) {\n\t            subBucketIndex -= this.subBucketHalfCount;\n\t            bucketIndex = 0;\n\t        }\n\t        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n\t    };\n\t    /**\n\t     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n\t        return thisValueBaseLevel;\n\t    };\n\t    /**\n\t     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n\t        return this.nextNonEquivalentValue(value) - 1;\n\t    };\n\t    /**\n\t     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n\t        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n\t    };\n\t    /**\n\t     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n\t     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The size of the range of values equivalent to the given value.\n\t     */\n\t    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        var distanceToNextValue = pow(2, this.unitMagnitude +\n\t            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n\t        return distanceToNextValue;\n\t    };\n\t    /**\n\t     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n\t     */\n\t    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n\t        return (this.lowestEquivalentValue(value) +\n\t            floor(this.sizeOfEquivalentValueRange(value) / 2));\n\t    };\n\t    /**\n\t     * Get the computed mean value of all recorded values in the histogram\n\t     *\n\t     * @return the mean value (in value units) of the histogram data\n\t     */\n\t    AbstractHistogram.prototype.getMean = function () {\n\t        if (this.getTotalCount() === 0) {\n\t            return 0;\n\t        }\n\t        this.recordedValuesIterator.reset();\n\t        var totalValue = 0;\n\t        while (this.recordedValuesIterator.hasNext()) {\n\t            var iterationValue = this.recordedValuesIterator.next();\n\t            totalValue +=\n\t                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n\t                    iterationValue.countAtValueIteratedTo;\n\t        }\n\t        return (totalValue * 1.0) / this.getTotalCount();\n\t    };\n\t    /**\n\t     * Get the computed standard deviation of all recorded values in the histogram\n\t     *\n\t     * @return the standard deviation (in value units) of the histogram data\n\t     */\n\t    AbstractHistogram.prototype.getStdDeviation = function () {\n\t        if (this.getTotalCount() === 0) {\n\t            return 0;\n\t        }\n\t        var mean = this.getMean();\n\t        var geometric_deviation_total = 0.0;\n\t        this.recordedValuesIterator.reset();\n\t        while (this.recordedValuesIterator.hasNext()) {\n\t            var iterationValue = this.recordedValuesIterator.next();\n\t            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n\t            geometric_deviation_total +=\n\t                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n\t        }\n\t        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n\t        return std_deviation;\n\t    };\n\t    /**\n\t     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n\t     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n\t     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n\t     *\n\t     * @param printStream    Stream into which the distribution will be output\n\t     * <p>\n\t     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n\t     * <p>\n\t     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n\t     *                                     output\n\t     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n\t     */\n\t    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n\t        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n\t        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n\t        if (useCsvFormat === void 0) { useCsvFormat = false; }\n\t        var result = \"\";\n\t        if (useCsvFormat) {\n\t            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n\t        }\n\t        else {\n\t            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n\t        }\n\t        var iterator = this.percentileIterator;\n\t        iterator.reset(percentileTicksPerHalfDistance);\n\t        var lineFormatter;\n\t        var lastLineFormatter;\n\t        if (useCsvFormat) {\n\t            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n\t            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n\t            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n\t            lineFormatter = function (iterationValue) {\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \",\" +\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \",\" +\n\t                    iterationValue.totalCountToThisValue +\n\t                    \",\" +\n\t                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n\t                    \"\\n\";\n\t            };\n\t            lastLineFormatter = function (iterationValue) {\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \",\" +\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \",\" +\n\t                    iterationValue.totalCountToThisValue +\n\t                    \",Infinity\\n\";\n\t            };\n\t        }\n\t        else {\n\t            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n\t            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n\t            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n\t            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n\t            lineFormatter = function (iterationValue) {\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \" \" +\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \" \" +\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n\t                    \" \" +\n\t                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n\t                    \"\\n\";\n\t            };\n\t            lastLineFormatter = function (iterationValue) {\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \" \" +\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \" \" +\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n\t                    \"\\n\";\n\t            };\n\t        }\n\t        while (iterator.hasNext()) {\n\t            var iterationValue = iterator.next();\n\t            if (iterationValue.percentileLevelIteratedTo < 100) {\n\t                result += lineFormatter(iterationValue);\n\t            }\n\t            else {\n\t                result += lastLineFormatter(iterationValue);\n\t            }\n\t        }\n\t        if (!useCsvFormat) {\n\t            // Calculate and output mean and std. deviation.\n\t            // Note: mean/std. deviation numbers are very often completely irrelevant when\n\t            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n\t            // response time distribution associated with GC pauses). However, reporting these numbers\n\t            // can be very useful for contrasting with the detailed percentile distribution\n\t            // reported by outputPercentileDistribution(). It is not at all surprising to find\n\t            // percentile distributions where results fall many tens or even hundreds of standard\n\t            // deviations away from the mean - such results simply indicate that the data sampled\n\t            // exhibits a very non-normal distribution, highlighting situations for which the std.\n\t            // deviation metric is a useless indicator.\n\t            //\n\t            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n\t            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n\t            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n\t            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n\t            var intFormatter = formatters_1.integerFormatter(12);\n\t            var totalCount = intFormatter(this.getTotalCount());\n\t            var bucketCount = intFormatter(this.bucketCount);\n\t            var subBucketCount = intFormatter(this.subBucketCount);\n\t            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n\t        }\n\t        return result;\n\t    };\n\t    /**\n\t     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n\t     *\n\t     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n\t     */\n\t    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n\t        return this._getEstimatedFootprintInBytes();\n\t    };\n\t    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.recordSingleValue(value);\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\n\t            return;\n\t        }\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n\t            this.recordSingleValue(missingValue);\n\t        }\n\t    };\n\t    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        if (countsIndex >= this.countsArrayLength) {\n\t            this.handleRecordException(count, value);\n\t        }\n\t        else {\n\t            this.addToCountAtIndex(countsIndex, count);\n\t        }\n\t        this.updateMinAndMax(value);\n\t        this.addToTotalCount(count);\n\t    };\n\t    /**\n\t     * Record a value in the histogram (adding to the value's current count)\n\t     *\n\t     * @param value The value to be recorded\n\t     * @param count The number of occurrences of this value to record\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n\t        this.recordCountAtValue(count, value);\n\t    };\n\t    /**\n\t     * Record a value in the histogram.\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\n\t     * <p>\n\t     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n\t     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n\t     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n\t     * for the same coordinated omission issue.\n\t     * <p>\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n\t     * important.\n\t     *\n\t     * @param value The value to record\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n\t    };\n\t    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n\t        this.recordCountAtValue(count, value);\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\n\t            return;\n\t        }\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n\t            this.recordCountAtValue(count, missingValue);\n\t        }\n\t    };\n\t    /**\n\t     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, the values added will include an auto-generated additional series of\n\t     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n\t     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n\t     *\n\t     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n\t     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n\t     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n\t     * for the same coordinated omission issue.\n\t     * by\n\t     * <p>\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n\t     * important.\n\t     *\n\t     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n\t        var toHistogram = this;\n\t        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n\t        while (otherValues.hasNext()) {\n\t            var v = otherValues.next();\n\t            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n\t        }\n\t    };\n\t    /**\n\t     * Add the contents of another histogram to this one.\n\t     * <p>\n\t     * As part of adding the contents, the start/end timestamp range of this histogram will be\n\t     * extended to include the start/end timestamp range of the other histogram.\n\t     *\n\t     * @param otherHistogram The other histogram.\n\t     * @throws (may throw) if values in fromHistogram's are\n\t     * higher than highestTrackableValue.\n\t     */\n\t    AbstractHistogram.prototype.add = function (otherHistogram) {\n\t        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\n\t            if (!this.autoResize) {\n\t                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n\t            }\n\t            this.resize(otherHistogram.maxValue);\n\t        }\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n\t            var observedOtherTotalCount = 0;\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.addToCountAtIndex(i, otherCount);\n\t                    observedOtherTotalCount += otherCount;\n\t                }\n\t            }\n\t            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n\t            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n\t            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n\t        }\n\t        else {\n\t            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n\t            // so we can't just stream through and add them. Instead, go through the array and add each\n\t            // non-zero value found at it's proper value:\n\t            // Do max value first, to avoid max value updates on each iteration:\n\t            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n\t            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n\t            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n\t            // Record the remaining values, up to but not including the max value:\n\t            for (var i = 0; i < otherMaxIndex; i++) {\n\t                otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n\t                }\n\t            }\n\t        }\n\t        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n\t        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n\t    };\n\t    /**\n\t     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n\t     *\n\t     * @param value The value for which to provide the recorded count\n\t     * @return The total count of values recorded in the histogram within the value range that is\n\t     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n\t     */\n\t    AbstractHistogram.prototype.getCountAtValue = function (value) {\n\t        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n\t        return this.getCountAtIndex(index);\n\t    };\n\t    /**\n\t     * Subtract the contents of another histogram from this one.\n\t     * <p>\n\t     * The start/end timestamps of this histogram will remain unchanged.\n\t     *\n\t     * @param otherHistogram The other histogram.\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n\t     *\n\t     */\n\t    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n\t        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\n\t            if (!this.autoResize) {\n\t                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n\t            }\n\t            this.resize(otherHistogram.maxValue);\n\t        }\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\n\t            // optim\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.addToCountAtIndex(i, -otherCount);\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    var otherValue = otherHistogram.valueFromIndex(i);\n\t                    if (this.getCountAtValue(otherValue) < otherCount) {\n\t                        throw new Error(\"otherHistogram count (\" +\n\t                            otherCount +\n\t                            \") at value \" +\n\t                            otherValue +\n\t                            \" is larger than this one's (\" +\n\t                            this.getCountAtValue(otherValue) +\n\t                            \")\");\n\t                    }\n\t                    this.recordCountAtValue(-otherCount, otherValue);\n\t                }\n\t            }\n\t        }\n\t        // With subtraction, the max and minNonZero values could have changed:\n\t        if (this.getCountAtValue(this.maxValue) <= 0 ||\n\t            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n\t            this.establishInternalTackingValues();\n\t        }\n\t    };\n\t    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n\t        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n\t        this.maxValue = 0;\n\t        this.minNonZeroValue = Number.MAX_VALUE;\n\t        var maxIndex = -1;\n\t        var minNonZeroIndex = -1;\n\t        var observedTotalCount = 0;\n\t        for (var index = 0; index < lengthToCover; index++) {\n\t            var countAtIndex = this.getCountAtIndex(index);\n\t            if (countAtIndex > 0) {\n\t                observedTotalCount += countAtIndex;\n\t                maxIndex = index;\n\t                if (minNonZeroIndex == -1 && index != 0) {\n\t                    minNonZeroIndex = index;\n\t                }\n\t            }\n\t        }\n\t        if (maxIndex >= 0) {\n\t            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n\t        }\n\t        if (minNonZeroIndex >= 0) {\n\t            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n\t        }\n\t        this.setTotalCount(observedTotalCount);\n\t    };\n\t    AbstractHistogram.prototype.reset = function () {\n\t        this.clearCounts();\n\t        this.setTotalCount(0);\n\t        this.startTimeStampMsec = 0;\n\t        this.endTimeStampMsec = 0;\n\t        this.tag = AbstractHistogramBase_1.NO_TAG;\n\t        this.maxValue = 0;\n\t        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n\t    };\n\t    return AbstractHistogram;\n\t}(AbstractHistogramBase_1.AbstractHistogramBase));\n\texports.AbstractHistogram = AbstractHistogram;\n\texports.default = AbstractHistogram;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int32Histogram = /** @class */ (function (_super) {\n\t    __extends(Int32Histogram, _super);\n\t    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint32Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int32Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint32Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int32Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int32Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int32Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int32Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int32Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 4 * this.counts.length;\n\t    };\n\t    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int32Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int32Histogram;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar EncodableHistogram_1 = __webpack_require__(13);\n\texports.NO_TAG = \"NO TAG\";\n\tvar AbstractHistogramBase = /** @class */ (function (_super) {\n\t    __extends(AbstractHistogramBase, _super);\n\t    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n\t    //intermediateUncompressedByteArray : number[] = null;\n\t    /* useless ?\n\t    getIntegerToDoubleValueConversionRatio(): number {\n\t        return this.integerToDoubleValueConversionRatio;\n\t    }\n\t  \n\t    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n\t    }*/\n\t    function AbstractHistogramBase() {\n\t        var _this = _super.call(this) || this;\n\t        _this.autoResize = false;\n\t        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n\t        _this.endTimeStampMsec = 0;\n\t        _this.tag = exports.NO_TAG;\n\t        _this.integerToDoubleValueConversionRatio = 1.0;\n\t        _this.identity = 0;\n\t        _this.highestTrackableValue = 0;\n\t        _this.lowestDiscernibleValue = 0;\n\t        _this.numberOfSignificantValueDigits = 0;\n\t        _this.bucketCount = 0;\n\t        _this.subBucketCount = 0;\n\t        _this.countsArrayLength = 0;\n\t        _this.wordSizeInBytes = 0;\n\t        return _this;\n\t    }\n\t    return AbstractHistogramBase;\n\t}(EncodableHistogram_1.EncodableHistogram));\n\texports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar pow = Math.pow, floor = Math.floor;\n\tvar TWO_POW_32 = pow(2, 32);\n\t/**\n\t * Mimic Java's ByteBufffer with big endian order\n\t */\n\tvar ByteBuffer = /** @class */ (function () {\n\t    function ByteBuffer(data) {\n\t        this.position = 0;\n\t        this.data = data;\n\t        this.int32ArrayForConvert = new Uint32Array(1);\n\t        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n\t    }\n\t    ByteBuffer.allocate = function (size) {\n\t        if (size === void 0) { size = 16; }\n\t        return new ByteBuffer(new Uint8Array(size));\n\t    };\n\t    ByteBuffer.prototype.put = function (value) {\n\t        if (this.position === this.data.length) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.data.length * 2);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.data[this.position] = value;\n\t        this.position++;\n\t    };\n\t    ByteBuffer.prototype.putInt32 = function (value) {\n\t        if (this.data.length - this.position < 4) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.data.length * 2 + 4);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.int32ArrayForConvert[0] = value;\n\t        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n\t        this.position += 4;\n\t    };\n\t    ByteBuffer.prototype.putInt64 = function (value) {\n\t        this.putInt32(floor(value / TWO_POW_32));\n\t        this.putInt32(value);\n\t    };\n\t    ByteBuffer.prototype.putArray = function (array) {\n\t        if (this.data.length - this.position < array.byteLength) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.position + array.byteLength);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.data.set(array, this.position);\n\t        this.position += array.byteLength;\n\t    };\n\t    ByteBuffer.prototype.get = function () {\n\t        var value = this.data[this.position];\n\t        this.position++;\n\t        return value;\n\t    };\n\t    ByteBuffer.prototype.getInt32 = function () {\n\t        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n\t        var value = this.int32ArrayForConvert[0];\n\t        this.position += 4;\n\t        return value;\n\t    };\n\t    ByteBuffer.prototype.getInt64 = function () {\n\t        var high = this.getInt32();\n\t        var low = this.getInt32();\n\t        return high * TWO_POW_32 + low;\n\t    };\n\t    ByteBuffer.prototype.resetPosition = function () {\n\t        this.position = 0;\n\t    };\n\t    return ByteBuffer;\n\t}());\n\texports.default = ByteBuffer;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(4);\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int32Histogram_1 = __webpack_require__(2);\n\t__webpack_require__(12);\n\tvar base64 = __webpack_require__(11);\n\tvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n\t    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n\t    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n\t    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String.trim()));\n\t    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n\t};\n\texports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\n\tvar encodeIntoBase64String = function (histogram, compressionLevel) {\n\t    var buffer = ByteBuffer_1.default.allocate();\n\t    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n\t    var encodedBuffer = buffer.data.slice(0, bufferSize);\n\t    return base64.fromByteArray(encodedBuffer);\n\t};\n\texports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar HistogramIterationValue_1 = __webpack_require__(15);\n\t/**\n\t * Used for iterating through histogram values.\n\t */\n\tvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n\t    function AbstractHistogramIterator() {\n\t        this.currentIterationValue = new HistogramIterationValue_1.default();\n\t    }\n\t    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n\t        this.histogram = histogram;\n\t        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n\t        this.arrayTotalCount = histogram.getTotalCount();\n\t        this.currentIndex = 0;\n\t        this.currentValueAtIndex = 0;\n\t        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n\t        this.prevValueIteratedTo = 0;\n\t        this.totalCountToPrevIndex = 0;\n\t        this.totalCountToCurrentIndex = 0;\n\t        this.totalValueToCurrentIndex = 0;\n\t        this.countAtThisValue = 0;\n\t        this.freshSubBucket = true;\n\t        this.currentIterationValue.reset();\n\t    };\n\t    /**\n\t     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n\t     * element rather than throwing an exception.)\n\t     *\n\t     * @return true if the iterator has more elements.\n\t     */\n\t    AbstractHistogramIterator.prototype.hasNext = function () {\n\t        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n\t            throw \"Concurrent Modification Exception\";\n\t        }\n\t        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n\t    };\n\t    /**\n\t     * Returns the next element in the iteration.\n\t     *\n\t     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n\t     */\n\t    AbstractHistogramIterator.prototype.next = function () {\n\t        // Move through the sub buckets and buckets until we hit the next reporting level:\n\t        while (!this.exhaustedSubBuckets()) {\n\t            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n\t            if (this.freshSubBucket) {\n\t                // Don't add unless we've incremented since last bucket...\n\t                this.totalCountToCurrentIndex += this.countAtThisValue;\n\t                this.totalValueToCurrentIndex +=\n\t                    this.countAtThisValue *\n\t                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n\t                this.freshSubBucket = false;\n\t            }\n\t            if (this.reachedIterationLevel()) {\n\t                var valueIteratedTo = this.getValueIteratedTo();\n\t                Object.assign(this.currentIterationValue, {\n\t                    valueIteratedTo: valueIteratedTo,\n\t                    valueIteratedFrom: this.prevValueIteratedTo,\n\t                    countAtValueIteratedTo: this.countAtThisValue,\n\t                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n\t                    totalCountToThisValue: this.totalCountToCurrentIndex,\n\t                    totalValueToThisValue: this.totalValueToCurrentIndex,\n\t                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n\t                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n\t                });\n\t                this.prevValueIteratedTo = valueIteratedTo;\n\t                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n\t                this.incrementIterationLevel();\n\t                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n\t                    throw new Error(\"Concurrent Modification Exception\");\n\t                }\n\t                return this.currentIterationValue;\n\t            }\n\t            this.incrementSubBucket();\n\t        }\n\t        throw new Error(\"Index Out Of Bounds Exception\");\n\t    };\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n\t        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n\t    };\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n\t        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n\t    };\n\t    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n\t        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n\t    };\n\t    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n\t        return this.currentIndex >= this.histogram.countsArrayLength;\n\t    };\n\t    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n\t        this.freshSubBucket = true;\n\t        this.currentIndex++;\n\t        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n\t        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n\t    };\n\t    return AbstractHistogramIterator;\n\t}());\n\texports.default = AbstractHistogramIterator;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar PackedArray_1 = __webpack_require__(26);\n\t/**\n\t * <h3>A High Dynamic Range (HDR) Histogram that uses a packed internal representation</h3>\n\t * <p>\n\t * {@link PackedHistogram} supports the recording and analyzing sampled data value counts across a configurable\n\t * integer value range with configurable value precision within the range. Value precision is expressed as the\n\t * number of significant digits in the value recording, and provides control over value quantization behavior\n\t * across the value range and the subsequent value resolution at any given level.\n\t * <p>\n\t * {@link PackedHistogram} tracks value counts in a packed internal representation optimized\n\t * for typical histogram recoded values are sparse in the value range and tend to be incremented in small unit counts.\n\t * This packed representation tends to require significantly smaller amounts of stoarge when compared to unpacked\n\t * representations, but can incur additional recording cost due to resizing and repacking operations that may\n\t * occur as previously unrecorded values are encountered.\n\t * <p>\n\t * For example, a {@link PackedHistogram} could be configured to track the counts of observed integer values between 0 and\n\t * 3,600,000,000,000 while maintaining a value precision of 3 significant digits across that range. Value quantization\n\t * within the range will thus be no larger than 1/1,000th (or 0.1%) of any value. This example Histogram could\n\t * be used to track and analyze the counts of observed response times ranging between 1 nanosecond and 1 hour\n\t * in magnitude, while maintaining a value resolution of 1 microsecond up to 1 millisecond, a resolution of\n\t * 1 millisecond (or better) up to one second, and a resolution of 1 second (or better) up to 1,000 seconds. At its\n\t * maximum tracked value (1 hour), it would still maintain a resolution of 3.6 seconds (or better).\n\t * <p>\n\t * Auto-resizing: When constructed with no specified value range range (or when auto-resize is turned on with {@link\n\t * Histogram#setAutoResize}) a {@link PackedHistogram} will auto-resize its dynamic range to include recorded values as\n\t * they are encountered. Note that recording calls that cause auto-resizing may take longer to execute, as resizing\n\t * incurs allocation and copying of internal data structures.\n\t * <p>\n\t */\n\tvar PackedHistogram = /** @class */ (function (_super) {\n\t    __extends(PackedHistogram, _super);\n\t    function PackedHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.packedCounts = new PackedArray_1.PackedArray(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    PackedHistogram.prototype.clearCounts = function () {\n\t        this.packedCounts.clear();\n\t        this.totalCount = 0;\n\t    };\n\t    PackedHistogram.prototype.incrementCountAtIndex = function (index) {\n\t        this.packedCounts.increment(index);\n\t    };\n\t    PackedHistogram.prototype.addToCountAtIndex = function (index, value) {\n\t        this.packedCounts.add(index, value);\n\t    };\n\t    PackedHistogram.prototype.setCountAtIndex = function (index, value) {\n\t        /* TODO move in packed array\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t          throw value + \" would overflow integer count\";\n\t        }*/\n\t        this.packedCounts.set(index, value);\n\t    };\n\t    PackedHistogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        this.packedCounts.setVirtualLength(this.countsArrayLength);\n\t    };\n\t    PackedHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    PackedHistogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    PackedHistogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    PackedHistogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    PackedHistogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    PackedHistogram.prototype.getCountAtIndex = function (index) {\n\t        return this.packedCounts.get(index);\n\t    };\n\t    PackedHistogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 192 + 8 * this.packedCounts.getPhysicalLength();\n\t    };\n\t    PackedHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new PackedHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return PackedHistogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = PackedHistogram;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar leftPadding = function (size) {\n\t    return function (input) {\n\t        if (input.length < size) {\n\t            return \" \".repeat(size - input.length) + input;\n\t        }\n\t        return input;\n\t    };\n\t};\n\texports.integerFormatter = function (size) {\n\t    var padding = leftPadding(size);\n\t    return function (integer) { return padding(\"\" + integer); };\n\t};\n\texports.floatFormatter = function (size, fractionDigits) {\n\t    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n\t        maximumFractionDigits: fractionDigits,\n\t        minimumFractionDigits: fractionDigits,\n\t        useGrouping: false\n\t    });\n\t    var padding = leftPadding(size);\n\t    return function (float) { return padding(numberFormatter.format(float)); };\n\t};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ResizeError = /** @class */ (function () {\n\t    function ResizeError(newSize) {\n\t        this.newSize = newSize;\n\t    }\n\t    return ResizeError;\n\t}());\n\texports.ResizeError = ResizeError;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\t// Support decoding URL-safe base64 strings, as Node.js does.\n\t// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction getLens (b64) {\n\t  var len = b64.length\n\t\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // Trim off extra bytes after placeholder bytes are found\n\t  // See: https://github.com/beatgammit/base64-js/issues/42\n\t  var validLen = b64.indexOf('=')\n\t  if (validLen === -1) validLen = len\n\t\n\t  var placeHoldersLen = validLen === len\n\t    ? 0\n\t    : 4 - (validLen % 4)\n\t\n\t  return [validLen, placeHoldersLen]\n\t}\n\t\n\t// base64 is 4/3 + up to two characters of the original data\n\tfunction byteLength (b64) {\n\t  var lens = getLens(b64)\n\t  var validLen = lens[0]\n\t  var placeHoldersLen = lens[1]\n\t  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n\t}\n\t\n\tfunction _byteLength (b64, validLen, placeHoldersLen) {\n\t  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var tmp\n\t  var lens = getLens(b64)\n\t  var validLen = lens[0]\n\t  var placeHoldersLen = lens[1]\n\t\n\t  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\t\n\t  var curByte = 0\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  var len = placeHoldersLen > 0\n\t    ? validLen - 4\n\t    : validLen\n\t\n\t  var i\n\t  for (i = 0; i < len; i += 4) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 18) |\n\t      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n\t      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n\t      revLookup[b64.charCodeAt(i + 3)]\n\t    arr[curByte++] = (tmp >> 16) & 0xFF\n\t    arr[curByte++] = (tmp >> 8) & 0xFF\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHoldersLen === 2) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 2) |\n\t      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHoldersLen === 1) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 10) |\n\t      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n\t      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[curByte++] = (tmp >> 8) & 0xFF\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] +\n\t    lookup[num >> 12 & 0x3F] +\n\t    lookup[num >> 6 & 0x3F] +\n\t    lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp =\n\t      ((uint8[i] << 16) & 0xFF0000) +\n\t      ((uint8[i + 1] << 8) & 0xFF00) +\n\t      (uint8[i + 2] & 0xFF)\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(\n\t      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n\t    ))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    parts.push(\n\t      lookup[tmp >> 2] +\n\t      lookup[(tmp << 4) & 0x3F] +\n\t      '=='\n\t    )\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n\t    parts.push(\n\t      lookup[tmp >> 10] +\n\t      lookup[(tmp >> 4) & 0x3F] +\n\t      lookup[(tmp << 2) & 0x3F] +\n\t      '='\n\t    )\n\t  }\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(4);\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar ZigZagEncoding_1 = __webpack_require__(24);\n\tvar max = Math.max;\n\tvar V2EncodingCookieBase = 0x1c849303;\n\tvar V2CompressedEncodingCookieBase = 0x1c849304;\n\tvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\n\tvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\n\tvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\n\tfunction fillBufferFromCountsArray(self, buffer) {\n\t    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n\t    var srcIndex = 0;\n\t    while (srcIndex < countsLimit) {\n\t        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n\t        // while negative values indicate a repeat zero counts.\n\t        var count = self.getCountAtIndex(srcIndex++);\n\t        if (count < 0) {\n\t            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n\t                count +\n\t                \") at index \" +\n\t                srcIndex +\n\t                \", corresponding the value range [\" +\n\t                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n\t                \",\" +\n\t                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n\t                \")\");\n\t        }\n\t        // Count trailing 0s (which follow this count):\n\t        var zerosCount = 0;\n\t        if (count == 0) {\n\t            zerosCount = 1;\n\t            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n\t                zerosCount++;\n\t                srcIndex++;\n\t            }\n\t        }\n\t        if (zerosCount > 1) {\n\t            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n\t        }\n\t        else {\n\t            ZigZagEncoding_1.default.encode(buffer, count);\n\t        }\n\t    }\n\t}\n\t/**\n\t * Encode this histogram into a ByteBuffer\n\t * @param buffer The buffer to encode into\n\t * @return The number of bytes written to the buffer\n\t */\n\tfunction encodeIntoByteBuffer(buffer) {\n\t    var self = this;\n\t    var initialPosition = buffer.position;\n\t    buffer.putInt32(encodingCookie);\n\t    buffer.putInt32(0); // Placeholder for payload length in bytes.\n\t    buffer.putInt32(1);\n\t    buffer.putInt32(self.numberOfSignificantValueDigits);\n\t    buffer.putInt64(self.lowestDiscernibleValue);\n\t    buffer.putInt64(self.highestTrackableValue);\n\t    buffer.putInt64(1);\n\t    var payloadStartPosition = buffer.position;\n\t    fillBufferFromCountsArray(self, buffer);\n\t    var backupIndex = buffer.position;\n\t    buffer.position = initialPosition + 4;\n\t    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n\t    buffer.position = backupIndex;\n\t    return backupIndex - initialPosition;\n\t}\n\texports.encodeIntoByteBuffer = encodeIntoByteBuffer;\n\tfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n\t    if (wordSizeInBytes != 2 &&\n\t        wordSizeInBytes != 4 &&\n\t        wordSizeInBytes != 8 &&\n\t        wordSizeInBytes != V2maxWordSizeInBytes) {\n\t        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n\t            V2maxWordSizeInBytes +\n\t            \") bytes\");\n\t    }\n\t    var dstIndex = 0;\n\t    var endPosition = sourceBuffer.position + lengthInBytes;\n\t    while (sourceBuffer.position < endPosition) {\n\t        var zerosCount = 0;\n\t        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n\t        if (count < 0) {\n\t            zerosCount = -count;\n\t            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n\t        }\n\t        else {\n\t            self.setCountAtIndex(dstIndex++, count);\n\t        }\n\t    }\n\t    return dstIndex; // this is the destination length\n\t}\n\tfunction getCookieBase(cookie) {\n\t    return cookie & ~0xf0;\n\t}\n\tfunction getWordSizeInBytesFromCookie(cookie) {\n\t    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n\t        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n\t        return V2maxWordSizeInBytes;\n\t    }\n\t    var sizeByte = (cookie & 0xf0) >> 4;\n\t    return sizeByte & 0xe;\n\t}\n\tfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n\t    var cookie = buffer.getInt32();\n\t    var payloadLengthInBytes;\n\t    var numberOfSignificantValueDigits;\n\t    var lowestTrackableUnitValue;\n\t    var highestTrackableValue;\n\t    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n\t        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n\t            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n\t        }\n\t        payloadLengthInBytes = buffer.getInt32();\n\t        buffer.getInt32(); // normalizingIndexOffset not used\n\t        numberOfSignificantValueDigits = buffer.getInt32();\n\t        lowestTrackableUnitValue = buffer.getInt64();\n\t        highestTrackableValue = buffer.getInt64();\n\t        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n\t    }\n\t    else {\n\t        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n\t    }\n\t    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n\t    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n\t    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n\t    histogram.establishInternalTackingValues(filledLength);\n\t    return histogram;\n\t}\n\texports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\n\tfunction findDeflateFunction() {\n\t    try {\n\t        return eval('require(\"zlib\").deflateSync');\n\t    }\n\t    catch (error) {\n\t        var pako = __webpack_require__(10);\n\t        return pako.deflate;\n\t    }\n\t}\n\tfunction findInflateFunction() {\n\t    try {\n\t        return eval('require(\"zlib\").inflateSync');\n\t    }\n\t    catch (error) {\n\t        var pako = __webpack_require__(10);\n\t        return pako.inflate;\n\t    }\n\t}\n\tvar deflate = findDeflateFunction();\n\tvar inflate = findInflateFunction();\n\tfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n\t    var initialTargetPosition = buffer.position;\n\t    var cookie = buffer.getInt32();\n\t    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n\t        throw new Error(\"Encoding not supported, only V2 is supported\");\n\t    }\n\t    var lengthOfCompressedContents = buffer.getInt32();\n\t    var uncompressedBuffer = inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n\t    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n\t}\n\texports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n\t/**\n\t * Encode this histogram in compressed form into a byte array\n\t * @param targetBuffer The buffer to encode into\n\t * @return The number of bytes written to the array\n\t */\n\tfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n\t    var self = this;\n\t    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n\t    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n\t    targetBuffer.putInt32(compressedEncodingCookie);\n\t    var compressionOptions = compressionLevel\n\t        ? { level: compressionLevel }\n\t        : {};\n\t    var compressedArray = deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n\t    targetBuffer.putInt32(compressedArray.byteLength);\n\t    targetBuffer.putArray(compressedArray);\n\t    return targetBuffer.position;\n\t}\n\texports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar EncodableHistogram = /** @class */ (function () {\n\t    function EncodableHistogram() {\n\t    }\n\t    return EncodableHistogram;\n\t}());\n\texports.EncodableHistogram = EncodableHistogram;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Float64Histogram = /** @class */ (function (_super) {\n\t    __extends(Float64Histogram, _super);\n\t    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Float64Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Float64Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Float64Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Float64Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Float64Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Float64Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Float64Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Float64Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 8 * this.counts.length;\n\t    };\n\t    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Float64Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Float64Histogram;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/**\n\t * Represents a value point iterated through in a Histogram, with associated stats.\n\t * <ul>\n\t * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n\t * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n\t * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n\t * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n\t * range.</li>\n\t * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n\t * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n\t * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n\t * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n\t * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n\t * values equal or smaller than valueIteratedTo.</li>\n\t * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n\t * equal or smaller than valueIteratedTo.</li>\n\t * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n\t * or smaller than valueIteratedTo.</li>\n\t * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n\t * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n\t * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n\t * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n\t * range of multiple percentiles in the requested percentile iteration points).</li>\n\t * </ul>\n\t */\n\tvar HistogramIterationValue = /** @class */ (function () {\n\t    function HistogramIterationValue() {\n\t        this.reset();\n\t    }\n\t    HistogramIterationValue.prototype.reset = function () {\n\t        this.valueIteratedTo = 0;\n\t        this.valueIteratedFrom = 0;\n\t        this.countAtValueIteratedTo = 0;\n\t        this.countAddedInThisIterationStep = 0;\n\t        this.totalCountToThisValue = 0;\n\t        this.totalValueToThisValue = 0;\n\t        this.percentile = 0.0;\n\t        this.percentileLevelIteratedTo = 0.0;\n\t    };\n\t    return HistogramIterationValue;\n\t}());\n\texports.default = HistogramIterationValue;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogramBase_1 = __webpack_require__(3);\n\tvar Int32Histogram_1 = __webpack_require__(2);\n\tvar encoding_1 = __webpack_require__(5);\n\tvar TAG_PREFIX = \"Tag=\";\n\tvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n\t/**\n\t * A histogram log reader.\n\t * <p>\n\t * Histogram logs are used to capture full fidelity, per-time-interval\n\t * histograms of a recorded value.\n\t * <p>\n\t * For example, a histogram log can be used to capture high fidelity\n\t * reaction-time logs for some measured system or subsystem component.\n\t * Such a log would capture a full reaction time histogram for each\n\t * logged interval, and could be used to later reconstruct a full\n\t * HdrHistogram of the measured reaction time behavior for any arbitrary\n\t * time range within the log, by adding [only] the relevant interval\n\t * histograms.\n\t * <h3>Histogram log format:</h3>\n\t * A histogram log file consists of text lines. Lines beginning with\n\t * the \"#\" character are optional and treated as comments. Lines\n\t * containing the legend (starting with \"Timestamp\") are also optional\n\t * and ignored in parsing the histogram log. All other lines must\n\t * be valid interval description lines. Text fields are delimited by\n\t * commas, spaces.\n\t * <p>\n\t * A valid interval description line contains an optional Tag=tagString\n\t * text field, followed by an interval description.\n\t * <p>\n\t * A valid interval description must contain exactly four text fields:\n\t * <ul>\n\t * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n\t * representing the start timestamp of the interval in seconds.</li>\n\t * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n\t * representing the length of the interval in seconds.</li>\n\t * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n\t * which generally represents the maximum value of the interval histogram.</li>\n\t * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n\t * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n\t * </ul>\n\t * The log file may contain an optional indication of a starting time. Starting time\n\t * is indicated using a special comments starting with \"#[StartTime: \" and followed\n\t * by a number parse-able as a double, representing the start time (in seconds)\n\t * that may be added to timestamps in the file to determine an absolute\n\t * timestamp (e.g. since the epoch) for each interval.\n\t */\n\tvar HistogramLogReader = /** @class */ (function () {\n\t    function HistogramLogReader(logContent, options) {\n\t        var _a;\n\t        this.lines = splitLines(logContent);\n\t        this.currentLineIndex = 0;\n\t        this.histogramConstr = ((_a = options) === null || _a === void 0 ? void 0 : _a.histogramConstr) || Int32Histogram_1.default;\n\t    }\n\t    /**\n\t     * Read the next interval histogram from the log. Returns a Histogram object if\n\t     * an interval line was found, or null if not.\n\t     * <p>Upon encountering any unexpected format errors in reading the next interval\n\t     * from the file, this method will return a null.\n\t     * @return a DecodedInterval, or a null if no appropriate interval found\n\t     */\n\t    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n\t        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n\t        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n\t        while (this.currentLineIndex < this.lines.length) {\n\t            var currentLine = this.lines[this.currentLineIndex];\n\t            this.currentLineIndex++;\n\t            if (currentLine.startsWith(\"#[StartTime:\")) {\n\t                this.parseStartTimeFromLine(currentLine);\n\t            }\n\t            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n\t                this.parseBaseTimeFromLine(currentLine);\n\t            }\n\t            else if (currentLine.startsWith(\"#\") ||\n\t                currentLine.startsWith('\"StartTimestamp\"')) {\n\t                // skip legend & meta data for now\n\t            }\n\t            else if (currentLine.includes(\",\")) {\n\t                var tokens = currentLine.split(\",\");\n\t                var firstToken = tokens[0];\n\t                var tag = void 0;\n\t                if (firstToken.startsWith(TAG_PREFIX)) {\n\t                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n\t                    tokens.shift();\n\t                }\n\t                else {\n\t                    tag = AbstractHistogramBase_1.NO_TAG;\n\t                }\n\t                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n\t                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n\t                if (!this.baseTimeSec) {\n\t                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n\t                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n\t                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n\t                        // StartTime), we assume that timestamps in the log are not absolute\n\t                        this.baseTimeSec = this.startTimeSec;\n\t                    }\n\t                    else {\n\t                        // Timestamps are absolute\n\t                        this.baseTimeSec = 0.0;\n\t                    }\n\t                }\n\t                if (rangeEndTimeSec < logTimeStampInSec) {\n\t                    return null;\n\t                }\n\t                if (logTimeStampInSec < rangeStartTimeSec) {\n\t                    continue;\n\t                }\n\t                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram, this.histogramConstr);\n\t                histogram.startTimeStampMsec =\n\t                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n\t                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n\t                histogram.endTimeStampMsec =\n\t                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n\t                histogram.tag = tag;\n\t                return histogram;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n\t        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n\t    };\n\t    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n\t        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n\t    };\n\t    return HistogramLogReader;\n\t}());\n\tvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\n\tvar shouldIncludeNoTag = function (lines) {\n\t    return lines.find(function (line) {\n\t        return !line.startsWith(\"#\") &&\n\t            !line.startsWith('\"') &&\n\t            !line.startsWith(TAG_PREFIX) &&\n\t            line.includes(\",\");\n\t    });\n\t};\n\texports.listTags = function (content) {\n\t    var lines = splitLines(content);\n\t    var tags = lines\n\t        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n\t        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n\t    var tagsWithoutDuplicates = new Set(tags);\n\t    var result = Array.from(tagsWithoutDuplicates);\n\t    if (shouldIncludeNoTag(lines)) {\n\t        result.unshift(\"NO TAG\");\n\t    }\n\t    return result;\n\t};\n\texports.default = HistogramLogReader;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramBase_1 = __webpack_require__(3);\n\tvar encoding_1 = __webpack_require__(5);\n\tvar formatters_1 = __webpack_require__(8);\n\tvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\n\tvar timeFormatter = formatters_1.floatFormatter(5, 3);\n\tvar HistogramLogWriter = /** @class */ (function () {\n\t    function HistogramLogWriter(log) {\n\t        this.log = log;\n\t        /**\n\t         * Base time to subtract from supplied histogram start/end timestamps when\n\t         * logging based on histogram timestamps.\n\t         * Base time is expected to be in msec since the epoch, as histogram start/end times\n\t         * are typically stamped with absolute times in msec since the epoch.\n\t         */\n\t        this.baseTime = 0;\n\t    }\n\t    /**\n\t     * Output an interval histogram, with the given timestamp information and the [optional] tag\n\t     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n\t     * specified timestamp information will be used, and the timestamp information in the actual\n\t     * histogram will be ignored).\n\t     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n\t     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n\t     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n\t     * @param histogram The interval histogram to log.\n\t     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n\t     */\n\t    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n\t        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n\t        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n\t        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n\t        var base64 = encoding_1.encodeIntoBase64String(histogram);\n\t        var start = timeFormatter(startTimeStampSec);\n\t        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n\t        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n\t        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n\t        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n\t            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n\t        }\n\t        else {\n\t            this.log(lineContent);\n\t        }\n\t    };\n\t    /**\n\t     * Log a comment to the log.\n\t     * Comments will be preceded with with the '#' character.\n\t     * @param comment the comment string.\n\t     */\n\t    HistogramLogWriter.prototype.outputComment = function (comment) {\n\t        this.log(\"#\" + comment + \"\\n\");\n\t    };\n\t    /**\n\t     * Log a start time in the log.\n\t     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n\t     */\n\t    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n\t        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n\t    };\n\t    /**\n\t     * Output a legend line to the log.\n\t     */\n\t    HistogramLogWriter.prototype.outputLegend = function () {\n\t        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n\t    };\n\t    /**\n\t     * Output a log format version to the log.\n\t     */\n\t    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n\t        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n\t    };\n\t    return HistogramLogWriter;\n\t}());\n\texports.default = HistogramLogWriter;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int16Histogram = /** @class */ (function (_super) {\n\t    __extends(Int16Histogram, _super);\n\t    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint16Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int16Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint16Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int16Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int16Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int16Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int16Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int16Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 2 * this.counts.length;\n\t    };\n\t    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int16Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int16Histogram;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int8Histogram = /** @class */ (function (_super) {\n\t    __extends(Int8Histogram, _super);\n\t    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint8Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int8Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint8Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int8Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int8Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int8Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int8Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int8Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + this.counts.length;\n\t    };\n\t    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int8Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int8Histogram;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\n\tvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n\t/**\n\t * Used for iterating through histogram values according to percentile levels. The iteration is\n\t * performed in steps that start at 0% and reduce their distance to 100% according to the\n\t * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n\t * values are exhausted.\n\t */\n\tvar PercentileIterator = /** @class */ (function (_super) {\n\t    __extends(PercentileIterator, _super);\n\t    /**\n\t     * @param histogram The histogram this iterator will operate on\n\t     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n\t     */\n\t    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n\t        var _this = _super.call(this) || this;\n\t        _this.percentileTicksPerHalfDistance = 0;\n\t        _this.percentileLevelToIterateTo = 0;\n\t        _this.percentileLevelToIterateFrom = 0;\n\t        _this.reachedLastRecordedValue = false;\n\t        _this.doReset(histogram, percentileTicksPerHalfDistance);\n\t        return _this;\n\t    }\n\t    /**\n\t     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n\t     *\n\t     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n\t     */\n\t    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n\t        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n\t    };\n\t    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n\t        _super.prototype.resetIterator.call(this, histogram);\n\t        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n\t        this.percentileLevelToIterateTo = 0;\n\t        this.percentileLevelToIterateFrom = 0;\n\t        this.reachedLastRecordedValue = false;\n\t    };\n\t    PercentileIterator.prototype.hasNext = function () {\n\t        if (_super.prototype.hasNext.call(this))\n\t            return true;\n\t        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n\t            this.percentileLevelToIterateTo = 100;\n\t            this.reachedLastRecordedValue = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    PercentileIterator.prototype.incrementIterationLevel = function () {\n\t        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n\t        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n\t        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n\t        // make the steps easily comprehensible and readable to humans. The resulting percentile\n\t        // steps are much easier to browse through in a percentile distribution output, for example.\n\t        //\n\t        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n\t        // by at the current scale. The scale is detemined by the percentile level we are\n\t        // iterating to. The following math determines the tick size for the current scale,\n\t        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n\t        // [from either 0% or from the previous half-distance]. When that half-distance is\n\t        // crossed, the scale changes and the tick size is effectively cut in half.\n\t        // percentileTicksPerHalfDistance = 5\n\t        // percentileReportingTicks = 10,\n\t        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n\t            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n\t        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n\t    };\n\t    PercentileIterator.prototype.reachedIterationLevel = function () {\n\t        if (this.countAtThisValue === 0) {\n\t            return false;\n\t        }\n\t        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n\t        return currentPercentile >= this.percentileLevelToIterateTo;\n\t    };\n\t    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n\t        return this.percentileLevelToIterateTo;\n\t    };\n\t    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n\t        return this.percentileLevelToIterateFrom;\n\t    };\n\t    return PercentileIterator;\n\t}(AbstractHistogramIterator_1.default));\n\texports.default = PercentileIterator;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\n\t/**\n\t * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n\t * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n\t * all recorded histogram values are exhausted.\n\t */\n\tvar RecordedValuesIterator = /** @class */ (function (_super) {\n\t    __extends(RecordedValuesIterator, _super);\n\t    /**\n\t     * @param histogram The histogram this iterator will operate on\n\t     */\n\t    function RecordedValuesIterator(histogram) {\n\t        var _this = _super.call(this) || this;\n\t        _this.doReset(histogram);\n\t        return _this;\n\t    }\n\t    /**\n\t     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n\t     */\n\t    RecordedValuesIterator.prototype.reset = function () {\n\t        this.doReset(this.histogram);\n\t    };\n\t    RecordedValuesIterator.prototype.doReset = function (histogram) {\n\t        _super.prototype.resetIterator.call(this, histogram);\n\t        this.visitedIndex = -1;\n\t    };\n\t    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n\t        this.visitedIndex = this.currentIndex;\n\t    };\n\t    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n\t        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n\t        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n\t    };\n\t    return RecordedValuesIterator;\n\t}(AbstractHistogramIterator_1.default));\n\texports.default = RecordedValuesIterator;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar Int32Histogram_1 = __webpack_require__(2);\n\tvar PackedHistogram_1 = __webpack_require__(7);\n\t/**\n\t * Records integer values, and provides stable interval {@link Histogram} samples from\n\t * live recorded data without interrupting or stalling active recording of values. Each interval\n\t * histogram provided contains all value counts accumulated since the previous interval histogram\n\t * was taken.\n\t * <p>\n\t * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n\t * <p>\n\t * {@link Recorder} supports concurrent\n\t * {@link Recorder#recordValue} or\n\t * {@link Recorder#recordValueWithExpectedInterval} calls.\n\t *\n\t */\n\tvar Recorder = /** @class */ (function () {\n\t    /**\n\t     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n\t     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n\t     *\n\t     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n\t     *                                       decimal digits to which the histogram will maintain value resolution\n\t     *                                       and separation. Must be a non-negative integer between 0 and 5.\n\t     * @param packed Specifies whether the recorder will uses a packed internal representation or not.\n\t     * @param clock (for testing purpose) an action that give current time in ms since 1970\n\t     */\n\t    function Recorder(numberOfSignificantValueDigits, packed, clock) {\n\t        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n\t        if (packed === void 0) { packed = false; }\n\t        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n\t        this.packed = packed;\n\t        this.clock = clock;\n\t        this.histogramConstr = packed ? PackedHistogram_1.default : Int32Histogram_1.default;\n\t        this.activeHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n\t        Recorder.idGenerator++;\n\t        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n\t        this.activeHistogram.startTimeStampMsec = clock();\n\t    }\n\t    /**\n\t     * Record a value in the histogram\n\t     *\n\t     * @param value The value to be recorded\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValue = function (value) {\n\t        this.activeHistogram.recordValue(value);\n\t    };\n\t    /**\n\t     * Record a value in the histogram (adding to the value's current count)\n\t     *\n\t     * @param value The value to be recorded\n\t     * @param count The number of occurrences of this value to record\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValueWithCount = function (value, count) {\n\t        this.activeHistogram.recordValueWithCount(value, count);\n\t    };\n\t    /**\n\t     * Record a value\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\n\t     * <p>\n\t     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n\t     * for more explanations about coordinated omission and expected interval correction.\n\t     *      *\n\t     * @param value The value to record\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n\t    };\n\t    /**\n\t     * Get an interval histogram, which will include a stable, consistent view of all value counts\n\t     * accumulated since the last interval histogram was taken.\n\t     * <p>\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)}\n\t     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n\t     * and content copying operations, and is therefore significantly more efficient for repeated use than\n\t     * {@link Recorder#getIntervalHistogram()} and\n\t     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n\t     * {@code histogramToRecycle} must\n\t     * be either be null or an interval histogram returned by a previous call to\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)} or\n\t     * {@link Recorder#getIntervalHistogram()}.\n\t     * <p>\n\t     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n\t     * the same interval histogram instance is recycled more than once, behavior is undefined.\n\t     * <p>\n\t     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n\t     * counts for the next interval\n\t     *\n\t     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n\t     *                           copy operations.\n\t     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n\t     */\n\t    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n\t        if (histogramToRecycle) {\n\t            var histogramToRecycleWithId = histogramToRecycle;\n\t            if (histogramToRecycleWithId.containingInstanceId !==\n\t                this.activeHistogram.containingInstanceId) {\n\t                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n\t            }\n\t        }\n\t        this.inactiveHistogram = histogramToRecycle;\n\t        this.performIntervalSample();\n\t        var sampledHistogram = this.inactiveHistogram;\n\t        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n\t        return sampledHistogram;\n\t    };\n\t    /**\n\t     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n\t     * was taken) into {@code targetHistogram}.\n\t     *\n\t     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n\t     * the value counts, and start accumulating value counts for the next interval.\n\t     *\n\t     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n\t     */\n\t    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n\t        this.performIntervalSample();\n\t        if (this.inactiveHistogram) {\n\t            targetHistogram.add(this.inactiveHistogram);\n\t            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n\t            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n\t        }\n\t    };\n\t    /**\n\t     * Reset any value counts accumulated thus far.\n\t     */\n\t    Recorder.prototype.reset = function () {\n\t        this.activeHistogram.reset();\n\t        this.activeHistogram.startTimeStampMsec = this.clock();\n\t    };\n\t    Recorder.prototype.performIntervalSample = function () {\n\t        if (!this.inactiveHistogram) {\n\t            this.inactiveHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n\t            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n\t        }\n\t        this.inactiveHistogram.reset();\n\t        var tempHistogram = this.activeHistogram;\n\t        this.activeHistogram = this.inactiveHistogram;\n\t        this.inactiveHistogram = tempHistogram;\n\t        var currentTimeInMs = this.clock();\n\t        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n\t        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n\t    };\n\t    Recorder.idGenerator = 0;\n\t    return Recorder;\n\t}());\n\texports.default = Recorder;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar SparseArrayHistogram = /** @class */ (function (_super) {\n\t    __extends(SparseArrayHistogram, _super);\n\t    function SparseArrayHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Array();\n\t        return _this;\n\t    }\n\t    SparseArrayHistogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    SparseArrayHistogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index] || 0;\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    SparseArrayHistogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index] || 0;\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    SparseArrayHistogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    SparseArrayHistogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t    };\n\t    SparseArrayHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    SparseArrayHistogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    SparseArrayHistogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    SparseArrayHistogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    SparseArrayHistogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    SparseArrayHistogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index] || 0;\n\t    };\n\t    SparseArrayHistogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + this.counts.length;\n\t    };\n\t    SparseArrayHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new SparseArrayHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return SparseArrayHistogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = SparseArrayHistogram;\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar pow = Math.pow, floor = Math.floor;\n\tvar TWO_POW_7 = pow(2, 7);\n\tvar TWO_POW_14 = pow(2, 14);\n\tvar TWO_POW_21 = pow(2, 21);\n\tvar TWO_POW_28 = pow(2, 28);\n\tvar TWO_POW_35 = pow(2, 35);\n\tvar TWO_POW_42 = pow(2, 42);\n\tvar TWO_POW_49 = pow(2, 49);\n\tvar TWO_POW_56 = pow(2, 56);\n\t/**\n\t * This class provides encoding and decoding methods for writing and reading\n\t * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n\t * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n\t * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n\t * allows small (closer to zero) negative values to use fewer bytes. Details\n\t * on both LEB128 and ZigZag can be readily found elsewhere.\n\t *\n\t * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n\t * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n\t * value can take up to 10 bytes in the stream, where this variant's encoding\n\t * of a 64 bit values will max out at 9 bytes.\n\t *\n\t * As such, this encoder/decoder should NOT be used for encoding or decoding\n\t * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n\t */\n\tvar ZigZagEncoding = /** @class */ (function () {\n\t    function ZigZagEncoding() {\n\t    }\n\t    /**\n\t     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n\t     * (negative numbers not supported)\n\t     * @param buffer the buffer to write to\n\t     * @param value  the value to write to the buffer\n\t     */\n\t    ZigZagEncoding.encode = function (buffer, value) {\n\t        if (value >= 0) {\n\t            value = value * 2;\n\t        }\n\t        else {\n\t            value = -value * 2 - 1;\n\t        }\n\t        if (value < TWO_POW_7) {\n\t            buffer.put(value);\n\t        }\n\t        else {\n\t            buffer.put(value | 0x80);\n\t            if (value < TWO_POW_14) {\n\t                buffer.put(floor(value / TWO_POW_7));\n\t            }\n\t            else {\n\t                buffer.put(floor(value / TWO_POW_7) | 0x80);\n\t                if (value < TWO_POW_21) {\n\t                    buffer.put(floor(value / TWO_POW_14));\n\t                }\n\t                else {\n\t                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n\t                    if (value < TWO_POW_28) {\n\t                        buffer.put(floor(value / TWO_POW_21));\n\t                    }\n\t                    else {\n\t                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n\t                        if (value < TWO_POW_35) {\n\t                            buffer.put(floor(value / TWO_POW_28));\n\t                        }\n\t                        else {\n\t                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n\t                            if (value < TWO_POW_42) {\n\t                                buffer.put(floor(value / TWO_POW_35));\n\t                            }\n\t                            else {\n\t                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n\t                                if (value < TWO_POW_49) {\n\t                                    buffer.put(floor(value / TWO_POW_42));\n\t                                }\n\t                                else {\n\t                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n\t                                    if (value < TWO_POW_56) {\n\t                                        buffer.put(floor(value / TWO_POW_49));\n\t                                    }\n\t                                    else {\n\t                                        // should not happen\n\t                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n\t                                        buffer.put(floor(value / TWO_POW_56));\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n\t     * (negative numbers not supported)\n\t     * @param buffer the buffer to read from\n\t     * @return the value read from the buffer\n\t     */\n\t    ZigZagEncoding.decode = function (buffer) {\n\t        var v = buffer.get();\n\t        var value = v & 0x7f;\n\t        if ((v & 0x80) != 0) {\n\t            v = buffer.get();\n\t            value += (v & 0x7f) * TWO_POW_7;\n\t            if ((v & 0x80) != 0) {\n\t                v = buffer.get();\n\t                value += (v & 0x7f) * TWO_POW_14;\n\t                if ((v & 0x80) != 0) {\n\t                    v = buffer.get();\n\t                    value += (v & 0x7f) * TWO_POW_21;\n\t                    if ((v & 0x80) != 0) {\n\t                        v = buffer.get();\n\t                        value += (v & 0x7f) * TWO_POW_28;\n\t                        if ((v & 0x80) != 0) {\n\t                            v = buffer.get();\n\t                            value += (v & 0x7f) * TWO_POW_35;\n\t                            if ((v & 0x80) != 0) {\n\t                                v = buffer.get();\n\t                                value += (v & 0x7f) * TWO_POW_42;\n\t                                if ((v & 0x80) != 0) {\n\t                                    v = buffer.get();\n\t                                    value += (v & 0x7f) * TWO_POW_49;\n\t                                    if ((v & 0x80) != 0) {\n\t                                        v = buffer.get();\n\t                                        value += (v & 0x7f) * TWO_POW_56;\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (value % 2 === 0) {\n\t            value = value / 2;\n\t        }\n\t        else {\n\t            value = -(value + 1) / 2;\n\t        }\n\t        return value;\n\t    };\n\t    return ZigZagEncoding;\n\t}());\n\texports.default = ZigZagEncoding;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(4);\n\texports.ByteBuffer = ByteBuffer_1.default;\n\tvar Int8Histogram_1 = __webpack_require__(19);\n\texports.Int8Histogram = Int8Histogram_1.default;\n\tvar Int16Histogram_1 = __webpack_require__(18);\n\texports.Int16Histogram = Int16Histogram_1.default;\n\tvar Int32Histogram_1 = __webpack_require__(2);\n\texports.Int32Histogram = Int32Histogram_1.default;\n\tvar Float64Histogram_1 = __webpack_require__(14);\n\texports.Float64Histogram = Float64Histogram_1.default;\n\tvar PackedHistogram_1 = __webpack_require__(7);\n\texports.PackedHistogram = PackedHistogram_1.default;\n\tvar SparseArrayHistogram_1 = __webpack_require__(23);\n\texports.SparseArrayHistogram = SparseArrayHistogram_1.default;\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\texports.AbstractHistogram = AbstractHistogram_1.default;\n\texports.Histogram = AbstractHistogram_1.default;\n\tvar HistogramLogReader_1 = __webpack_require__(16);\n\texports.HistogramLogReader = HistogramLogReader_1.default;\n\texports.listTags = HistogramLogReader_1.listTags;\n\tvar HistogramLogWriter_1 = __webpack_require__(17);\n\texports.HistogramLogWriter = HistogramLogWriter_1.default;\n\tvar encoding_1 = __webpack_require__(5);\n\texports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\n\texports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\n\tvar Recorder_1 = __webpack_require__(22);\n\texports.Recorder = Recorder_1.default;\n\tvar defaultRequest = {\n\t    bitBucketSize: 32,\n\t    autoResize: true,\n\t    lowestDiscernibleValue: 1,\n\t    highestTrackableValue: 2,\n\t    numberOfSignificantValueDigits: 3\n\t};\n\texports.defaultRequest = defaultRequest;\n\t/*const bigIntAvailable = (() => {\n\t  try {\n\t    eval(\"123n\");\n\t    return true;\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t})();*/\n\tvar build = function (request) {\n\t    if (request === void 0) { request = defaultRequest; }\n\t    var parameters = Object.assign({}, defaultRequest, request);\n\t    var histogramConstr;\n\t    switch (parameters.bitBucketSize) {\n\t        case 8:\n\t            histogramConstr = Int8Histogram_1.default;\n\t            break;\n\t        case 16:\n\t            histogramConstr = Int16Histogram_1.default;\n\t            break;\n\t        case 32:\n\t            histogramConstr = Int32Histogram_1.default;\n\t            break;\n\t        case \"sparse_array\":\n\t            histogramConstr = SparseArrayHistogram_1.default;\n\t            break;\n\t        case \"packed\":\n\t            histogramConstr = PackedHistogram_1.default;\n\t            break;\n\t        default:\n\t            //histogramConstr = bigIntAvailable ? BigIntHistogram : Float64Histogram;\n\t            histogramConstr = Float64Histogram_1.default;\n\t    }\n\t    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n\t    histogram.autoResize = parameters.autoResize;\n\t    return histogram;\n\t};\n\texports.build = build;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar PackedArrayContext_1 = __webpack_require__(27);\n\tvar ResizeError_1 = __webpack_require__(9);\n\tvar NUMBER_OF_SETS = 8;\n\tvar pow = Math.pow, floor = Math.floor;\n\t/**\n\t * A Packed array of signed 64 bit values, and supports {@link #get get()}, {@link #set set()},\n\t * {@link #add add()} and {@link #increment increment()} operations on the logical contents of the array.\n\t *\n\t * An {@link PackedLongArray} Uses {@link PackedArrayContext} to track\n\t * the array's logical contents. Contexts may be switched when a context requires resizing\n\t * to complete logical array operations (get, set, add, increment). Contexts are\n\t * established and used within critical sections in order to facilitate concurrent\n\t * implementors.\n\t *\n\t */\n\tvar PackedArray = /** @class */ (function () {\n\t    function PackedArray(virtualLength, initialPhysicalLength) {\n\t        if (initialPhysicalLength === void 0) { initialPhysicalLength = PackedArrayContext_1.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY; }\n\t        this.arrayContext = new PackedArrayContext_1.PackedArrayContext(virtualLength, initialPhysicalLength);\n\t    }\n\t    PackedArray.prototype.setVirtualLength = function (newVirtualArrayLength) {\n\t        if (newVirtualArrayLength < this.length()) {\n\t            throw new Error(\"Cannot set virtual length, as requested length \" +\n\t                newVirtualArrayLength +\n\t                \" is smaller than the current virtual length \" +\n\t                this.length());\n\t        }\n\t        var currentArrayContext = this.arrayContext;\n\t        if (currentArrayContext.isPacked &&\n\t            currentArrayContext.determineTopLevelShiftForVirtualLength(newVirtualArrayLength) == currentArrayContext.getTopLevelShift()) {\n\t            // No changes to the array context contents is needed. Just change the virtual length.\n\t            currentArrayContext.setVirtualLength(newVirtualArrayLength);\n\t            return;\n\t        }\n\t        this.arrayContext = currentArrayContext.copyAndIncreaseSize(this.getPhysicalLength(), newVirtualArrayLength);\n\t    };\n\t    /**\n\t     * Get value at virtual index in the array\n\t     * @param index the virtual array index\n\t     * @return the array value at the virtual index given\n\t     */\n\t    PackedArray.prototype.get = function (index) {\n\t        var value = 0;\n\t        for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n\t            var byteValueAtPackedIndex = 0;\n\t            // Deal with unpacked context:\n\t            if (!this.arrayContext.isPacked) {\n\t                return this.arrayContext.getAtUnpackedIndex(index);\n\t            }\n\t            // Context is packed:\n\t            var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, false);\n\t            if (packedIndex < 0) {\n\t                return value;\n\t            }\n\t            byteValueAtPackedIndex =\n\t                this.arrayContext.getAtByteIndex(packedIndex) * pow(2, byteNum << 3);\n\t            value += byteValueAtPackedIndex;\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t     * Increment value at a virrual index in the array\n\t     * @param index virtual index of value to increment\n\t     */\n\t    PackedArray.prototype.increment = function (index) {\n\t        this.add(index, 1);\n\t    };\n\t    PackedArray.prototype.safeGetPackedIndexgetPackedIndex = function (setNumber, virtualIndex) {\n\t        do {\n\t            try {\n\t                return this.arrayContext.getPackedIndex(setNumber, virtualIndex, true);\n\t            }\n\t            catch (ex) {\n\t                if (ex instanceof ResizeError_1.ResizeError) {\n\t                    this.arrayContext.resizeArray(ex.newSize);\n\t                }\n\t                else {\n\t                    throw ex;\n\t                }\n\t            }\n\t        } while (true);\n\t    };\n\t    /**\n\t     * Add to a value at a virtual index in the array\n\t     * @param index the virtual index of the value to be added to\n\t     * @param value the value to add\n\t     */\n\t    PackedArray.prototype.add = function (index, value) {\n\t        var remainingValueToAdd = value;\n\t        for (var byteNum = 0, byteShift = 0; byteNum < NUMBER_OF_SETS; byteNum++, byteShift += 8) {\n\t            // Deal with unpacked context:\n\t            if (!this.arrayContext.isPacked) {\n\t                this.arrayContext.addAndGetAtUnpackedIndex(index, value);\n\t                return;\n\t            }\n\t            // Context is packed:\n\t            var packedIndex = this.safeGetPackedIndexgetPackedIndex(byteNum, index);\n\t            var byteToAdd = remainingValueToAdd & 0xff;\n\t            var afterAddByteValue = this.arrayContext.addAtByteIndex(packedIndex, byteToAdd);\n\t            // Reduce remaining value to add by amount just added:\n\t            remainingValueToAdd -= byteToAdd;\n\t            remainingValueToAdd = remainingValueToAdd / pow(2, 8);\n\t            // Account for carry:\n\t            remainingValueToAdd += floor(afterAddByteValue / pow(2, 8));\n\t            if (remainingValueToAdd == 0) {\n\t                return; // nothing to add to higher magnitudes\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Set the value at a virtual index in the array\n\t     * @param index the virtual index of the value to set\n\t     * @param value the value to set\n\t     */\n\t    PackedArray.prototype.set = function (index, value) {\n\t        var bytesAlreadySet = 0;\n\t        do {\n\t            var valueForNextLevels = value;\n\t            try {\n\t                for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n\t                    // Establish context within: critical section\n\t                    // Deal with unpacked context:\n\t                    if (!this.arrayContext.isPacked) {\n\t                        this.arrayContext.setAtUnpackedIndex(index, value);\n\t                        return;\n\t                    }\n\t                    // Context is packed:\n\t                    if (valueForNextLevels == 0) {\n\t                        // Special-case zeros to avoid inflating packed array for no reason\n\t                        var packedIndex_1 = this.arrayContext.getPackedIndex(byteNum, index, false);\n\t                        if (packedIndex_1 < 0) {\n\t                            return; // no need to create entries for zero values if they don't already exist\n\t                        }\n\t                    }\n\t                    // Make sure byte is populated:\n\t                    var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, true);\n\t                    // Determine value to write, and prepare for next levels\n\t                    var byteToWrite = valueForNextLevels & 0xff;\n\t                    valueForNextLevels = floor(valueForNextLevels / pow(2, 8));\n\t                    if (byteNum < bytesAlreadySet) {\n\t                        // We want to avoid writing to the same byte twice when not doing so for the\n\t                        // entire 64 bit value atomically, as doing so opens a race with e.g. concurrent\n\t                        // adders. So dobn't actually write the byte if has been written before.\n\t                        continue;\n\t                    }\n\t                    this.arrayContext.setAtByteIndex(packedIndex, byteToWrite);\n\t                    bytesAlreadySet++;\n\t                }\n\t                return;\n\t            }\n\t            catch (ex) {\n\t                if (ex instanceof ResizeError_1.ResizeError) {\n\t                    this.arrayContext.resizeArray(ex.newSize);\n\t                }\n\t                else {\n\t                    throw ex;\n\t                }\n\t            }\n\t        } while (true);\n\t    };\n\t    /**\n\t     * Get the current physical length (in longs) of the array's backing storage\n\t     * @return the current physical length (in longs) of the array's current backing storage\n\t     */\n\t    PackedArray.prototype.getPhysicalLength = function () {\n\t        return this.arrayContext.physicalLength;\n\t    };\n\t    /**\n\t     * Get the (virtual) length of the array\n\t     * @return the (virtual) length of the array\n\t     */\n\t    PackedArray.prototype.length = function () {\n\t        return this.arrayContext.getVirtualLength();\n\t    };\n\t    /**\n\t     * Clear the array contents\n\t     */\n\t    PackedArray.prototype.clear = function () {\n\t        this.arrayContext.clear();\n\t    };\n\t    PackedArray.prototype.toString = function () {\n\t        var output = \"PackedArray:\\n\";\n\t        output += this.arrayContext.toString();\n\t        return output;\n\t    };\n\t    return PackedArray;\n\t}());\n\texports.PackedArray = PackedArray;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ResizeError_1 = __webpack_require__(9);\n\t/**\n\t * A packed-value, sparse array context used for storing 64 bit signed values.\n\t *\n\t * An array context is optimised for tracking sparsely set (as in mostly zeros) values that tend to not make\n\t * use pof the full 64 bit value range even when they are non-zero. The array context's internal representation\n\t * is such that the packed value at each virtual array index may be represented by 0-8 bytes of actual storage.\n\t *\n\t * An array context encodes the packed values in 8 \"set trees\" with each set tree representing one byte of the\n\t * packed value at the virtual index in question. The {@link #getPackedIndex(int, int, boolean)} method is used\n\t * to look up the byte-index corresponding to the given (set tree) value byte of the given virtual index, and can\n\t * be used to add entries to represent that byte as needed. As a succesful {@link #getPackedIndex(int, int, boolean)}\n\t * may require a resizing of the array, it can throw a {@link ResizeException} to indicate that the requested\n\t * packed index cannot be found or added without a resize of the physical storage.\n\t *\n\t */\n\texports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY = 16;\n\tvar MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH = Math.pow(2, 13) - 1; //(Short.MAX_VALUE / 4);  TODO ALEX why ???\n\tvar SET_0_START_INDEX = 0;\n\tvar NUMBER_OF_SETS = 8;\n\tvar LEAF_LEVEL_SHIFT = 3;\n\tvar NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET = 0;\n\tvar NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS = 1;\n\tvar PACKED_ARRAY_GROWTH_INCREMENT = 16;\n\tvar PACKED_ARRAY_GROWTH_FRACTION_POW2 = 4;\n\tvar pow = Math.pow, ceil = Math.ceil, log2 = Math.log2, max = Math.max;\n\tvar bitCount = function (n) {\n\t    var bits = 0;\n\t    while (n !== 0) {\n\t        bits += bitCount32(n | 0);\n\t        n /= 0x100000000;\n\t    }\n\t    return bits;\n\t};\n\tvar bitCount32 = function (n) {\n\t    n = n - ((n >> 1) & 0x55555555);\n\t    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n\t};\n\tvar PackedArrayContext = /** @class */ (function () {\n\t    function PackedArrayContext(virtualLength, initialPhysicalLength) {\n\t        this.populatedShortLength = 0;\n\t        this.topLevelShift = Number.MAX_VALUE; // Make it non-sensical until properly initialized.\n\t        this.physicalLength = Math.max(initialPhysicalLength, exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY);\n\t        this.isPacked =\n\t            this.physicalLength <= MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH;\n\t        if (!this.isPacked) {\n\t            this.physicalLength = virtualLength;\n\t        }\n\t        this.array = new ArrayBuffer(this.physicalLength * 8);\n\t        this.initArrayViews(this.array);\n\t        this.init(virtualLength);\n\t    }\n\t    PackedArrayContext.prototype.initArrayViews = function (array) {\n\t        this.byteArray = new Uint8Array(array);\n\t        this.shortArray = new Uint16Array(array);\n\t        this.longArray = new Float64Array(array);\n\t    };\n\t    PackedArrayContext.prototype.init = function (virtualLength) {\n\t        if (!this.isPacked) {\n\t            // Deal with non-packed context init:\n\t            this.virtualLength = virtualLength;\n\t            return;\n\t        }\n\t        this.populatedShortLength = SET_0_START_INDEX + 8;\n\t        // Populate empty root entries, and point to them from the root indexes:\n\t        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n\t            this.setAtShortIndex(SET_0_START_INDEX + i, 0);\n\t        }\n\t        this.setVirtualLength(virtualLength);\n\t    };\n\t    PackedArrayContext.prototype.clear = function () {\n\t        this.byteArray.fill(0);\n\t    };\n\t    PackedArrayContext.prototype.copyAndIncreaseSize = function (newPhysicalArrayLength, newVirtualArrayLength) {\n\t        var ctx = new PackedArrayContext(newVirtualArrayLength, newPhysicalArrayLength);\n\t        if (this.isPacked) {\n\t            ctx.populateEquivalentEntriesWithEntriesFromOther(this);\n\t        }\n\t        return ctx;\n\t    };\n\t    PackedArrayContext.prototype.getPopulatedShortLength = function () {\n\t        return this.populatedShortLength;\n\t    };\n\t    PackedArrayContext.prototype.getPopulatedLongLength = function () {\n\t        return (this.getPopulatedShortLength() + 3) >> 2; // round up\n\t    };\n\t    PackedArrayContext.prototype.setAtByteIndex = function (byteIndex, value) {\n\t        this.byteArray[byteIndex] = value;\n\t    };\n\t    PackedArrayContext.prototype.getAtByteIndex = function (byteIndex) {\n\t        return this.byteArray[byteIndex];\n\t    };\n\t    /**\n\t     * add a byte value to a current byte value in the array\n\t     * @param byteIndex index of byte value to add to\n\t     * @param valueToAdd byte value to add\n\t     * @return the afterAddValue. ((afterAddValue & 0x100) != 0) indicates a carry.\n\t     */\n\t    PackedArrayContext.prototype.addAtByteIndex = function (byteIndex, valueToAdd) {\n\t        var newValue = this.byteArray[byteIndex] + valueToAdd;\n\t        this.byteArray[byteIndex] = newValue;\n\t        return newValue;\n\t    };\n\t    PackedArrayContext.prototype.setPopulatedLongLength = function (newPopulatedLongLength) {\n\t        this.populatedShortLength = newPopulatedLongLength << 2;\n\t    };\n\t    PackedArrayContext.prototype.getVirtualLength = function () {\n\t        return this.virtualLength;\n\t    };\n\t    PackedArrayContext.prototype.length = function () {\n\t        return this.physicalLength;\n\t    };\n\t    PackedArrayContext.prototype.setAtShortIndex = function (shortIndex, value) {\n\t        this.shortArray[shortIndex] = value;\n\t    };\n\t    PackedArrayContext.prototype.setAtLongIndex = function (longIndex, value) {\n\t        this.longArray[longIndex] = value;\n\t    };\n\t    PackedArrayContext.prototype.getAtShortIndex = function (shortIndex) {\n\t        return this.shortArray[shortIndex];\n\t    };\n\t    PackedArrayContext.prototype.getIndexAtShortIndex = function (shortIndex) {\n\t        return this.shortArray[shortIndex];\n\t    };\n\t    PackedArrayContext.prototype.setPackedSlotIndicators = function (entryIndex, newPackedSlotIndicators) {\n\t        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, newPackedSlotIndicators);\n\t    };\n\t    PackedArrayContext.prototype.getPackedSlotIndicators = function (entryIndex) {\n\t        return (this.shortArray[entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET] &\n\t            0xffff);\n\t    };\n\t    PackedArrayContext.prototype.getIndexAtEntrySlot = function (entryIndex, slot) {\n\t        return this.getAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot);\n\t    };\n\t    PackedArrayContext.prototype.setIndexAtEntrySlot = function (entryIndex, slot, newIndexValue) {\n\t        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot, newIndexValue);\n\t    };\n\t    PackedArrayContext.prototype.expandArrayIfNeeded = function (entryLengthInLongs) {\n\t        var currentLength = this.length();\n\t        if (currentLength < this.getPopulatedLongLength() + entryLengthInLongs) {\n\t            var growthIncrement = max(entryLengthInLongs, PACKED_ARRAY_GROWTH_INCREMENT, this.getPopulatedLongLength() >> PACKED_ARRAY_GROWTH_FRACTION_POW2);\n\t            throw new ResizeError_1.ResizeError(currentLength + growthIncrement);\n\t        }\n\t    };\n\t    PackedArrayContext.prototype.newEntry = function (entryLengthInShorts) {\n\t        // Add entry at the end of the array:\n\t        var newEntryIndex = this.populatedShortLength;\n\t        this.expandArrayIfNeeded((entryLengthInShorts >> 2) + 1);\n\t        this.populatedShortLength = newEntryIndex + entryLengthInShorts;\n\t        for (var i = 0; i < entryLengthInShorts; i++) {\n\t            this.setAtShortIndex(newEntryIndex + i, -1); // Poison value -1. Must be overriden before reads\n\t        }\n\t        return newEntryIndex;\n\t    };\n\t    PackedArrayContext.prototype.newLeafEntry = function () {\n\t        // Add entry at the end of the array:\n\t        var newEntryIndex;\n\t        newEntryIndex = this.getPopulatedLongLength();\n\t        this.expandArrayIfNeeded(1);\n\t        this.setPopulatedLongLength(newEntryIndex + 1);\n\t        this.setAtLongIndex(newEntryIndex, 0);\n\t        return newEntryIndex;\n\t    };\n\t    /**\n\t     * Consolidate entry with previous entry verison if one exists\n\t     *\n\t     * @param entryIndex The shortIndex of the entry to be consolidated\n\t     * @param previousVersionIndex the index of the previous version of the entry\n\t     */\n\t    PackedArrayContext.prototype.consolidateEntry = function (entryIndex, previousVersionIndex) {\n\t        var previousVersionPackedSlotsIndicators = this.getPackedSlotIndicators(previousVersionIndex);\n\t        // Previous version exists, needs consolidation\n\t        var packedSlotsIndicators = this.getPackedSlotIndicators(entryIndex);\n\t        var insertedSlotMask = packedSlotsIndicators ^ previousVersionPackedSlotsIndicators; // the only bit that differs\n\t        var slotsBelowBitNumber = packedSlotsIndicators & (insertedSlotMask - 1);\n\t        var insertedSlotIndex = bitCount(slotsBelowBitNumber);\n\t        var numberOfSlotsInEntry = bitCount(packedSlotsIndicators);\n\t        // Copy the entry slots from previous version, skipping the newly inserted slot in the target:\n\t        var sourceSlot = 0;\n\t        for (var targetSlot = 0; targetSlot < numberOfSlotsInEntry; targetSlot++) {\n\t            if (targetSlot !== insertedSlotIndex) {\n\t                var indexAtSlot = this.getIndexAtEntrySlot(previousVersionIndex, sourceSlot);\n\t                if (indexAtSlot !== 0) {\n\t                    this.setIndexAtEntrySlot(entryIndex, targetSlot, indexAtSlot);\n\t                }\n\t                sourceSlot++;\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Expand entry as indicated.\n\t     *\n\t     * @param existingEntryIndex the index of the entry\n\t     * @param entryPointerIndex  index to the slot pointing to the entry (needs to be fixed up)\n\t     * @param insertedSlotIndex  realtive [packed] index of slot being inserted into entry\n\t     * @param insertedSlotMask   mask value fo slot being inserted\n\t     * @param nextLevelIsLeaf    the level below this one is a leaf level\n\t     * @return the updated index of the entry (-1 if epansion failed due to conflict)\n\t     * @throws RetryException if expansion fails due to concurrent conflict, and caller should try again.\n\t     */\n\t    PackedArrayContext.prototype.expandEntry = function (existingEntryIndex, entryPointerIndex, insertedSlotIndex, insertedSlotMask, nextLevelIsLeaf) {\n\t        var packedSlotIndicators = this.getAtShortIndex(existingEntryIndex) & 0xffff;\n\t        packedSlotIndicators |= insertedSlotMask;\n\t        var numberOfslotsInExpandedEntry = bitCount(packedSlotIndicators);\n\t        if (insertedSlotIndex >= numberOfslotsInExpandedEntry) {\n\t            throw new Error(\"inserted slot index is out of range given provided masks\");\n\t        }\n\t        var expandedEntryLength = numberOfslotsInExpandedEntry + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS;\n\t        // Create new next-level entry to refer to from slot at this level:\n\t        var indexOfNewNextLevelEntry = 0;\n\t        if (nextLevelIsLeaf) {\n\t            indexOfNewNextLevelEntry = this.newLeafEntry(); // Establish long-index to new leaf entry\n\t        }\n\t        else {\n\t            // TODO: Optimize this by creating the whole sub-tree here, rather than a step that will immediaterly expand\n\t            // Create a new 1 word (empty, no slots set) entry for the next level:\n\t            indexOfNewNextLevelEntry = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS); // Establish short-index to new leaf entry\n\t            this.setPackedSlotIndicators(indexOfNewNextLevelEntry, 0);\n\t        }\n\t        var insertedSlotValue = indexOfNewNextLevelEntry;\n\t        var expandedEntryIndex = this.newEntry(expandedEntryLength);\n\t        // populate the packed indicators word:\n\t        this.setPackedSlotIndicators(expandedEntryIndex, packedSlotIndicators);\n\t        // Populate the inserted slot with the index of the new next level entry:\n\t        this.setIndexAtEntrySlot(expandedEntryIndex, insertedSlotIndex, insertedSlotValue);\n\t        this.setAtShortIndex(entryPointerIndex, expandedEntryIndex);\n\t        this.consolidateEntry(expandedEntryIndex, existingEntryIndex);\n\t        return expandedEntryIndex;\n\t    };\n\t    //\n\t    //   ######   ######## ########    ##     ##    ###    ##             ## #### ##    ## ########  ######## ##     ##\n\t    //  ##    ##  ##          ##       ##     ##   ## ##   ##            ##   ##  ###   ## ##     ## ##        ##   ##\n\t    //  ##        ##          ##       ##     ##  ##   ##  ##           ##    ##  ####  ## ##     ## ##         ## ##\n\t    //  ##   #### ######      ##       ##     ## ##     ## ##          ##     ##  ## ## ## ##     ## ######      ###\n\t    //  ##    ##  ##          ##        ##   ##  ######### ##         ##      ##  ##  #### ##     ## ##         ## ##\n\t    //  ##    ##  ##          ##         ## ##   ##     ## ##        ##       ##  ##   ### ##     ## ##        ##   ##\n\t    //   ######   ########    ##          ###    ##     ## ######## ##       #### ##    ## ########  ######## ##     ##\n\t    //\n\t    PackedArrayContext.prototype.getRootEntry = function (setNumber, insertAsNeeded) {\n\t        if (insertAsNeeded === void 0) { insertAsNeeded = false; }\n\t        var entryPointerIndex = SET_0_START_INDEX + setNumber;\n\t        var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n\t        if (entryIndex == 0) {\n\t            if (!insertAsNeeded) {\n\t                return 0; // Index does not currently exist in packed array;\n\t            }\n\t            entryIndex = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS);\n\t            // Create a new empty (no slots set) entry for the next level:\n\t            this.setPackedSlotIndicators(entryIndex, 0);\n\t            this.setAtShortIndex(entryPointerIndex, entryIndex);\n\t        }\n\t        return entryIndex;\n\t    };\n\t    /**\n\t     * Get the byte-index (into the packed array) corresponding to a given (set tree) value byte of given virtual index.\n\t     * Inserts new set tree nodes as needed if indicated.\n\t     *\n\t     * @param setNumber      The set tree number (0-7, 0 corresponding with the LSByte set tree)\n\t     * @param virtualIndex   The virtual index into the PackedArray\n\t     * @param insertAsNeeded If true, will insert new set tree nodes as needed if they do not already exist\n\t     * @return the byte-index corresponding to the given (set tree) value byte of the given virtual index\n\t     */\n\t    PackedArrayContext.prototype.getPackedIndex = function (setNumber, virtualIndex, insertAsNeeded) {\n\t        if (virtualIndex >= this.virtualLength) {\n\t            throw new Error(\"Attempting access at index \" + virtualIndex + \", beyond virtualLength \" + this.virtualLength);\n\t        }\n\t        var entryPointerIndex = SET_0_START_INDEX + setNumber; // TODO init needed ?\n\t        var entryIndex = this.getRootEntry(setNumber, insertAsNeeded);\n\t        if (entryIndex == 0) {\n\t            return -1; // Index does not currently exist in packed array;\n\t        }\n\t        // Work down the levels of non-leaf entries:\n\t        for (var indexShift = this.topLevelShift; indexShift >= LEAF_LEVEL_SHIFT; indexShift -= 4) {\n\t            var nextLevelIsLeaf = indexShift === LEAF_LEVEL_SHIFT;\n\t            // Target is a packedSlotIndicators entry\n\t            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n\t            var slotBitNumber = (virtualIndex / pow(2, indexShift)) & 0xf; //(virtualIndex >>> indexShift) & 0xf;\n\t            var slotMask = 1 << slotBitNumber;\n\t            var slotsBelowBitNumber = packedSlotIndicators & (slotMask - 1);\n\t            var slotNumber = bitCount(slotsBelowBitNumber);\n\t            if ((packedSlotIndicators & slotMask) === 0) {\n\t                // The entryIndex slot does not have the contents we want\n\t                if (!insertAsNeeded) {\n\t                    return -1; // Index does not currently exist in packed array;\n\t                }\n\t                // Expand the entry, adding the index to new entry at the proper slot:\n\t                entryIndex = this.expandEntry(entryIndex, entryPointerIndex, slotNumber, slotMask, nextLevelIsLeaf);\n\t            }\n\t            // Next level's entry pointer index is in the appropriate slot in in the entries array in this entry:\n\t            entryPointerIndex =\n\t                entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slotNumber;\n\t            entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n\t        }\n\t        // entryIndex is the long-index of a leaf entry that contains the value byte for the given set\n\t        var byteIndex = (entryIndex << 3) + (virtualIndex & 0x7); // Determine byte index offset within leaf entry\n\t        return byteIndex;\n\t    };\n\t    PackedArrayContext.prototype.determineTopLevelShiftForVirtualLength = function (virtualLength) {\n\t        var sizeMagnitude = ceil(log2(virtualLength));\n\t        var eightsSizeMagnitude = sizeMagnitude - 3;\n\t        var multipleOfFourSizeMagnitude = ceil(eightsSizeMagnitude / 4) * 4;\n\t        multipleOfFourSizeMagnitude = max(multipleOfFourSizeMagnitude, 8);\n\t        var topLevelShiftNeeded = multipleOfFourSizeMagnitude - 4 + 3;\n\t        return topLevelShiftNeeded;\n\t    };\n\t    PackedArrayContext.prototype.setVirtualLength = function (virtualLength) {\n\t        if (!this.isPacked) {\n\t            throw new Error(\"Should never be adjusting the virtual size of a non-packed context\");\n\t        }\n\t        this.topLevelShift = this.determineTopLevelShiftForVirtualLength(virtualLength);\n\t        this.virtualLength = virtualLength;\n\t    };\n\t    PackedArrayContext.prototype.getTopLevelShift = function () {\n\t        return this.topLevelShift;\n\t    };\n\t    //\n\t    //  ##     ##         ########   #######  ########  ##     ## ##          ###    ######## ########\n\t    //   ##   ##          ##     ## ##     ## ##     ## ##     ## ##         ## ##      ##    ##\n\t    //    ## ##           ##     ## ##     ## ##     ## ##     ## ##        ##   ##     ##    ##\n\t    //     ###    ####### ########  ##     ## ########  ##     ## ##       ##     ##    ##    ######\n\t    //    ## ##           ##        ##     ## ##        ##     ## ##       #########    ##    ##\n\t    //   ##   ##          ##        ##     ## ##        ##     ## ##       ##     ##    ##    ##\n\t    //  ##     ##         ##         #######  ##         #######  ######## ##     ##    ##    ########\n\t    //\n\t    PackedArrayContext.prototype.resizeArray = function (newLength) {\n\t        var tmp = new Uint8Array(newLength * 8);\n\t        tmp.set(this.byteArray);\n\t        this.array = tmp.buffer;\n\t        this.initArrayViews(this.array);\n\t        this.physicalLength = newLength;\n\t    };\n\t    PackedArrayContext.prototype.populateEquivalentEntriesWithEntriesFromOther = function (other) {\n\t        if (this.virtualLength < other.getVirtualLength()) {\n\t            throw new Error(\"Cannot populate array of smaller virtual length\");\n\t        }\n\t        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n\t            var otherEntryIndex = other.getAtShortIndex(SET_0_START_INDEX + i);\n\t            if (otherEntryIndex == 0)\n\t                continue; // No tree to duplicate\n\t            var entryIndexPointer = SET_0_START_INDEX + i;\n\t            for (var i_1 = this.topLevelShift; i_1 > other.topLevelShift; i_1 -= 4) {\n\t                // for each inserted level:\n\t                // Allocate entry in other:\n\t                var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + 1;\n\t                var newEntryIndex = this.newEntry(sizeOfEntry);\n\t                // Link new level in.\n\t                this.setAtShortIndex(entryIndexPointer, newEntryIndex);\n\t                // Populate new level entry, use pointer to slot 0 as place to populate under:\n\t                this.setPackedSlotIndicators(newEntryIndex, 0x1); // Slot 0 populated\n\t                entryIndexPointer =\n\t                    newEntryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS; // Where the slot 0 index goes.\n\t            }\n\t            this.copyEntriesAtLevelFromOther(other, otherEntryIndex, entryIndexPointer, other.topLevelShift);\n\t        }\n\t    };\n\t    PackedArrayContext.prototype.copyEntriesAtLevelFromOther = function (other, otherLevelEntryIndex, levelEntryIndexPointer, otherIndexShift) {\n\t        var nextLevelIsLeaf = otherIndexShift == LEAF_LEVEL_SHIFT;\n\t        var packedSlotIndicators = other.getPackedSlotIndicators(otherLevelEntryIndex);\n\t        var numberOfSlots = bitCount(packedSlotIndicators);\n\t        var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + numberOfSlots;\n\t        var entryIndex = this.newEntry(sizeOfEntry);\n\t        this.setAtShortIndex(levelEntryIndexPointer, entryIndex);\n\t        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, packedSlotIndicators);\n\t        for (var i = 0; i < numberOfSlots; i++) {\n\t            if (nextLevelIsLeaf) {\n\t                // Make leaf in other:\n\t                var leafEntryIndex = this.newLeafEntry();\n\t                this.setIndexAtEntrySlot(entryIndex, i, leafEntryIndex);\n\t                // OPTIM\n\t                // avoid iteration on all the values of the source ctx\n\t                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n\t                this.longArray[leafEntryIndex] =\n\t                    other.longArray[otherNextLevelEntryIndex];\n\t            }\n\t            else {\n\t                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n\t                this.copyEntriesAtLevelFromOther(other, otherNextLevelEntryIndex, entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + i, otherIndexShift - 4);\n\t            }\n\t        }\n\t    };\n\t    PackedArrayContext.prototype.getAtUnpackedIndex = function (index) {\n\t        return this.longArray[index];\n\t    };\n\t    PackedArrayContext.prototype.setAtUnpackedIndex = function (index, newValue) {\n\t        this.longArray[index] = newValue;\n\t    };\n\t    PackedArrayContext.prototype.lazysetAtUnpackedIndex = function (index, newValue) {\n\t        this.longArray[index] = newValue;\n\t    };\n\t    PackedArrayContext.prototype.incrementAndGetAtUnpackedIndex = function (index) {\n\t        this.longArray[index]++;\n\t        return this.longArray[index];\n\t    };\n\t    PackedArrayContext.prototype.addAndGetAtUnpackedIndex = function (index, valueToAdd) {\n\t        this.longArray[index] += valueToAdd;\n\t        return this.longArray[index];\n\t    };\n\t    //\n\t    //   ########  #######           ######  ######## ########  #### ##    ##  ######\n\t    //      ##    ##     ##         ##    ##    ##    ##     ##  ##  ###   ## ##    ##\n\t    //      ##    ##     ##         ##          ##    ##     ##  ##  ####  ## ##\n\t    //      ##    ##     ## #######  ######     ##    ########   ##  ## ## ## ##   ####\n\t    //      ##    ##     ##               ##    ##    ##   ##    ##  ##  #### ##    ##\n\t    //      ##    ##     ##         ##    ##    ##    ##    ##   ##  ##   ### ##    ##\n\t    //      ##     #######           ######     ##    ##     ## #### ##    ##  ######\n\t    //\n\t    PackedArrayContext.prototype.nonLeafEntryToString = function (entryIndex, indexShift, indentLevel) {\n\t        var output = \"\";\n\t        for (var i = 0; i < indentLevel; i++) {\n\t            output += \"  \";\n\t        }\n\t        try {\n\t            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n\t            output += \"slotIndiators: 0x\" + toHex(packedSlotIndicators) + \", prevVersionIndex: 0: [ \";\n\t            var numberOfslotsInEntry = bitCount(packedSlotIndicators);\n\t            for (var i = 0; i < numberOfslotsInEntry; i++) {\n\t                output += this.getIndexAtEntrySlot(entryIndex, i);\n\t                if (i < numberOfslotsInEntry - 1) {\n\t                    output += \", \";\n\t                }\n\t            }\n\t            output += \" ] (indexShift = \" + indexShift + \")\\n\";\n\t            var nextLevelIsLeaf = indexShift == LEAF_LEVEL_SHIFT;\n\t            for (var i = 0; i < numberOfslotsInEntry; i++) {\n\t                var nextLevelEntryIndex = this.getIndexAtEntrySlot(entryIndex, i);\n\t                if (nextLevelIsLeaf) {\n\t                    output += this.leafEntryToString(nextLevelEntryIndex, indentLevel + 4);\n\t                }\n\t                else {\n\t                    output += this.nonLeafEntryToString(nextLevelEntryIndex, indexShift - 4, indentLevel + 4);\n\t                }\n\t            }\n\t        }\n\t        catch (ex) {\n\t            output += \"Exception thrown at nonLeafEnty at index \" + entryIndex + \" with indexShift \" + indexShift + \"\\n\";\n\t        }\n\t        return output;\n\t    };\n\t    PackedArrayContext.prototype.leafEntryToString = function (entryIndex, indentLevel) {\n\t        var output = \"\";\n\t        for (var i = 0; i < indentLevel; i++) {\n\t            output += \"  \";\n\t        }\n\t        try {\n\t            output += \"Leaf bytes : \";\n\t            for (var i = 0; i < 8; i++) {\n\t                output += \"0x\" + toHex(this.byteArray[entryIndex * 8 + i]) + \" \";\n\t            }\n\t            output += \"\\n\";\n\t        }\n\t        catch (ex) {\n\t            output += \"Exception thrown at leafEnty at index \" + entryIndex + \"\\n\";\n\t        }\n\t        return output;\n\t    };\n\t    PackedArrayContext.prototype.toString = function () {\n\t        var output = \"PackedArrayContext:\\n\";\n\t        if (!this.isPacked) {\n\t            return output + \"Context is unpacked:\\n\"; // unpackedToString();\n\t        }\n\t        for (var setNumber = 0; setNumber < NUMBER_OF_SETS; setNumber++) {\n\t            try {\n\t                var entryPointerIndex = SET_0_START_INDEX + setNumber;\n\t                var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n\t                output += \"Set \" + setNumber + \": root = \" + entryIndex + \" \\n\";\n\t                if (entryIndex == 0)\n\t                    continue;\n\t                output += this.nonLeafEntryToString(entryIndex, this.topLevelShift, 4);\n\t            }\n\t            catch (ex) {\n\t                output += \"Exception thrown in set \" + setNumber + \"%d\\n\";\n\t            }\n\t        }\n\t        //output += recordedValuesToString();\n\t        return output;\n\t    };\n\t    return PackedArrayContext;\n\t}());\n\texports.PackedArrayContext = PackedArrayContext;\n\tvar toHex = function (n) {\n\t    return Number(n)\n\t        .toString(16)\n\t        .padStart(2, \"0\");\n\t};\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\n\texports.default = ulp;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// hdrhistogram.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f35eab19b43220a71e45","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\nvar formatters_1 = require(\"./formatters\");\nvar ulp_1 = require(\"./ulp\");\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\nvar AbstractHistogram = /** @class */ (function (_super) {\n    __extends(AbstractHistogram, _super);\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this) || this;\n        _this.maxValue = 0;\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n        // Verify argument validity\n        if (lowestDiscernibleValue < 1) {\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n        }\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue ( 2 * \" + lowestDiscernibleValue + \" )\");\n        }\n        if (numberOfSignificantValueDigits < 0 ||\n            numberOfSignificantValueDigits > 5) {\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n        }\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n        return _this;\n    }\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n        var internalValue = value + this.unitMagnitudeMask;\n        this.maxValue = internalValue;\n    };\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n        if (value <= this.unitMagnitudeMask) {\n            return;\n        }\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue = internalValue;\n    };\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue =\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\n                ? minNonZeroValue\n                : internalValue;\n    };\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\n        this.highestTrackableValue = highestTrackableValue;\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n        if (normalizingIndexOffset !== 0) {\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\n        }\n        /*\n         * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n         * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n         * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n         */\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n        this.subBucketHalfCountMagnitude =\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n        this.subBucketHalfCount = this.subBucketCount / 2;\n        this.subBucketMask =\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n        this.establishSize(highestTrackableValue);\n        this.leadingZeroCountBase =\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n    };\n    /**\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n     *\n     * <pre>\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n     * ...\n     * </pre>\n     *\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n     * values as it has better precision.\n     */\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n        // establish counts array length:\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n        // establish exponent range needed to support the trackable value with no overflow:\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n        // establish the new highest trackable value:\n        this.highestTrackableValue = newHighestTrackableValue;\n    };\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue (\" +\n                highestTrackableValue +\n                \") cannot be < (2 * lowestDiscernibleValue)\");\n        }\n        //determine counts array length needed:\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n        return countsArrayLength;\n    };\n    /**\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n     * value if we consider the sub-bucket length to be halved.\n     */\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n        return lengthNeeded;\n    };\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n        // always have at least 1 bucket\n        var bucketsNeeded = 1;\n        while (smallestUntrackableValue <= value) {\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n                // TODO check array max size in JavaScript\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n                return bucketsNeeded + 1;\n            }\n            smallestUntrackableValue = smallestUntrackableValue * 2;\n            bucketsNeeded++;\n        }\n        return bucketsNeeded;\n    };\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValue = function (value) {\n        this.recordSingleValue(value);\n    };\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(1, value);\n        }\n        else {\n            this.incrementCountAtIndex(countsIndex);\n        }\n        this.updateMinAndMax(value);\n        this.incrementTotalCount();\n    };\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n        if (!this.autoResize) {\n            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n        }\n        this.resize(value);\n        var countsIndex = this.countsArrayIndex(value);\n        this.addToCountAtIndex(countsIndex, count);\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n    };\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n        if (value < 0) {\n            throw new Error(\"Histogram recorded value cannot be negative.\");\n        }\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n    };\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n        // TODO\n        //assert(subBucketIndex < subBucketCount);\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n        // However, this works out since we give bucket 0 twice as much space.\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n        return bucketBaseIndex + offsetInBucket;\n    };\n    /**\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n     */\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n        // The mask maps small values to bucket 0.\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n        return max(floor(log2(value)) -\n            this.subBucketHalfCountMagnitude -\n            this.unitMagnitude, 0);\n    };\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n        // and therefore in the top half of subBucketCount.\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n    };\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n        if (value > this.maxValue) {\n            this.updatedMaxValue(value);\n        }\n        if (value < this.minNonZeroValue && value !== 0) {\n            this.updateMinNonZeroValue(value);\n        }\n    };\n    /**\n     * Get the value at a given percentile.\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n     * percentage of the overall recorded value entries in the histogram are either smaller than\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n     * entries in the histogram are either larger than or equivalent to.\n     * <p>\n     * Note that two values are \"equivalent\" in this statement if\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n     *\n     * @param percentile  The percentile for which to return the associated value\n     * @return The value that the given percentage of the overall recorded value entries in the\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n     * value that all value entries in the histogram are either larger than or equivalent to.\n     */\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n        // of overall recorded values is actually included. However, this must be done with care:\n        //\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n        // being 1 ulp larger than the correct integer count for this percentile:\n        var fpCountAtPercentile = (requestedPercentile / 100.0) * this.getTotalCount();\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n        // making us skip a count:\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n        1 // Make sure we at least reach the first recorded entry\n        );\n        var totalToCurrentIndex = 0;\n        for (var i = 0; i < this.countsArrayLength; i++) {\n            totalToCurrentIndex += this.getCountAtIndex(i);\n            if (totalToCurrentIndex >= countAtPercentile) {\n                var valueAtIndex = this.valueFromIndex(i);\n                return percentile === 0.0\n                    ? this.lowestEquivalentValue(valueAtIndex)\n                    : this.highestEquivalentValue(valueAtIndex);\n            }\n        }\n        return 0;\n    };\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n    };\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n        var subBucketIndex = (index % this.subBucketHalfCount) + this.subBucketHalfCount;\n        if (bucketIndex < 0) {\n            subBucketIndex -= this.subBucketHalfCount;\n            bucketIndex = 0;\n        }\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n    };\n    /**\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n        return thisValueBaseLevel;\n    };\n    /**\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n        return this.nextNonEquivalentValue(value) - 1;\n    };\n    /**\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n    };\n    /**\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The size of the range of values equivalent to the given value.\n     */\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var distanceToNextValue = pow(2, this.unitMagnitude +\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n        return distanceToNextValue;\n    };\n    /**\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n     */\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) +\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\n    };\n    /**\n     * Get the computed mean value of all recorded values in the histogram\n     *\n     * @return the mean value (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getMean = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        this.recordedValuesIterator.reset();\n        var totalValue = 0;\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            totalValue +=\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n                    iterationValue.countAtValueIteratedTo;\n        }\n        return (totalValue * 1.0) / this.getTotalCount();\n    };\n    /**\n     * Get the computed standard deviation of all recorded values in the histogram\n     *\n     * @return the standard deviation (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getStdDeviation = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        var mean = this.getMean();\n        var geometric_deviation_total = 0.0;\n        this.recordedValuesIterator.reset();\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n            geometric_deviation_total +=\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n        }\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n        return std_deviation;\n    };\n    /**\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n     *\n     * @param printStream    Stream into which the distribution will be output\n     * <p>\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n     * <p>\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n     *                                     output\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n     */\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\n        var result = \"\";\n        if (useCsvFormat) {\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n        }\n        else {\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n        }\n        var iterator = this.percentileIterator;\n        iterator.reset(percentileTicksPerHalfDistance);\n        var lineFormatter;\n        var lastLineFormatter;\n        if (useCsvFormat) {\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",\" +\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",Infinity\\n\";\n            };\n        }\n        else {\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \" \" +\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \"\\n\";\n            };\n        }\n        while (iterator.hasNext()) {\n            var iterationValue = iterator.next();\n            if (iterationValue.percentileLevelIteratedTo < 100) {\n                result += lineFormatter(iterationValue);\n            }\n            else {\n                result += lastLineFormatter(iterationValue);\n            }\n        }\n        if (!useCsvFormat) {\n            // Calculate and output mean and std. deviation.\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n            // response time distribution associated with GC pauses). However, reporting these numbers\n            // can be very useful for contrasting with the detailed percentile distribution\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\n            // percentile distributions where results fall many tens or even hundreds of standard\n            // deviations away from the mean - such results simply indicate that the data sampled\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\n            // deviation metric is a useless indicator.\n            //\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n            var intFormatter = formatters_1.integerFormatter(12);\n            var totalCount = intFormatter(this.getTotalCount());\n            var bucketCount = intFormatter(this.bucketCount);\n            var subBucketCount = intFormatter(this.subBucketCount);\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n        }\n        return result;\n    };\n    /**\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n     *\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n     */\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n        return this._getEstimatedFootprintInBytes();\n    };\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValue(value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordSingleValue(missingValue);\n        }\n    };\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(count, value);\n        }\n        else {\n            this.addToCountAtIndex(countsIndex, count);\n        }\n        this.updateMinAndMax(value);\n        this.addToTotalCount(count);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n        this.recordCountAtValue(count, value);\n    };\n    /**\n     * Record a value in the histogram.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n        this.recordCountAtValue(count, value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordCountAtValue(count, missingValue);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, the values added will include an auto-generated additional series of\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n     *\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * by\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n     */\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n        var toHistogram = this;\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n        while (otherValues.hasNext()) {\n            var v = otherValues.next();\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one.\n     * <p>\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\n     * extended to include the start/end timestamp range of the other histogram.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws (may throw) if values in fromHistogram's are\n     * higher than highestTrackableValue.\n     */\n    AbstractHistogram.prototype.add = function (otherHistogram) {\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            var observedOtherTotalCount = 0;\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, otherCount);\n                    observedOtherTotalCount += otherCount;\n                }\n            }\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n        }\n        else {\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n            // so we can't just stream through and add them. Instead, go through the array and add each\n            // non-zero value found at it's proper value:\n            // Do max value first, to avoid max value updates on each iteration:\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n            // Record the remaining values, up to but not including the max value:\n            for (var i = 0; i < otherMaxIndex; i++) {\n                otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n                }\n            }\n        }\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n    };\n    /**\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n     *\n     * @param value The value for which to provide the recorded count\n     * @return The total count of values recorded in the histogram within the value range that is\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n     */\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n        return this.getCountAtIndex(index);\n    };\n    /**\n     * Subtract the contents of another histogram from this one.\n     * <p>\n     * The start/end timestamps of this histogram will remain unchanged.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n     *\n     */\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // optim\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, -otherCount);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    var otherValue = otherHistogram.valueFromIndex(i);\n                    if (this.getCountAtValue(otherValue) < otherCount) {\n                        throw new Error(\"otherHistogram count (\" +\n                            otherCount +\n                            \") at value \" +\n                            otherValue +\n                            \" is larger than this one's (\" +\n                            this.getCountAtValue(otherValue) +\n                            \")\");\n                    }\n                    this.recordCountAtValue(-otherCount, otherValue);\n                }\n            }\n        }\n        // With subtraction, the max and minNonZero values could have changed:\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n            this.establishInternalTackingValues();\n        }\n    };\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_VALUE;\n        var maxIndex = -1;\n        var minNonZeroIndex = -1;\n        var observedTotalCount = 0;\n        for (var index = 0; index < lengthToCover; index++) {\n            var countAtIndex = this.getCountAtIndex(index);\n            if (countAtIndex > 0) {\n                observedTotalCount += countAtIndex;\n                maxIndex = index;\n                if (minNonZeroIndex == -1 && index != 0) {\n                    minNonZeroIndex = index;\n                }\n            }\n        }\n        if (maxIndex >= 0) {\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n        }\n        if (minNonZeroIndex >= 0) {\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n        }\n        this.setTotalCount(observedTotalCount);\n    };\n    AbstractHistogram.prototype.reset = function () {\n        this.clearCounts();\n        this.setTotalCount(0);\n        this.startTimeStampMsec = 0;\n        this.endTimeStampMsec = 0;\n        this.tag = AbstractHistogramBase_1.NO_TAG;\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n    };\n    return AbstractHistogram;\n}(AbstractHistogramBase_1.AbstractHistogramBase));\nexports.AbstractHistogram = AbstractHistogram;\nexports.default = AbstractHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram = /** @class */ (function (_super) {\n    __extends(Int32Histogram, _super);\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint32Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int32Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint32Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int32Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int32Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int32Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int32Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 4 * this.counts.length;\n    };\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int32Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int32Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\nexports.NO_TAG = \"NO TAG\";\nvar AbstractHistogramBase = /** @class */ (function (_super) {\n    __extends(AbstractHistogramBase, _super);\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n    //intermediateUncompressedByteArray : number[] = null;\n    /* useless ?\n    getIntegerToDoubleValueConversionRatio(): number {\n        return this.integerToDoubleValueConversionRatio;\n    }\n  \n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n    }*/\n    function AbstractHistogramBase() {\n        var _this = _super.call(this) || this;\n        _this.autoResize = false;\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n        _this.endTimeStampMsec = 0;\n        _this.tag = exports.NO_TAG;\n        _this.integerToDoubleValueConversionRatio = 1.0;\n        _this.identity = 0;\n        _this.highestTrackableValue = 0;\n        _this.lowestDiscernibleValue = 0;\n        _this.numberOfSignificantValueDigits = 0;\n        _this.bucketCount = 0;\n        _this.subBucketCount = 0;\n        _this.countsArrayLength = 0;\n        _this.wordSizeInBytes = 0;\n        return _this;\n    }\n    return AbstractHistogramBase;\n}(EncodableHistogram_1.EncodableHistogram));\nexports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_32 = pow(2, 32);\n/**\n * Mimic Java's ByteBufffer with big endian order\n */\nvar ByteBuffer = /** @class */ (function () {\n    function ByteBuffer(data) {\n        this.position = 0;\n        this.data = data;\n        this.int32ArrayForConvert = new Uint32Array(1);\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n    }\n    ByteBuffer.allocate = function (size) {\n        if (size === void 0) { size = 16; }\n        return new ByteBuffer(new Uint8Array(size));\n    };\n    ByteBuffer.prototype.put = function (value) {\n        if (this.position === this.data.length) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2);\n            this.data.set(oldArray);\n        }\n        this.data[this.position] = value;\n        this.position++;\n    };\n    ByteBuffer.prototype.putInt32 = function (value) {\n        if (this.data.length - this.position < 4) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2 + 4);\n            this.data.set(oldArray);\n        }\n        this.int32ArrayForConvert[0] = value;\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n        this.position += 4;\n    };\n    ByteBuffer.prototype.putInt64 = function (value) {\n        this.putInt32(floor(value / TWO_POW_32));\n        this.putInt32(value);\n    };\n    ByteBuffer.prototype.putArray = function (array) {\n        if (this.data.length - this.position < array.byteLength) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.position + array.byteLength);\n            this.data.set(oldArray);\n        }\n        this.data.set(array, this.position);\n        this.position += array.byteLength;\n    };\n    ByteBuffer.prototype.get = function () {\n        var value = this.data[this.position];\n        this.position++;\n        return value;\n    };\n    ByteBuffer.prototype.getInt32 = function () {\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n        var value = this.int32ArrayForConvert[0];\n        this.position += 4;\n        return value;\n    };\n    ByteBuffer.prototype.getInt64 = function () {\n        var high = this.getInt32();\n        var low = this.getInt32();\n        return high * TWO_POW_32 + low;\n    };\n    ByteBuffer.prototype.resetPosition = function () {\n        this.position = 0;\n    };\n    return ByteBuffer;\n}());\nexports.default = ByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nrequire(\"./AbstractHistogram.encoding\");\nvar base64 = require(\"base64-js\");\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String.trim()));\n    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n};\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\n    var buffer = ByteBuffer_1.default.allocate();\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\n    return base64.fromByteArray(encodedBuffer);\n};\nexports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\n/**\n * Used for iterating through histogram values.\n */\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n    function AbstractHistogramIterator() {\n        this.currentIterationValue = new HistogramIterationValue_1.default();\n    }\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n        this.histogram = histogram;\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n        this.arrayTotalCount = histogram.getTotalCount();\n        this.currentIndex = 0;\n        this.currentValueAtIndex = 0;\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n        this.prevValueIteratedTo = 0;\n        this.totalCountToPrevIndex = 0;\n        this.totalCountToCurrentIndex = 0;\n        this.totalValueToCurrentIndex = 0;\n        this.countAtThisValue = 0;\n        this.freshSubBucket = true;\n        this.currentIterationValue.reset();\n    };\n    /**\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n     * element rather than throwing an exception.)\n     *\n     * @return true if the iterator has more elements.\n     */\n    AbstractHistogramIterator.prototype.hasNext = function () {\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n            throw \"Concurrent Modification Exception\";\n        }\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n    };\n    /**\n     * Returns the next element in the iteration.\n     *\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n     */\n    AbstractHistogramIterator.prototype.next = function () {\n        // Move through the sub buckets and buckets until we hit the next reporting level:\n        while (!this.exhaustedSubBuckets()) {\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n            if (this.freshSubBucket) {\n                // Don't add unless we've incremented since last bucket...\n                this.totalCountToCurrentIndex += this.countAtThisValue;\n                this.totalValueToCurrentIndex +=\n                    this.countAtThisValue *\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n                this.freshSubBucket = false;\n            }\n            if (this.reachedIterationLevel()) {\n                var valueIteratedTo = this.getValueIteratedTo();\n                Object.assign(this.currentIterationValue, {\n                    valueIteratedTo: valueIteratedTo,\n                    valueIteratedFrom: this.prevValueIteratedTo,\n                    countAtValueIteratedTo: this.countAtThisValue,\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n                });\n                this.prevValueIteratedTo = valueIteratedTo;\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n                this.incrementIterationLevel();\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n                    throw new Error(\"Concurrent Modification Exception\");\n                }\n                return this.currentIterationValue;\n            }\n            this.incrementSubBucket();\n        }\n        throw new Error(\"Index Out Of Bounds Exception\");\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n    };\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n        return this.currentIndex >= this.histogram.countsArrayLength;\n    };\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n        this.freshSubBucket = true;\n        this.currentIndex++;\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n    };\n    return AbstractHistogramIterator;\n}());\nexports.default = AbstractHistogramIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar PackedArray_1 = require(\"./packedarray/PackedArray\");\n/**\n * <h3>A High Dynamic Range (HDR) Histogram that uses a packed internal representation</h3>\n * <p>\n * {@link PackedHistogram} supports the recording and analyzing sampled data value counts across a configurable\n * integer value range with configurable value precision within the range. Value precision is expressed as the\n * number of significant digits in the value recording, and provides control over value quantization behavior\n * across the value range and the subsequent value resolution at any given level.\n * <p>\n * {@link PackedHistogram} tracks value counts in a packed internal representation optimized\n * for typical histogram recoded values are sparse in the value range and tend to be incremented in small unit counts.\n * This packed representation tends to require significantly smaller amounts of stoarge when compared to unpacked\n * representations, but can incur additional recording cost due to resizing and repacking operations that may\n * occur as previously unrecorded values are encountered.\n * <p>\n * For example, a {@link PackedHistogram} could be configured to track the counts of observed integer values between 0 and\n * 3,600,000,000,000 while maintaining a value precision of 3 significant digits across that range. Value quantization\n * within the range will thus be no larger than 1/1,000th (or 0.1%) of any value. This example Histogram could\n * be used to track and analyze the counts of observed response times ranging between 1 nanosecond and 1 hour\n * in magnitude, while maintaining a value resolution of 1 microsecond up to 1 millisecond, a resolution of\n * 1 millisecond (or better) up to one second, and a resolution of 1 second (or better) up to 1,000 seconds. At its\n * maximum tracked value (1 hour), it would still maintain a resolution of 3.6 seconds (or better).\n * <p>\n * Auto-resizing: When constructed with no specified value range range (or when auto-resize is turned on with {@link\n * Histogram#setAutoResize}) a {@link PackedHistogram} will auto-resize its dynamic range to include recorded values as\n * they are encountered. Note that recording calls that cause auto-resizing may take longer to execute, as resizing\n * incurs allocation and copying of internal data structures.\n * <p>\n */\nvar PackedHistogram = /** @class */ (function (_super) {\n    __extends(PackedHistogram, _super);\n    function PackedHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.packedCounts = new PackedArray_1.PackedArray(_this.countsArrayLength);\n        return _this;\n    }\n    PackedHistogram.prototype.clearCounts = function () {\n        this.packedCounts.clear();\n        this.totalCount = 0;\n    };\n    PackedHistogram.prototype.incrementCountAtIndex = function (index) {\n        this.packedCounts.increment(index);\n    };\n    PackedHistogram.prototype.addToCountAtIndex = function (index, value) {\n        this.packedCounts.add(index, value);\n    };\n    PackedHistogram.prototype.setCountAtIndex = function (index, value) {\n        /* TODO move in packed array\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n          throw value + \" would overflow integer count\";\n        }*/\n        this.packedCounts.set(index, value);\n    };\n    PackedHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        this.packedCounts.setVirtualLength(this.countsArrayLength);\n    };\n    PackedHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    PackedHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    PackedHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    PackedHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    PackedHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    PackedHistogram.prototype.getCountAtIndex = function (index) {\n        return this.packedCounts.get(index);\n    };\n    PackedHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 192 + 8 * this.packedCounts.getPhysicalLength();\n    };\n    PackedHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new PackedHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return PackedHistogram;\n}(AbstractHistogram_1.default));\nexports.default = PackedHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PackedHistogram.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leftPadding = function (size) {\n    return function (input) {\n        if (input.length < size) {\n            return \" \".repeat(size - input.length) + input;\n        }\n        return input;\n    };\n};\nexports.integerFormatter = function (size) {\n    var padding = leftPadding(size);\n    return function (integer) { return padding(\"\" + integer); };\n};\nexports.floatFormatter = function (size, fractionDigits) {\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n        maximumFractionDigits: fractionDigits,\n        minimumFractionDigits: fractionDigits,\n        useGrouping: false\n    });\n    var padding = leftPadding(size);\n    return function (float) { return padding(numberFormatter.format(float)); };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError = /** @class */ (function () {\n    function ResizeError(newSize) {\n        this.newSize = newSize;\n    }\n    return ResizeError;\n}());\nexports.ResizeError = ResizeError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/ResizeError.ts\n// module id = 9\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 10\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\nvar max = Math.max;\nvar V2EncodingCookieBase = 0x1c849303;\nvar V2CompressedEncodingCookieBase = 0x1c849304;\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nfunction fillBufferFromCountsArray(self, buffer) {\n    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n    var srcIndex = 0;\n    while (srcIndex < countsLimit) {\n        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n        // while negative values indicate a repeat zero counts.\n        var count = self.getCountAtIndex(srcIndex++);\n        if (count < 0) {\n            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n                count +\n                \") at index \" +\n                srcIndex +\n                \", corresponding the value range [\" +\n                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \",\" +\n                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \")\");\n        }\n        // Count trailing 0s (which follow this count):\n        var zerosCount = 0;\n        if (count == 0) {\n            zerosCount = 1;\n            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n                zerosCount++;\n                srcIndex++;\n            }\n        }\n        if (zerosCount > 1) {\n            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n        }\n        else {\n            ZigZagEncoding_1.default.encode(buffer, count);\n        }\n    }\n}\n/**\n * Encode this histogram into a ByteBuffer\n * @param buffer The buffer to encode into\n * @return The number of bytes written to the buffer\n */\nfunction encodeIntoByteBuffer(buffer) {\n    var self = this;\n    var initialPosition = buffer.position;\n    buffer.putInt32(encodingCookie);\n    buffer.putInt32(0); // Placeholder for payload length in bytes.\n    buffer.putInt32(1);\n    buffer.putInt32(self.numberOfSignificantValueDigits);\n    buffer.putInt64(self.lowestDiscernibleValue);\n    buffer.putInt64(self.highestTrackableValue);\n    buffer.putInt64(1);\n    var payloadStartPosition = buffer.position;\n    fillBufferFromCountsArray(self, buffer);\n    var backupIndex = buffer.position;\n    buffer.position = initialPosition + 4;\n    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n    buffer.position = backupIndex;\n    return backupIndex - initialPosition;\n}\nexports.encodeIntoByteBuffer = encodeIntoByteBuffer;\nfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n    if (wordSizeInBytes != 2 &&\n        wordSizeInBytes != 4 &&\n        wordSizeInBytes != 8 &&\n        wordSizeInBytes != V2maxWordSizeInBytes) {\n        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n            V2maxWordSizeInBytes +\n            \") bytes\");\n    }\n    var dstIndex = 0;\n    var endPosition = sourceBuffer.position + lengthInBytes;\n    while (sourceBuffer.position < endPosition) {\n        var zerosCount = 0;\n        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n        if (count < 0) {\n            zerosCount = -count;\n            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n        }\n        else {\n            self.setCountAtIndex(dstIndex++, count);\n        }\n    }\n    return dstIndex; // this is the destination length\n}\nfunction getCookieBase(cookie) {\n    return cookie & ~0xf0;\n}\nfunction getWordSizeInBytesFromCookie(cookie) {\n    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n        return V2maxWordSizeInBytes;\n    }\n    var sizeByte = (cookie & 0xf0) >> 4;\n    return sizeByte & 0xe;\n}\nfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var cookie = buffer.getInt32();\n    var payloadLengthInBytes;\n    var numberOfSignificantValueDigits;\n    var lowestTrackableUnitValue;\n    var highestTrackableValue;\n    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n        }\n        payloadLengthInBytes = buffer.getInt32();\n        buffer.getInt32(); // normalizingIndexOffset not used\n        numberOfSignificantValueDigits = buffer.getInt32();\n        lowestTrackableUnitValue = buffer.getInt64();\n        highestTrackableValue = buffer.getInt64();\n        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n    }\n    else {\n        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n    }\n    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n    histogram.establishInternalTackingValues(filledLength);\n    return histogram;\n}\nexports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\nfunction findDeflateFunction() {\n    try {\n        return eval('require(\"zlib\").deflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/deflate\");\n        return pako.deflate;\n    }\n}\nfunction findInflateFunction() {\n    try {\n        return eval('require(\"zlib\").inflateSync');\n    }\n    catch (error) {\n        var pako = require(\"pako/lib/inflate\");\n        return pako.inflate;\n    }\n}\nvar deflate = findDeflateFunction();\nvar inflate = findInflateFunction();\nfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var initialTargetPosition = buffer.position;\n    var cookie = buffer.getInt32();\n    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n        throw new Error(\"Encoding not supported, only V2 is supported\");\n    }\n    var lengthOfCompressedContents = buffer.getInt32();\n    var uncompressedBuffer = inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n}\nexports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n/**\n * Encode this histogram in compressed form into a byte array\n * @param targetBuffer The buffer to encode into\n * @return The number of bytes written to the array\n */\nfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n    var self = this;\n    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n    targetBuffer.putInt32(compressedEncodingCookie);\n    var compressionOptions = compressionLevel\n        ? { level: compressionLevel }\n        : {};\n    var compressedArray = deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n    targetBuffer.putInt32(compressedArray.byteLength);\n    targetBuffer.putArray(compressedArray);\n    return targetBuffer.position;\n}\nexports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.encoding.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodableHistogram = /** @class */ (function () {\n    function EncodableHistogram() {\n    }\n    return EncodableHistogram;\n}());\nexports.EncodableHistogram = EncodableHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Float64Histogram = /** @class */ (function (_super) {\n    __extends(Float64Histogram, _super);\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Float64Array(_this.countsArrayLength);\n        return _this;\n    }\n    Float64Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Float64Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Float64Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Float64Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Float64Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Float64Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 8 * this.counts.length;\n    };\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Float64Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Float64Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a value point iterated through in a Histogram, with associated stats.\n * <ul>\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n * range.</li>\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n * values equal or smaller than valueIteratedTo.</li>\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n * equal or smaller than valueIteratedTo.</li>\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n * or smaller than valueIteratedTo.</li>\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n * range of multiple percentiles in the requested percentile iteration points).</li>\n * </ul>\n */\nvar HistogramIterationValue = /** @class */ (function () {\n    function HistogramIterationValue() {\n        this.reset();\n    }\n    HistogramIterationValue.prototype.reset = function () {\n        this.valueIteratedTo = 0;\n        this.valueIteratedFrom = 0;\n        this.countAtValueIteratedTo = 0;\n        this.countAddedInThisIterationStep = 0;\n        this.totalCountToThisValue = 0;\n        this.totalValueToThisValue = 0;\n        this.percentile = 0.0;\n        this.percentileLevelIteratedTo = 0.0;\n    };\n    return HistogramIterationValue;\n}());\nexports.default = HistogramIterationValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar encoding_1 = require(\"./encoding\");\nvar TAG_PREFIX = \"Tag=\";\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n/**\n * A histogram log reader.\n * <p>\n * Histogram logs are used to capture full fidelity, per-time-interval\n * histograms of a recorded value.\n * <p>\n * For example, a histogram log can be used to capture high fidelity\n * reaction-time logs for some measured system or subsystem component.\n * Such a log would capture a full reaction time histogram for each\n * logged interval, and could be used to later reconstruct a full\n * HdrHistogram of the measured reaction time behavior for any arbitrary\n * time range within the log, by adding [only] the relevant interval\n * histograms.\n * <h3>Histogram log format:</h3>\n * A histogram log file consists of text lines. Lines beginning with\n * the \"#\" character are optional and treated as comments. Lines\n * containing the legend (starting with \"Timestamp\") are also optional\n * and ignored in parsing the histogram log. All other lines must\n * be valid interval description lines. Text fields are delimited by\n * commas, spaces.\n * <p>\n * A valid interval description line contains an optional Tag=tagString\n * text field, followed by an interval description.\n * <p>\n * A valid interval description must contain exactly four text fields:\n * <ul>\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n * representing the start timestamp of the interval in seconds.</li>\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n * representing the length of the interval in seconds.</li>\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n * which generally represents the maximum value of the interval histogram.</li>\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n * </ul>\n * The log file may contain an optional indication of a starting time. Starting time\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\n * by a number parse-able as a double, representing the start time (in seconds)\n * that may be added to timestamps in the file to determine an absolute\n * timestamp (e.g. since the epoch) for each interval.\n */\nvar HistogramLogReader = /** @class */ (function () {\n    function HistogramLogReader(logContent, options) {\n        var _a;\n        this.lines = splitLines(logContent);\n        this.currentLineIndex = 0;\n        this.histogramConstr = ((_a = options) === null || _a === void 0 ? void 0 : _a.histogramConstr) || Int32Histogram_1.default;\n    }\n    /**\n     * Read the next interval histogram from the log. Returns a Histogram object if\n     * an interval line was found, or null if not.\n     * <p>Upon encountering any unexpected format errors in reading the next interval\n     * from the file, this method will return a null.\n     * @return a DecodedInterval, or a null if no appropriate interval found\n     */\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n        while (this.currentLineIndex < this.lines.length) {\n            var currentLine = this.lines[this.currentLineIndex];\n            this.currentLineIndex++;\n            if (currentLine.startsWith(\"#[StartTime:\")) {\n                this.parseStartTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n                this.parseBaseTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#\") ||\n                currentLine.startsWith('\"StartTimestamp\"')) {\n                // skip legend & meta data for now\n            }\n            else if (currentLine.includes(\",\")) {\n                var tokens = currentLine.split(\",\");\n                var firstToken = tokens[0];\n                var tag = void 0;\n                if (firstToken.startsWith(TAG_PREFIX)) {\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n                    tokens.shift();\n                }\n                else {\n                    tag = AbstractHistogramBase_1.NO_TAG;\n                }\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n                if (!this.baseTimeSec) {\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n                        // StartTime), we assume that timestamps in the log are not absolute\n                        this.baseTimeSec = this.startTimeSec;\n                    }\n                    else {\n                        // Timestamps are absolute\n                        this.baseTimeSec = 0.0;\n                    }\n                }\n                if (rangeEndTimeSec < logTimeStampInSec) {\n                    return null;\n                }\n                if (logTimeStampInSec < rangeStartTimeSec) {\n                    continue;\n                }\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram, this.histogramConstr);\n                histogram.startTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n                histogram.endTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n                histogram.tag = tag;\n                return histogram;\n            }\n        }\n        return null;\n    };\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    return HistogramLogReader;\n}());\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\nvar shouldIncludeNoTag = function (lines) {\n    return lines.find(function (line) {\n        return !line.startsWith(\"#\") &&\n            !line.startsWith('\"') &&\n            !line.startsWith(TAG_PREFIX) &&\n            line.includes(\",\");\n    });\n};\nexports.listTags = function (content) {\n    var lines = splitLines(content);\n    var tags = lines\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n    var tagsWithoutDuplicates = new Set(tags);\n    var result = Array.from(tagsWithoutDuplicates);\n    if (shouldIncludeNoTag(lines)) {\n        result.unshift(\"NO TAG\");\n    }\n    return result;\n};\nexports.default = HistogramLogReader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar formatters_1 = require(\"./formatters\");\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\nvar HistogramLogWriter = /** @class */ (function () {\n    function HistogramLogWriter(log) {\n        this.log = log;\n        /**\n         * Base time to subtract from supplied histogram start/end timestamps when\n         * logging based on histogram timestamps.\n         * Base time is expected to be in msec since the epoch, as histogram start/end times\n         * are typically stamped with absolute times in msec since the epoch.\n         */\n        this.baseTime = 0;\n    }\n    /**\n     * Output an interval histogram, with the given timestamp information and the [optional] tag\n     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n     * specified timestamp information will be used, and the timestamp information in the actual\n     * histogram will be ignored).\n     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n     * @param histogram The interval histogram to log.\n     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n     */\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\n        var start = timeFormatter(startTimeStampSec);\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n        }\n        else {\n            this.log(lineContent);\n        }\n    };\n    /**\n     * Log a comment to the log.\n     * Comments will be preceded with with the '#' character.\n     * @param comment the comment string.\n     */\n    HistogramLogWriter.prototype.outputComment = function (comment) {\n        this.log(\"#\" + comment + \"\\n\");\n    };\n    /**\n     * Log a start time in the log.\n     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n     */\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n    };\n    /**\n     * Output a legend line to the log.\n     */\n    HistogramLogWriter.prototype.outputLegend = function () {\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n    };\n    /**\n     * Output a log format version to the log.\n     */\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n    };\n    return HistogramLogWriter;\n}());\nexports.default = HistogramLogWriter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int16Histogram = /** @class */ (function (_super) {\n    __extends(Int16Histogram, _super);\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint16Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int16Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint16Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int16Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int16Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int16Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int16Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 2 * this.counts.length;\n    };\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int16Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int16Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int8Histogram = /** @class */ (function (_super) {\n    __extends(Int8Histogram, _super);\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint8Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int8Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint8Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int8Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int8Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int8Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int8Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int8Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int8Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n/**\n * Used for iterating through histogram values according to percentile levels. The iteration is\n * performed in steps that start at 0% and reduce their distance to 100% according to the\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n * values are exhausted.\n */\nvar PercentileIterator = /** @class */ (function (_super) {\n    __extends(PercentileIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n     */\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n        var _this = _super.call(this) || this;\n        _this.percentileTicksPerHalfDistance = 0;\n        _this.percentileLevelToIterateTo = 0;\n        _this.percentileLevelToIterateFrom = 0;\n        _this.reachedLastRecordedValue = false;\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     *\n     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n     */\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n    };\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n        this.percentileLevelToIterateTo = 0;\n        this.percentileLevelToIterateFrom = 0;\n        this.reachedLastRecordedValue = false;\n    };\n    PercentileIterator.prototype.hasNext = function () {\n        if (_super.prototype.hasNext.call(this))\n            return true;\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n            this.percentileLevelToIterateTo = 100;\n            this.reachedLastRecordedValue = true;\n            return true;\n        }\n        return false;\n    };\n    PercentileIterator.prototype.incrementIterationLevel = function () {\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\n        // steps are much easier to browse through in a percentile distribution output, for example.\n        //\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n        // by at the current scale. The scale is detemined by the percentile level we are\n        // iterating to. The following math determines the tick size for the current scale,\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n        // [from either 0% or from the previous half-distance]. When that half-distance is\n        // crossed, the scale changes and the tick size is effectively cut in half.\n        // percentileTicksPerHalfDistance = 5\n        // percentileReportingTicks = 10,\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n    };\n    PercentileIterator.prototype.reachedIterationLevel = function () {\n        if (this.countAtThisValue === 0) {\n            return false;\n        }\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n        return currentPercentile >= this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n        return this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n        return this.percentileLevelToIterateFrom;\n    };\n    return PercentileIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = PercentileIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\n/**\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n * all recorded histogram values are exhausted.\n */\nvar RecordedValuesIterator = /** @class */ (function (_super) {\n    __extends(RecordedValuesIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     */\n    function RecordedValuesIterator(histogram) {\n        var _this = _super.call(this) || this;\n        _this.doReset(histogram);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     */\n    RecordedValuesIterator.prototype.reset = function () {\n        this.doReset(this.histogram);\n    };\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.visitedIndex = -1;\n    };\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n        this.visitedIndex = this.currentIndex;\n    };\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n    };\n    return RecordedValuesIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = RecordedValuesIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\n/**\n * Records integer values, and provides stable interval {@link Histogram} samples from\n * live recorded data without interrupting or stalling active recording of values. Each interval\n * histogram provided contains all value counts accumulated since the previous interval histogram\n * was taken.\n * <p>\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n * <p>\n * {@link Recorder} supports concurrent\n * {@link Recorder#recordValue} or\n * {@link Recorder#recordValueWithExpectedInterval} calls.\n *\n */\nvar Recorder = /** @class */ (function () {\n    /**\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n     *\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n     *                                       decimal digits to which the histogram will maintain value resolution\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\n     * @param packed Specifies whether the recorder will uses a packed internal representation or not.\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\n     */\n    function Recorder(numberOfSignificantValueDigits, packed, clock) {\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n        if (packed === void 0) { packed = false; }\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.packed = packed;\n        this.clock = clock;\n        this.histogramConstr = packed ? PackedHistogram_1.default : Int32Histogram_1.default;\n        this.activeHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n        Recorder.idGenerator++;\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n        this.activeHistogram.startTimeStampMsec = clock();\n    }\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValue = function (value) {\n        this.activeHistogram.recordValue(value);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithCount = function (value, count) {\n        this.activeHistogram.recordValueWithCount(value, count);\n    };\n    /**\n     * Record a value\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n     * for more explanations about coordinated omission and expected interval correction.\n     *      *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    /**\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\n     * accumulated since the last interval histogram was taken.\n     * <p>\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)}\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\n     * {@link Recorder#getIntervalHistogram()} and\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n     * {@code histogramToRecycle} must\n     * be either be null or an interval histogram returned by a previous call to\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} or\n     * {@link Recorder#getIntervalHistogram()}.\n     * <p>\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\n     * <p>\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n     * counts for the next interval\n     *\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n     *                           copy operations.\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n     */\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n        if (histogramToRecycle) {\n            var histogramToRecycleWithId = histogramToRecycle;\n            if (histogramToRecycleWithId.containingInstanceId !==\n                this.activeHistogram.containingInstanceId) {\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n            }\n        }\n        this.inactiveHistogram = histogramToRecycle;\n        this.performIntervalSample();\n        var sampledHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n        return sampledHistogram;\n    };\n    /**\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n     * was taken) into {@code targetHistogram}.\n     *\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n     * the value counts, and start accumulating value counts for the next interval.\n     *\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n     */\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n        this.performIntervalSample();\n        if (this.inactiveHistogram) {\n            targetHistogram.add(this.inactiveHistogram);\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n        }\n    };\n    /**\n     * Reset any value counts accumulated thus far.\n     */\n    Recorder.prototype.reset = function () {\n        this.activeHistogram.reset();\n        this.activeHistogram.startTimeStampMsec = this.clock();\n    };\n    Recorder.prototype.performIntervalSample = function () {\n        if (!this.inactiveHistogram) {\n            this.inactiveHistogram = new this.histogramConstr(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n        }\n        this.inactiveHistogram.reset();\n        var tempHistogram = this.activeHistogram;\n        this.activeHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = tempHistogram;\n        var currentTimeInMs = this.clock();\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n    };\n    Recorder.idGenerator = 0;\n    return Recorder;\n}());\nexports.default = Recorder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar SparseArrayHistogram = /** @class */ (function (_super) {\n    __extends(SparseArrayHistogram, _super);\n    function SparseArrayHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Array();\n        return _this;\n    }\n    SparseArrayHistogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    SparseArrayHistogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index] || 0;\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    SparseArrayHistogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    SparseArrayHistogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n    };\n    SparseArrayHistogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    SparseArrayHistogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    SparseArrayHistogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    SparseArrayHistogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    SparseArrayHistogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    SparseArrayHistogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index] || 0;\n    };\n    SparseArrayHistogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    SparseArrayHistogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new SparseArrayHistogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return SparseArrayHistogram;\n}(AbstractHistogram_1.default));\nexports.default = SparseArrayHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SparseArrayHistogram.ts\n// module id = 23\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_7 = pow(2, 7);\nvar TWO_POW_14 = pow(2, 14);\nvar TWO_POW_21 = pow(2, 21);\nvar TWO_POW_28 = pow(2, 28);\nvar TWO_POW_35 = pow(2, 35);\nvar TWO_POW_42 = pow(2, 42);\nvar TWO_POW_49 = pow(2, 49);\nvar TWO_POW_56 = pow(2, 56);\n/**\n * This class provides encoding and decoding methods for writing and reading\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n * allows small (closer to zero) negative values to use fewer bytes. Details\n * on both LEB128 and ZigZag can be readily found elsewhere.\n *\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n * value can take up to 10 bytes in the stream, where this variant's encoding\n * of a 64 bit values will max out at 9 bytes.\n *\n * As such, this encoder/decoder should NOT be used for encoding or decoding\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n */\nvar ZigZagEncoding = /** @class */ (function () {\n    function ZigZagEncoding() {\n    }\n    /**\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n     * (negative numbers not supported)\n     * @param buffer the buffer to write to\n     * @param value  the value to write to the buffer\n     */\n    ZigZagEncoding.encode = function (buffer, value) {\n        if (value >= 0) {\n            value = value * 2;\n        }\n        else {\n            value = -value * 2 - 1;\n        }\n        if (value < TWO_POW_7) {\n            buffer.put(value);\n        }\n        else {\n            buffer.put(value | 0x80);\n            if (value < TWO_POW_14) {\n                buffer.put(floor(value / TWO_POW_7));\n            }\n            else {\n                buffer.put(floor(value / TWO_POW_7) | 0x80);\n                if (value < TWO_POW_21) {\n                    buffer.put(floor(value / TWO_POW_14));\n                }\n                else {\n                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n                    if (value < TWO_POW_28) {\n                        buffer.put(floor(value / TWO_POW_21));\n                    }\n                    else {\n                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n                        if (value < TWO_POW_35) {\n                            buffer.put(floor(value / TWO_POW_28));\n                        }\n                        else {\n                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n                            if (value < TWO_POW_42) {\n                                buffer.put(floor(value / TWO_POW_35));\n                            }\n                            else {\n                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n                                if (value < TWO_POW_49) {\n                                    buffer.put(floor(value / TWO_POW_42));\n                                }\n                                else {\n                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n                                    if (value < TWO_POW_56) {\n                                        buffer.put(floor(value / TWO_POW_49));\n                                    }\n                                    else {\n                                        // should not happen\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n                                        buffer.put(floor(value / TWO_POW_56));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n     * (negative numbers not supported)\n     * @param buffer the buffer to read from\n     * @return the value read from the buffer\n     */\n    ZigZagEncoding.decode = function (buffer) {\n        var v = buffer.get();\n        var value = v & 0x7f;\n        if ((v & 0x80) != 0) {\n            v = buffer.get();\n            value += (v & 0x7f) * TWO_POW_7;\n            if ((v & 0x80) != 0) {\n                v = buffer.get();\n                value += (v & 0x7f) * TWO_POW_14;\n                if ((v & 0x80) != 0) {\n                    v = buffer.get();\n                    value += (v & 0x7f) * TWO_POW_21;\n                    if ((v & 0x80) != 0) {\n                        v = buffer.get();\n                        value += (v & 0x7f) * TWO_POW_28;\n                        if ((v & 0x80) != 0) {\n                            v = buffer.get();\n                            value += (v & 0x7f) * TWO_POW_35;\n                            if ((v & 0x80) != 0) {\n                                v = buffer.get();\n                                value += (v & 0x7f) * TWO_POW_42;\n                                if ((v & 0x80) != 0) {\n                                    v = buffer.get();\n                                    value += (v & 0x7f) * TWO_POW_49;\n                                    if ((v & 0x80) != 0) {\n                                        v = buffer.get();\n                                        value += (v & 0x7f) * TWO_POW_56;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (value % 2 === 0) {\n            value = value / 2;\n        }\n        else {\n            value = -(value + 1) / 2;\n        }\n        return value;\n    };\n    return ZigZagEncoding;\n}());\nexports.default = ZigZagEncoding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 24\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nexports.ByteBuffer = ByteBuffer_1.default;\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\nexports.Int8Histogram = Int8Histogram_1.default;\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\nexports.Int16Histogram = Int16Histogram_1.default;\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nexports.Int32Histogram = Int32Histogram_1.default;\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\nexports.Float64Histogram = Float64Histogram_1.default;\nvar PackedHistogram_1 = require(\"./PackedHistogram\");\nexports.PackedHistogram = PackedHistogram_1.default;\nvar SparseArrayHistogram_1 = require(\"./SparseArrayHistogram\");\nexports.SparseArrayHistogram = SparseArrayHistogram_1.default;\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nexports.AbstractHistogram = AbstractHistogram_1.default;\nexports.Histogram = AbstractHistogram_1.default;\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\nexports.HistogramLogReader = HistogramLogReader_1.default;\nexports.listTags = HistogramLogReader_1.listTags;\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\nvar encoding_1 = require(\"./encoding\");\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\nvar Recorder_1 = require(\"./Recorder\");\nexports.Recorder = Recorder_1.default;\nvar defaultRequest = {\n    bitBucketSize: 32,\n    autoResize: true,\n    lowestDiscernibleValue: 1,\n    highestTrackableValue: 2,\n    numberOfSignificantValueDigits: 3\n};\nexports.defaultRequest = defaultRequest;\n/*const bigIntAvailable = (() => {\n  try {\n    eval(\"123n\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();*/\nvar build = function (request) {\n    if (request === void 0) { request = defaultRequest; }\n    var parameters = Object.assign({}, defaultRequest, request);\n    var histogramConstr;\n    switch (parameters.bitBucketSize) {\n        case 8:\n            histogramConstr = Int8Histogram_1.default;\n            break;\n        case 16:\n            histogramConstr = Int16Histogram_1.default;\n            break;\n        case 32:\n            histogramConstr = Int32Histogram_1.default;\n            break;\n        case \"sparse_array\":\n            histogramConstr = SparseArrayHistogram_1.default;\n            break;\n        case \"packed\":\n            histogramConstr = PackedHistogram_1.default;\n            break;\n        default:\n            //histogramConstr = bigIntAvailable ? BigIntHistogram : Float64Histogram;\n            histogramConstr = Float64Histogram_1.default;\n    }\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n    histogram.autoResize = parameters.autoResize;\n    return histogram;\n};\nexports.build = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 25\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar PackedArrayContext_1 = require(\"./PackedArrayContext\");\nvar ResizeError_1 = require(\"./ResizeError\");\nvar NUMBER_OF_SETS = 8;\nvar pow = Math.pow, floor = Math.floor;\n/**\n * A Packed array of signed 64 bit values, and supports {@link #get get()}, {@link #set set()},\n * {@link #add add()} and {@link #increment increment()} operations on the logical contents of the array.\n *\n * An {@link PackedLongArray} Uses {@link PackedArrayContext} to track\n * the array's logical contents. Contexts may be switched when a context requires resizing\n * to complete logical array operations (get, set, add, increment). Contexts are\n * established and used within critical sections in order to facilitate concurrent\n * implementors.\n *\n */\nvar PackedArray = /** @class */ (function () {\n    function PackedArray(virtualLength, initialPhysicalLength) {\n        if (initialPhysicalLength === void 0) { initialPhysicalLength = PackedArrayContext_1.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY; }\n        this.arrayContext = new PackedArrayContext_1.PackedArrayContext(virtualLength, initialPhysicalLength);\n    }\n    PackedArray.prototype.setVirtualLength = function (newVirtualArrayLength) {\n        if (newVirtualArrayLength < this.length()) {\n            throw new Error(\"Cannot set virtual length, as requested length \" +\n                newVirtualArrayLength +\n                \" is smaller than the current virtual length \" +\n                this.length());\n        }\n        var currentArrayContext = this.arrayContext;\n        if (currentArrayContext.isPacked &&\n            currentArrayContext.determineTopLevelShiftForVirtualLength(newVirtualArrayLength) == currentArrayContext.getTopLevelShift()) {\n            // No changes to the array context contents is needed. Just change the virtual length.\n            currentArrayContext.setVirtualLength(newVirtualArrayLength);\n            return;\n        }\n        this.arrayContext = currentArrayContext.copyAndIncreaseSize(this.getPhysicalLength(), newVirtualArrayLength);\n    };\n    /**\n     * Get value at virtual index in the array\n     * @param index the virtual array index\n     * @return the array value at the virtual index given\n     */\n    PackedArray.prototype.get = function (index) {\n        var value = 0;\n        for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n            var byteValueAtPackedIndex = 0;\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                return this.arrayContext.getAtUnpackedIndex(index);\n            }\n            // Context is packed:\n            var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, false);\n            if (packedIndex < 0) {\n                return value;\n            }\n            byteValueAtPackedIndex =\n                this.arrayContext.getAtByteIndex(packedIndex) * pow(2, byteNum << 3);\n            value += byteValueAtPackedIndex;\n        }\n        return value;\n    };\n    /**\n     * Increment value at a virrual index in the array\n     * @param index virtual index of value to increment\n     */\n    PackedArray.prototype.increment = function (index) {\n        this.add(index, 1);\n    };\n    PackedArray.prototype.safeGetPackedIndexgetPackedIndex = function (setNumber, virtualIndex) {\n        do {\n            try {\n                return this.arrayContext.getPackedIndex(setNumber, virtualIndex, true);\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Add to a value at a virtual index in the array\n     * @param index the virtual index of the value to be added to\n     * @param value the value to add\n     */\n    PackedArray.prototype.add = function (index, value) {\n        var remainingValueToAdd = value;\n        for (var byteNum = 0, byteShift = 0; byteNum < NUMBER_OF_SETS; byteNum++, byteShift += 8) {\n            // Deal with unpacked context:\n            if (!this.arrayContext.isPacked) {\n                this.arrayContext.addAndGetAtUnpackedIndex(index, value);\n                return;\n            }\n            // Context is packed:\n            var packedIndex = this.safeGetPackedIndexgetPackedIndex(byteNum, index);\n            var byteToAdd = remainingValueToAdd & 0xff;\n            var afterAddByteValue = this.arrayContext.addAtByteIndex(packedIndex, byteToAdd);\n            // Reduce remaining value to add by amount just added:\n            remainingValueToAdd -= byteToAdd;\n            remainingValueToAdd = remainingValueToAdd / pow(2, 8);\n            // Account for carry:\n            remainingValueToAdd += floor(afterAddByteValue / pow(2, 8));\n            if (remainingValueToAdd == 0) {\n                return; // nothing to add to higher magnitudes\n            }\n        }\n    };\n    /**\n     * Set the value at a virtual index in the array\n     * @param index the virtual index of the value to set\n     * @param value the value to set\n     */\n    PackedArray.prototype.set = function (index, value) {\n        var bytesAlreadySet = 0;\n        do {\n            var valueForNextLevels = value;\n            try {\n                for (var byteNum = 0; byteNum < NUMBER_OF_SETS; byteNum++) {\n                    // Establish context within: critical section\n                    // Deal with unpacked context:\n                    if (!this.arrayContext.isPacked) {\n                        this.arrayContext.setAtUnpackedIndex(index, value);\n                        return;\n                    }\n                    // Context is packed:\n                    if (valueForNextLevels == 0) {\n                        // Special-case zeros to avoid inflating packed array for no reason\n                        var packedIndex_1 = this.arrayContext.getPackedIndex(byteNum, index, false);\n                        if (packedIndex_1 < 0) {\n                            return; // no need to create entries for zero values if they don't already exist\n                        }\n                    }\n                    // Make sure byte is populated:\n                    var packedIndex = this.arrayContext.getPackedIndex(byteNum, index, true);\n                    // Determine value to write, and prepare for next levels\n                    var byteToWrite = valueForNextLevels & 0xff;\n                    valueForNextLevels = floor(valueForNextLevels / pow(2, 8));\n                    if (byteNum < bytesAlreadySet) {\n                        // We want to avoid writing to the same byte twice when not doing so for the\n                        // entire 64 bit value atomically, as doing so opens a race with e.g. concurrent\n                        // adders. So dobn't actually write the byte if has been written before.\n                        continue;\n                    }\n                    this.arrayContext.setAtByteIndex(packedIndex, byteToWrite);\n                    bytesAlreadySet++;\n                }\n                return;\n            }\n            catch (ex) {\n                if (ex instanceof ResizeError_1.ResizeError) {\n                    this.arrayContext.resizeArray(ex.newSize);\n                }\n                else {\n                    throw ex;\n                }\n            }\n        } while (true);\n    };\n    /**\n     * Get the current physical length (in longs) of the array's backing storage\n     * @return the current physical length (in longs) of the array's current backing storage\n     */\n    PackedArray.prototype.getPhysicalLength = function () {\n        return this.arrayContext.physicalLength;\n    };\n    /**\n     * Get the (virtual) length of the array\n     * @return the (virtual) length of the array\n     */\n    PackedArray.prototype.length = function () {\n        return this.arrayContext.getVirtualLength();\n    };\n    /**\n     * Clear the array contents\n     */\n    PackedArray.prototype.clear = function () {\n        this.arrayContext.clear();\n    };\n    PackedArray.prototype.toString = function () {\n        var output = \"PackedArray:\\n\";\n        output += this.arrayContext.toString();\n        return output;\n    };\n    return PackedArray;\n}());\nexports.PackedArray = PackedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/PackedArray.ts\n// module id = 26\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ResizeError_1 = require(\"./ResizeError\");\n/**\n * A packed-value, sparse array context used for storing 64 bit signed values.\n *\n * An array context is optimised for tracking sparsely set (as in mostly zeros) values that tend to not make\n * use pof the full 64 bit value range even when they are non-zero. The array context's internal representation\n * is such that the packed value at each virtual array index may be represented by 0-8 bytes of actual storage.\n *\n * An array context encodes the packed values in 8 \"set trees\" with each set tree representing one byte of the\n * packed value at the virtual index in question. The {@link #getPackedIndex(int, int, boolean)} method is used\n * to look up the byte-index corresponding to the given (set tree) value byte of the given virtual index, and can\n * be used to add entries to represent that byte as needed. As a succesful {@link #getPackedIndex(int, int, boolean)}\n * may require a resizing of the array, it can throw a {@link ResizeException} to indicate that the requested\n * packed index cannot be found or added without a resize of the physical storage.\n *\n */\nexports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY = 16;\nvar MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH = Math.pow(2, 13) - 1; //(Short.MAX_VALUE / 4);  TODO ALEX why ???\nvar SET_0_START_INDEX = 0;\nvar NUMBER_OF_SETS = 8;\nvar LEAF_LEVEL_SHIFT = 3;\nvar NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET = 0;\nvar NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS = 1;\nvar PACKED_ARRAY_GROWTH_INCREMENT = 16;\nvar PACKED_ARRAY_GROWTH_FRACTION_POW2 = 4;\nvar pow = Math.pow, ceil = Math.ceil, log2 = Math.log2, max = Math.max;\nvar bitCount = function (n) {\n    var bits = 0;\n    while (n !== 0) {\n        bits += bitCount32(n | 0);\n        n /= 0x100000000;\n    }\n    return bits;\n};\nvar bitCount32 = function (n) {\n    n = n - ((n >> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n};\nvar PackedArrayContext = /** @class */ (function () {\n    function PackedArrayContext(virtualLength, initialPhysicalLength) {\n        this.populatedShortLength = 0;\n        this.topLevelShift = Number.MAX_VALUE; // Make it non-sensical until properly initialized.\n        this.physicalLength = Math.max(initialPhysicalLength, exports.MINIMUM_INITIAL_PACKED_ARRAY_CAPACITY);\n        this.isPacked =\n            this.physicalLength <= MAX_SUPPORTED_PACKED_COUNTS_ARRAY_LENGTH;\n        if (!this.isPacked) {\n            this.physicalLength = virtualLength;\n        }\n        this.array = new ArrayBuffer(this.physicalLength * 8);\n        this.initArrayViews(this.array);\n        this.init(virtualLength);\n    }\n    PackedArrayContext.prototype.initArrayViews = function (array) {\n        this.byteArray = new Uint8Array(array);\n        this.shortArray = new Uint16Array(array);\n        this.longArray = new Float64Array(array);\n    };\n    PackedArrayContext.prototype.init = function (virtualLength) {\n        if (!this.isPacked) {\n            // Deal with non-packed context init:\n            this.virtualLength = virtualLength;\n            return;\n        }\n        this.populatedShortLength = SET_0_START_INDEX + 8;\n        // Populate empty root entries, and point to them from the root indexes:\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            this.setAtShortIndex(SET_0_START_INDEX + i, 0);\n        }\n        this.setVirtualLength(virtualLength);\n    };\n    PackedArrayContext.prototype.clear = function () {\n        this.byteArray.fill(0);\n    };\n    PackedArrayContext.prototype.copyAndIncreaseSize = function (newPhysicalArrayLength, newVirtualArrayLength) {\n        var ctx = new PackedArrayContext(newVirtualArrayLength, newPhysicalArrayLength);\n        if (this.isPacked) {\n            ctx.populateEquivalentEntriesWithEntriesFromOther(this);\n        }\n        return ctx;\n    };\n    PackedArrayContext.prototype.getPopulatedShortLength = function () {\n        return this.populatedShortLength;\n    };\n    PackedArrayContext.prototype.getPopulatedLongLength = function () {\n        return (this.getPopulatedShortLength() + 3) >> 2; // round up\n    };\n    PackedArrayContext.prototype.setAtByteIndex = function (byteIndex, value) {\n        this.byteArray[byteIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtByteIndex = function (byteIndex) {\n        return this.byteArray[byteIndex];\n    };\n    /**\n     * add a byte value to a current byte value in the array\n     * @param byteIndex index of byte value to add to\n     * @param valueToAdd byte value to add\n     * @return the afterAddValue. ((afterAddValue & 0x100) != 0) indicates a carry.\n     */\n    PackedArrayContext.prototype.addAtByteIndex = function (byteIndex, valueToAdd) {\n        var newValue = this.byteArray[byteIndex] + valueToAdd;\n        this.byteArray[byteIndex] = newValue;\n        return newValue;\n    };\n    PackedArrayContext.prototype.setPopulatedLongLength = function (newPopulatedLongLength) {\n        this.populatedShortLength = newPopulatedLongLength << 2;\n    };\n    PackedArrayContext.prototype.getVirtualLength = function () {\n        return this.virtualLength;\n    };\n    PackedArrayContext.prototype.length = function () {\n        return this.physicalLength;\n    };\n    PackedArrayContext.prototype.setAtShortIndex = function (shortIndex, value) {\n        this.shortArray[shortIndex] = value;\n    };\n    PackedArrayContext.prototype.setAtLongIndex = function (longIndex, value) {\n        this.longArray[longIndex] = value;\n    };\n    PackedArrayContext.prototype.getAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.getIndexAtShortIndex = function (shortIndex) {\n        return this.shortArray[shortIndex];\n    };\n    PackedArrayContext.prototype.setPackedSlotIndicators = function (entryIndex, newPackedSlotIndicators) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, newPackedSlotIndicators);\n    };\n    PackedArrayContext.prototype.getPackedSlotIndicators = function (entryIndex) {\n        return (this.shortArray[entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET] &\n            0xffff);\n    };\n    PackedArrayContext.prototype.getIndexAtEntrySlot = function (entryIndex, slot) {\n        return this.getAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot);\n    };\n    PackedArrayContext.prototype.setIndexAtEntrySlot = function (entryIndex, slot, newIndexValue) {\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slot, newIndexValue);\n    };\n    PackedArrayContext.prototype.expandArrayIfNeeded = function (entryLengthInLongs) {\n        var currentLength = this.length();\n        if (currentLength < this.getPopulatedLongLength() + entryLengthInLongs) {\n            var growthIncrement = max(entryLengthInLongs, PACKED_ARRAY_GROWTH_INCREMENT, this.getPopulatedLongLength() >> PACKED_ARRAY_GROWTH_FRACTION_POW2);\n            throw new ResizeError_1.ResizeError(currentLength + growthIncrement);\n        }\n    };\n    PackedArrayContext.prototype.newEntry = function (entryLengthInShorts) {\n        // Add entry at the end of the array:\n        var newEntryIndex = this.populatedShortLength;\n        this.expandArrayIfNeeded((entryLengthInShorts >> 2) + 1);\n        this.populatedShortLength = newEntryIndex + entryLengthInShorts;\n        for (var i = 0; i < entryLengthInShorts; i++) {\n            this.setAtShortIndex(newEntryIndex + i, -1); // Poison value -1. Must be overriden before reads\n        }\n        return newEntryIndex;\n    };\n    PackedArrayContext.prototype.newLeafEntry = function () {\n        // Add entry at the end of the array:\n        var newEntryIndex;\n        newEntryIndex = this.getPopulatedLongLength();\n        this.expandArrayIfNeeded(1);\n        this.setPopulatedLongLength(newEntryIndex + 1);\n        this.setAtLongIndex(newEntryIndex, 0);\n        return newEntryIndex;\n    };\n    /**\n     * Consolidate entry with previous entry verison if one exists\n     *\n     * @param entryIndex The shortIndex of the entry to be consolidated\n     * @param previousVersionIndex the index of the previous version of the entry\n     */\n    PackedArrayContext.prototype.consolidateEntry = function (entryIndex, previousVersionIndex) {\n        var previousVersionPackedSlotsIndicators = this.getPackedSlotIndicators(previousVersionIndex);\n        // Previous version exists, needs consolidation\n        var packedSlotsIndicators = this.getPackedSlotIndicators(entryIndex);\n        var insertedSlotMask = packedSlotsIndicators ^ previousVersionPackedSlotsIndicators; // the only bit that differs\n        var slotsBelowBitNumber = packedSlotsIndicators & (insertedSlotMask - 1);\n        var insertedSlotIndex = bitCount(slotsBelowBitNumber);\n        var numberOfSlotsInEntry = bitCount(packedSlotsIndicators);\n        // Copy the entry slots from previous version, skipping the newly inserted slot in the target:\n        var sourceSlot = 0;\n        for (var targetSlot = 0; targetSlot < numberOfSlotsInEntry; targetSlot++) {\n            if (targetSlot !== insertedSlotIndex) {\n                var indexAtSlot = this.getIndexAtEntrySlot(previousVersionIndex, sourceSlot);\n                if (indexAtSlot !== 0) {\n                    this.setIndexAtEntrySlot(entryIndex, targetSlot, indexAtSlot);\n                }\n                sourceSlot++;\n            }\n        }\n    };\n    /**\n     * Expand entry as indicated.\n     *\n     * @param existingEntryIndex the index of the entry\n     * @param entryPointerIndex  index to the slot pointing to the entry (needs to be fixed up)\n     * @param insertedSlotIndex  realtive [packed] index of slot being inserted into entry\n     * @param insertedSlotMask   mask value fo slot being inserted\n     * @param nextLevelIsLeaf    the level below this one is a leaf level\n     * @return the updated index of the entry (-1 if epansion failed due to conflict)\n     * @throws RetryException if expansion fails due to concurrent conflict, and caller should try again.\n     */\n    PackedArrayContext.prototype.expandEntry = function (existingEntryIndex, entryPointerIndex, insertedSlotIndex, insertedSlotMask, nextLevelIsLeaf) {\n        var packedSlotIndicators = this.getAtShortIndex(existingEntryIndex) & 0xffff;\n        packedSlotIndicators |= insertedSlotMask;\n        var numberOfslotsInExpandedEntry = bitCount(packedSlotIndicators);\n        if (insertedSlotIndex >= numberOfslotsInExpandedEntry) {\n            throw new Error(\"inserted slot index is out of range given provided masks\");\n        }\n        var expandedEntryLength = numberOfslotsInExpandedEntry + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS;\n        // Create new next-level entry to refer to from slot at this level:\n        var indexOfNewNextLevelEntry = 0;\n        if (nextLevelIsLeaf) {\n            indexOfNewNextLevelEntry = this.newLeafEntry(); // Establish long-index to new leaf entry\n        }\n        else {\n            // TODO: Optimize this by creating the whole sub-tree here, rather than a step that will immediaterly expand\n            // Create a new 1 word (empty, no slots set) entry for the next level:\n            indexOfNewNextLevelEntry = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS); // Establish short-index to new leaf entry\n            this.setPackedSlotIndicators(indexOfNewNextLevelEntry, 0);\n        }\n        var insertedSlotValue = indexOfNewNextLevelEntry;\n        var expandedEntryIndex = this.newEntry(expandedEntryLength);\n        // populate the packed indicators word:\n        this.setPackedSlotIndicators(expandedEntryIndex, packedSlotIndicators);\n        // Populate the inserted slot with the index of the new next level entry:\n        this.setIndexAtEntrySlot(expandedEntryIndex, insertedSlotIndex, insertedSlotValue);\n        this.setAtShortIndex(entryPointerIndex, expandedEntryIndex);\n        this.consolidateEntry(expandedEntryIndex, existingEntryIndex);\n        return expandedEntryIndex;\n    };\n    //\n    //   ######   ######## ########    ##     ##    ###    ##             ## #### ##    ## ########  ######## ##     ##\n    //  ##    ##  ##          ##       ##     ##   ## ##   ##            ##   ##  ###   ## ##     ## ##        ##   ##\n    //  ##        ##          ##       ##     ##  ##   ##  ##           ##    ##  ####  ## ##     ## ##         ## ##\n    //  ##   #### ######      ##       ##     ## ##     ## ##          ##     ##  ## ## ## ##     ## ######      ###\n    //  ##    ##  ##          ##        ##   ##  ######### ##         ##      ##  ##  #### ##     ## ##         ## ##\n    //  ##    ##  ##          ##         ## ##   ##     ## ##        ##       ##  ##   ### ##     ## ##        ##   ##\n    //   ######   ########    ##          ###    ##     ## ######## ##       #### ##    ## ########  ######## ##     ##\n    //\n    PackedArrayContext.prototype.getRootEntry = function (setNumber, insertAsNeeded) {\n        if (insertAsNeeded === void 0) { insertAsNeeded = false; }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber;\n        var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        if (entryIndex == 0) {\n            if (!insertAsNeeded) {\n                return 0; // Index does not currently exist in packed array;\n            }\n            entryIndex = this.newEntry(NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS);\n            // Create a new empty (no slots set) entry for the next level:\n            this.setPackedSlotIndicators(entryIndex, 0);\n            this.setAtShortIndex(entryPointerIndex, entryIndex);\n        }\n        return entryIndex;\n    };\n    /**\n     * Get the byte-index (into the packed array) corresponding to a given (set tree) value byte of given virtual index.\n     * Inserts new set tree nodes as needed if indicated.\n     *\n     * @param setNumber      The set tree number (0-7, 0 corresponding with the LSByte set tree)\n     * @param virtualIndex   The virtual index into the PackedArray\n     * @param insertAsNeeded If true, will insert new set tree nodes as needed if they do not already exist\n     * @return the byte-index corresponding to the given (set tree) value byte of the given virtual index\n     */\n    PackedArrayContext.prototype.getPackedIndex = function (setNumber, virtualIndex, insertAsNeeded) {\n        if (virtualIndex >= this.virtualLength) {\n            throw new Error(\"Attempting access at index \" + virtualIndex + \", beyond virtualLength \" + this.virtualLength);\n        }\n        var entryPointerIndex = SET_0_START_INDEX + setNumber; // TODO init needed ?\n        var entryIndex = this.getRootEntry(setNumber, insertAsNeeded);\n        if (entryIndex == 0) {\n            return -1; // Index does not currently exist in packed array;\n        }\n        // Work down the levels of non-leaf entries:\n        for (var indexShift = this.topLevelShift; indexShift >= LEAF_LEVEL_SHIFT; indexShift -= 4) {\n            var nextLevelIsLeaf = indexShift === LEAF_LEVEL_SHIFT;\n            // Target is a packedSlotIndicators entry\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            var slotBitNumber = (virtualIndex / pow(2, indexShift)) & 0xf; //(virtualIndex >>> indexShift) & 0xf;\n            var slotMask = 1 << slotBitNumber;\n            var slotsBelowBitNumber = packedSlotIndicators & (slotMask - 1);\n            var slotNumber = bitCount(slotsBelowBitNumber);\n            if ((packedSlotIndicators & slotMask) === 0) {\n                // The entryIndex slot does not have the contents we want\n                if (!insertAsNeeded) {\n                    return -1; // Index does not currently exist in packed array;\n                }\n                // Expand the entry, adding the index to new entry at the proper slot:\n                entryIndex = this.expandEntry(entryIndex, entryPointerIndex, slotNumber, slotMask, nextLevelIsLeaf);\n            }\n            // Next level's entry pointer index is in the appropriate slot in in the entries array in this entry:\n            entryPointerIndex =\n                entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + slotNumber;\n            entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n        }\n        // entryIndex is the long-index of a leaf entry that contains the value byte for the given set\n        var byteIndex = (entryIndex << 3) + (virtualIndex & 0x7); // Determine byte index offset within leaf entry\n        return byteIndex;\n    };\n    PackedArrayContext.prototype.determineTopLevelShiftForVirtualLength = function (virtualLength) {\n        var sizeMagnitude = ceil(log2(virtualLength));\n        var eightsSizeMagnitude = sizeMagnitude - 3;\n        var multipleOfFourSizeMagnitude = ceil(eightsSizeMagnitude / 4) * 4;\n        multipleOfFourSizeMagnitude = max(multipleOfFourSizeMagnitude, 8);\n        var topLevelShiftNeeded = multipleOfFourSizeMagnitude - 4 + 3;\n        return topLevelShiftNeeded;\n    };\n    PackedArrayContext.prototype.setVirtualLength = function (virtualLength) {\n        if (!this.isPacked) {\n            throw new Error(\"Should never be adjusting the virtual size of a non-packed context\");\n        }\n        this.topLevelShift = this.determineTopLevelShiftForVirtualLength(virtualLength);\n        this.virtualLength = virtualLength;\n    };\n    PackedArrayContext.prototype.getTopLevelShift = function () {\n        return this.topLevelShift;\n    };\n    //\n    //  ##     ##         ########   #######  ########  ##     ## ##          ###    ######## ########\n    //   ##   ##          ##     ## ##     ## ##     ## ##     ## ##         ## ##      ##    ##\n    //    ## ##           ##     ## ##     ## ##     ## ##     ## ##        ##   ##     ##    ##\n    //     ###    ####### ########  ##     ## ########  ##     ## ##       ##     ##    ##    ######\n    //    ## ##           ##        ##     ## ##        ##     ## ##       #########    ##    ##\n    //   ##   ##          ##        ##     ## ##        ##     ## ##       ##     ##    ##    ##\n    //  ##     ##         ##         #######  ##         #######  ######## ##     ##    ##    ########\n    //\n    PackedArrayContext.prototype.resizeArray = function (newLength) {\n        var tmp = new Uint8Array(newLength * 8);\n        tmp.set(this.byteArray);\n        this.array = tmp.buffer;\n        this.initArrayViews(this.array);\n        this.physicalLength = newLength;\n    };\n    PackedArrayContext.prototype.populateEquivalentEntriesWithEntriesFromOther = function (other) {\n        if (this.virtualLength < other.getVirtualLength()) {\n            throw new Error(\"Cannot populate array of smaller virtual length\");\n        }\n        for (var i = 0; i < NUMBER_OF_SETS; i++) {\n            var otherEntryIndex = other.getAtShortIndex(SET_0_START_INDEX + i);\n            if (otherEntryIndex == 0)\n                continue; // No tree to duplicate\n            var entryIndexPointer = SET_0_START_INDEX + i;\n            for (var i_1 = this.topLevelShift; i_1 > other.topLevelShift; i_1 -= 4) {\n                // for each inserted level:\n                // Allocate entry in other:\n                var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + 1;\n                var newEntryIndex = this.newEntry(sizeOfEntry);\n                // Link new level in.\n                this.setAtShortIndex(entryIndexPointer, newEntryIndex);\n                // Populate new level entry, use pointer to slot 0 as place to populate under:\n                this.setPackedSlotIndicators(newEntryIndex, 0x1); // Slot 0 populated\n                entryIndexPointer =\n                    newEntryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS; // Where the slot 0 index goes.\n            }\n            this.copyEntriesAtLevelFromOther(other, otherEntryIndex, entryIndexPointer, other.topLevelShift);\n        }\n    };\n    PackedArrayContext.prototype.copyEntriesAtLevelFromOther = function (other, otherLevelEntryIndex, levelEntryIndexPointer, otherIndexShift) {\n        var nextLevelIsLeaf = otherIndexShift == LEAF_LEVEL_SHIFT;\n        var packedSlotIndicators = other.getPackedSlotIndicators(otherLevelEntryIndex);\n        var numberOfSlots = bitCount(packedSlotIndicators);\n        var sizeOfEntry = NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + numberOfSlots;\n        var entryIndex = this.newEntry(sizeOfEntry);\n        this.setAtShortIndex(levelEntryIndexPointer, entryIndex);\n        this.setAtShortIndex(entryIndex + NON_LEAF_ENTRY_SLOT_INDICATORS_OFFSET, packedSlotIndicators);\n        for (var i = 0; i < numberOfSlots; i++) {\n            if (nextLevelIsLeaf) {\n                // Make leaf in other:\n                var leafEntryIndex = this.newLeafEntry();\n                this.setIndexAtEntrySlot(entryIndex, i, leafEntryIndex);\n                // OPTIM\n                // avoid iteration on all the values of the source ctx\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.longArray[leafEntryIndex] =\n                    other.longArray[otherNextLevelEntryIndex];\n            }\n            else {\n                var otherNextLevelEntryIndex = other.getIndexAtEntrySlot(otherLevelEntryIndex, i);\n                this.copyEntriesAtLevelFromOther(other, otherNextLevelEntryIndex, entryIndex + NON_LEAF_ENTRY_HEADER_SIZE_IN_SHORTS + i, otherIndexShift - 4);\n            }\n        }\n    };\n    PackedArrayContext.prototype.getAtUnpackedIndex = function (index) {\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.setAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.lazysetAtUnpackedIndex = function (index, newValue) {\n        this.longArray[index] = newValue;\n    };\n    PackedArrayContext.prototype.incrementAndGetAtUnpackedIndex = function (index) {\n        this.longArray[index]++;\n        return this.longArray[index];\n    };\n    PackedArrayContext.prototype.addAndGetAtUnpackedIndex = function (index, valueToAdd) {\n        this.longArray[index] += valueToAdd;\n        return this.longArray[index];\n    };\n    //\n    //   ########  #######           ######  ######## ########  #### ##    ##  ######\n    //      ##    ##     ##         ##    ##    ##    ##     ##  ##  ###   ## ##    ##\n    //      ##    ##     ##         ##          ##    ##     ##  ##  ####  ## ##\n    //      ##    ##     ## #######  ######     ##    ########   ##  ## ## ## ##   ####\n    //      ##    ##     ##               ##    ##    ##   ##    ##  ##  #### ##    ##\n    //      ##    ##     ##         ##    ##    ##    ##    ##   ##  ##   ### ##    ##\n    //      ##     #######           ######     ##    ##     ## #### ##    ##  ######\n    //\n    PackedArrayContext.prototype.nonLeafEntryToString = function (entryIndex, indexShift, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            var packedSlotIndicators = this.getPackedSlotIndicators(entryIndex);\n            output += \"slotIndiators: 0x\" + toHex(packedSlotIndicators) + \", prevVersionIndex: 0: [ \";\n            var numberOfslotsInEntry = bitCount(packedSlotIndicators);\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                output += this.getIndexAtEntrySlot(entryIndex, i);\n                if (i < numberOfslotsInEntry - 1) {\n                    output += \", \";\n                }\n            }\n            output += \" ] (indexShift = \" + indexShift + \")\\n\";\n            var nextLevelIsLeaf = indexShift == LEAF_LEVEL_SHIFT;\n            for (var i = 0; i < numberOfslotsInEntry; i++) {\n                var nextLevelEntryIndex = this.getIndexAtEntrySlot(entryIndex, i);\n                if (nextLevelIsLeaf) {\n                    output += this.leafEntryToString(nextLevelEntryIndex, indentLevel + 4);\n                }\n                else {\n                    output += this.nonLeafEntryToString(nextLevelEntryIndex, indexShift - 4, indentLevel + 4);\n                }\n            }\n        }\n        catch (ex) {\n            output += \"Exception thrown at nonLeafEnty at index \" + entryIndex + \" with indexShift \" + indexShift + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.leafEntryToString = function (entryIndex, indentLevel) {\n        var output = \"\";\n        for (var i = 0; i < indentLevel; i++) {\n            output += \"  \";\n        }\n        try {\n            output += \"Leaf bytes : \";\n            for (var i = 0; i < 8; i++) {\n                output += \"0x\" + toHex(this.byteArray[entryIndex * 8 + i]) + \" \";\n            }\n            output += \"\\n\";\n        }\n        catch (ex) {\n            output += \"Exception thrown at leafEnty at index \" + entryIndex + \"\\n\";\n        }\n        return output;\n    };\n    PackedArrayContext.prototype.toString = function () {\n        var output = \"PackedArrayContext:\\n\";\n        if (!this.isPacked) {\n            return output + \"Context is unpacked:\\n\"; // unpackedToString();\n        }\n        for (var setNumber = 0; setNumber < NUMBER_OF_SETS; setNumber++) {\n            try {\n                var entryPointerIndex = SET_0_START_INDEX + setNumber;\n                var entryIndex = this.getIndexAtShortIndex(entryPointerIndex);\n                output += \"Set \" + setNumber + \": root = \" + entryIndex + \" \\n\";\n                if (entryIndex == 0)\n                    continue;\n                output += this.nonLeafEntryToString(entryIndex, this.topLevelShift, 4);\n            }\n            catch (ex) {\n                output += \"Exception thrown in set \" + setNumber + \"%d\\n\";\n            }\n        }\n        //output += recordedValuesToString();\n        return output;\n    };\n    return PackedArrayContext;\n}());\nexports.PackedArrayContext = PackedArrayContext;\nvar toHex = function (n) {\n    return Number(n)\n        .toString(16)\n        .padStart(2, \"0\");\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/packedarray/PackedArrayContext.ts\n// module id = 27\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\nexports.default = ulp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 28\n// module chunks = 0"],"sourceRoot":""}